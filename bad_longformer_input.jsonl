{"code1": "import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStream; import java.io.PrintStream; import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; import static java.lang.Integer.*; import static java.lang.Character.*; public class B { Scanner scan; public B(Scanner s) { this.scan = s; } String[]A; long brut(char last, boolean[]U,boolean[]L) { long r =0; boolean all=true; for(int i=0;i<A.length;i++){ if(U[i])continue; all=false; boolean[]nl = L.clone(); char lc = \\'#\\'; for(char c:A[i].toCharArray()){ if(nl[c]) { if(lc!=c && !(c==last && c==A[i].charAt(0)))return 0; } nl[c]=true; } U[i]=true; r += brut(A[i].charAt(A[i].length()-1),U, nl); U[i]=false; } if(all)return 1; return r%1000000007; } public String solve() { int n = scan.nextInt(); A = new String[n]; for(int i=0;i<n;i++){ A[i]= \"\";String s =scan.next(); for(int j=0;j<s.length();j++) { if(A[i].length()==0 || A[i].charAt(A[i].length()-1)!=s.charAt(j))A[i]+=s.charAt(j); } System.out.print(A[i] +\" \"); } // System.out.println(); /* long res = brut(\\'#\\', new boolean[n], new boolean[256]); return \"\"+res; */ boolean[]EQ = new boolean[n]; for(int sn=0;sn<n;sn++){ String s = A[sn]; int d=0; boolean[] v = new boolean[256]; for(int i=0;i<s.length();i++){ if(v[s.charAt(i)] && s.charAt(i-1)!=s.charAt(i))return \"0\"; if(!v[s.charAt(i)]) { d++; v[s.charAt(i)]=true; } if(i>0 && s.charAt(i)!=s.charAt(0) && i+1<s.length() && s.charAt(i) !=s.charAt(s.length()-1)){ for(int j=0;j<n;j++){ if(j==sn)continue; for(char c:A[j].toCharArray()) { if(c==s.charAt(i))return \"0\"; } } } } EQ[sn]=d==1; } for(int i=0;i<n;i++)for(int j=0;j<n;j++){ if(i==j)continue; if(EQ[i]||EQ[j])continue; if(A[i].charAt(0)==A[j].charAt(0))return \"0\"; if(A[i].charAt(A[i].length()-1)==A[j].charAt(A[j].length()-1))return \"0\"; } boolean[][]M = new boolean[n][n]; int[]inc = new int[n]; int[]out = new int[n]; int parts =0; for(int i=0;i<n;i++){ if(EQ[i])continue; parts++; for(int j=0;j<n;j++){ if(EQ[j]||i==j)continue; if(A[i].charAt(A[i].length()-1)==A[j].charAt(0)){ M[i][j]=true; inc[j]++; out[i]++; } } } for(int i=0;i<n;i++)if(inc[i]>1||out[i]>1)return \"0\"; int ch=0; boolean cover[]=new boolean[n]; ArrayList<String> seg = new ArrayList<>(); for(int i=0;i<n;i++){ if(EQ[i])continue; if(inc[i]==0 && out[i]==0){ seg.add(A[i].charAt(0)+\"\"+A[i].charAt(A[i].length()-1)); cover[i]=true; } if(inc[i]>0 || out[i]==0)continue; String s =\"\"+A[i].charAt(0); int p =i; cover[p]=true; while(out[p]>0){ for(int j=0;j<n;j++) if(M[p][j]){ p=j; cover[p]=true; } } s+=A[p].charAt(A[p].length()-1); seg.add(s); } for(int i=0;i<n;i++)if(!EQ[i]&&!cover[i])return \"0\"; long res = 1; int free =0; long mod = 1000000007; for(char c = \\'a\\';c<=\\'z\\';c++){ int count=0;boolean att = false; for(int i=0;i<n;i++){ if(EQ[i]){ if(A[i].charAt(0)==c)count++; } } if(count==0)continue; for(int i=0;i<A.length;i++){ String s = A[i]; if(EQ[i])continue; if(s.charAt(0)==c || s.charAt(s.length()-1)==c)att=true; } if(!att && count >0)free++; for(int i=1;i<=count;i++)res = (res*i)%mod; } for(int i=1;i<=seg.size()+free;i++)res = (res*i)%mod; return \"\"+res; } int intLine(){ return parseInt(scan.nextLine()); } public static void main(String[] args) throws Exception{ Locale.setDefault(Locale.US); String cn = B.class.getName(); String sampleName = cn+\"-sample.in\"; String smallName = cn+\"-small-attempt4.in\"; String largeName = cn+\"-large.in\"; String name = largeName; String outName = name.substring(0, name.indexOf(\\'.\\'))+\".out\"; InputStream in = new BufferedInputStream(new FileInputStream(name)); PrintStream out = new PrintStream(new File(outName)); //PrintStream out = System.out; Scanner scan = new Scanner(in); int N = parseInt(scan.nextLine()); for(int c=1;c<=N;c++) { String res = new B(scan).solve(); out.printf(\"Case #%d: %s\\ \",c, res); System.err.println(c + \" done\"); } System.err.println(\"All done\"); } } '", "code2": "//Orz Sevenkplus #include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<ctime> #include<cctype> #include<complex> #include<algorithm> #include<iostream> #include<vector> #include<queue> #include<set> #include<map> #include<bitset> #define un using namespace un std; #define pb push_back #define pf pop_front #define mp make_pair #define c0 first #define c1 second #define sqr(x)((x)*(x)) #define clr(x)memset(x,0,sizeof(x)) #define clr1(x)memset(x,-1,sizeof(x)) #define clr80(x)memset(x,0x80,sizeof(x)) #define clr7F(x)memset(x,0x7F,sizeof(x)) #define ll long long #ifdef __unix__ #define LLD \"%lld\" #else #define LLD \"%I64d\" #endif #define pii pair<int,int> #define pip pair<int,pii> #define vi vector<int> #define vpi vector<pii> #define pq priority_queue template<typename T>inline bool chkmin(T&a,T b){return a>b?a=b,1:0;} template<typename T>inline bool chkmax(T&a,T b){return a<b?a=b,1:0;} #define modadd(a,b,c)(((a)+(b))%(c)) #define modmul(a,b,c)((int)(((ll)(a)*(b))%(c))) #define P 1000000007 #define getint(x){\\\\ char __next__char__;bool __nega__int__=0;\\\\ while(!isdigit(__next__char__=getchar())&&__next__char__!=\\'-\\');\\\\ __next__char__==\\'-\\'?(x=0,__nega__int__=1):(x=__next__char__-48);\\\\ while(isdigit(__next__char__=getchar()))x=x*10+__next__char__-48;\\\\ if(__nega__int__)x=-x;\\\\ } #define getint2(x1,x2){getint(x1);getint(x2);} #define getint3(x1,x2,x3){getint(x1);getint(x2);getint(x3);} #define getint4(x1,x2,x3,x4){getint(x1);getint(x2);getint(x3);getint(x4);} #define getint5(x1,x2,x3,x4,x5){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);} #define getint6(x1,x2,x3,x4,x5,x6){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);getint(x6);} char strr[200][200]; int f[26],b[26],e[26],l[200],s[26]; bool v[26]; bool check(int i){ char*str=strr[i]; clr(v); for(int j=l[i]-1;j--;){ if(str[j]!=str[j+1]){ if(v[str[j+1]-\\'a\\'])return 0; v[str[j+1]-\\'a\\']=1; } } return !v[str[0]-\\'a\\']; } int F[26]; int fa(int x){ int r=F[x],y=r; while(r!=F[r])r=F[r]; while((F[x]=r)!=(x=y))y=F[y]; return r; } int run(){ int n,ans=1; getint(n); clr(f); clr(b); clr(e); clr(s); for(int i=26;i--;)F[i]=i; for(int i=-1;++i!=n;){ clr(v); scanf(\"%s\",strr[i]); l[i]=strlen(strr[i]); char*str=strr[i]; if(str[0]==str[l[i]-1]){ e[str[0]-\\'a\\']++; ans=(ll)ans*e[str[0]-\\'a\\']%P; }else{ int x=fa(str[0]-\\'a\\'); int y=fa(str[l[i]-1]-\\'a\\'); if(x==y)return 0; F[x]=y; if(f[str[0]-\\'a\\']++){ return 0; } if(b[str[l[i]-1]-\\'a\\']++){ return 0; } } for(int j=l[i];j--;)v[str[j]-\\'a\\']=1; for(int j=26;j--;)s[j]+=v[j]; } for(int i=-1;++i!=n;){ char*str=strr[i]; if(!check(i)){ return 0; } for(int j=l[i];j--;) if(str[j]!=str[l[i]-1]&&str[j]!=str[0]){ if(s[str[j]-\\'a\\']>1)return 0; } } int q=0; for(int i=26;i--;){ if((e[i]||b[i])&&F[i]==i)q++; } while(q){ ans=(ll)ans*q%P; q--; } return ans; } int main(){ int T; getint(T); for(int t=1;t<=T;t++){ printf(\"Case #%d: %d\\ \",t,run()); } return 0; } '"}
{"code1": "def withoutDuplication(s): res = [] prev = -1 for c in s: i = ord(c) - ord(\\'a\\') if i != prev: res.append(i) prev = i return res mod = 1000000007 def fact(n): if n <= 1: return 1 return n*fact(n-1)%mod def solve(strs): n = 26 inE, outE, midE, badE = [0]*n, [0]*n, [0]*n, [0]*n g = [-1]*n for s in strs: letters = withoutDuplication(s) if len(letters) == 1: midE[letters[0]] += 1 else: outE[letters[0]] += 1 inE[letters[-1]] += 1 g[letters[0]] = letters[-1] for c in letters[1:-1]: badE[c] += 1 # print inE[:4], outE[:4], midE[:4], badE[:4], g[:4] for i in xrange(n): if badE[i] > 0 and inE[i] + outE[i] + midE[i] + badE[i] > 1: return 0 if inE[i] > 1 or outE[i] > 1: return 0 seen, nc = [False]*n, 0 for i in xrange(n): if seen[i] or inE[i] != 0: continue if outE[i] + midE[i] > 0: nc += 1 t = i while t != -1: seen[t] = True t = g[t] if len(filter(None, seen)) < n: return 0 #print nc res = fact(nc) for i in xrange(26): res *= fact(midE[i]) return res%mod T = int(raw_input()) for z in xrange(T): n = int(raw_input()) s = raw_input().strip().split(\\' \\') print \"Case #%d: %s\" % (z+1, solve(s))'", "code2": "#include <cstdlib> #include <cctype> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <vector> #include <string> #include <iostream> #include <sstream> #include <map> #include <set> #include <queue> #include <functional> using namespace std; typedef long long int64; #define PB push_back #define MP make_pair #define debug(x) cout<<(#x)<<\": \"<<(x)<<endl #define REP(i,n) for(int i=0;i<(n);++i) #define FOR(i,l,h) for(int i=(l);i<=(h);++i) #define FORD(i,h,l) for(int i=(h);i>=(l);--i) #define MOD 1000000007 inline int ADD(int a, int b) { a+=b; if (a>=MOD) a-=MOD; return (int)a; } inline void ADDTO(int &a, int b) { a+=b; if (a>=MOD) a-=MOD; } inline void SUBTO(int &a, int b) { a-=b; if (a<0) a+=MOD; } inline int MUL(int a, int b) { return (int)((int64)a*b%MOD); } int loop[30], indeg[30], oudeg[30], e[30][30], vis[30]; int fact[110], ans; void addEdge(char a, char b) { int u = a - \\'a\\', v = b - \\'a\\'; ++oudeg[u]; ++indeg[v]; e[u][v] = 1; } void dfs(int u) { vis[u] = 1; ans = MUL(ans, fact[loop[u]]); if (oudeg[u] > 0) { REP(v, 26) if (e[u][v] == 1) dfs(v); } } int main() { int tN; cin >> tN; fact[0] = 1; FOR(i, 1, 100) fact[i] = MUL(i, fact[i-1]); FOR(cN, 1, tN) { memset(loop, 0, sizeof(loop)); memset(indeg, 0, sizeof(indeg)); memset(oudeg, 0, sizeof(oudeg)); memset(e, 0, sizeof(e)); memset(vis, 0, sizeof(vis)); int n; cin >> n; REP(i, n) { string s; cin >> s; bool same = 1; REP(i, s.size()) { if (s[i] != s[0]) same = 0; if (i && s[i] != s[i-1]) addEdge(s[i-1], s[i]); } if (same) ++loop[s[0] - \\'a\\']; } bool nosol = 0; REP(i, 26) if (indeg[i] > 1 || oudeg[i] > 1) nosol = 1; if (!nosol) { ans = 1; int ncc = 0; REP(i, 26) if (!vis[i] && indeg[i] == 0) { if (oudeg[i] > 0 || loop[i] > 0) ++ncc; dfs(i); } ans = MUL(ans, fact[ncc]); REP(i, 26) if (!vis[i]) nosol = 1; } printf(\"Case #%d: \", cN); if (nosol) puts(\"0\"); else printf(\"%d\\ \", ans); } } '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; namespace CodeJam { internal class TestCase { public string[] Cars; } internal class Pair { public char First { get; set; } public char Last { get; set; } } internal class Program { private const string testFileName = \"B-large\"; private const int Base = 1000000007; public static IEnumerable<TestCase> ParseCases(TextReader reader) { var testCaseCount = int.Parse(reader.ReadLine()); for (var i = 0; i < testCaseCount; i++) { var carCount = int.Parse(reader.ReadLine()); var cars = reader.ReadLine().Split(); yield return new TestCase { Cars = cars }; } } private static long Solve(TestCase testCase) { // 3 types of cars // single letters: aaa // two letters: aabb // multiple letters aabcddd // simplify consecutive letters var withoutRuns = testCase.Cars.Select(RemoveConsecutive).ToArray(); var singleLetters = withoutRuns.Where(c => c.Length == 1).Select(c => c[0]).ToArray(); var hiddenLetters = withoutRuns.Where(c => c.Length > 2).SelectMany(c => c.Substring(1, c.Length - 2)).Distinct().ToArray(); var pairs = withoutRuns.Where(c => c.Length > 1).Select(c => new Pair { First = c[0], Last = c[c.Length - 1] }).ToArray(); // eliminate case 3 now if (pairs.Any(p => hiddenLetters.Contains(p.First) || hiddenLetters.Contains(p.Last)) || singleLetters.Any(hiddenLetters.Contains)) return 0; // we know just have to find orderings for pairs and single letters. // check that all the pairs can be ordered successfully if (pairs.Select(p => p.First).Distinct().Count() != pairs.Count() || pairs.Select(p => p.Last).Distinct().Count() != pairs.Count()) return 0; //check the groups that have an order imposed on them by the pairs var sortedPairs = GetFixedChains(pairs); if (sortedPairs == null) return 0; var singleLetterCounts = singleLetters.GroupBy(c => c, (key, values) => Tuple.Create(key, values.Count())); var lettersInChains = sortedPairs.SelectMany(p => p).SelectMany(p => new[] { p.First, p.Last }).Distinct(); var independentSingleLetters = singleLetters.Except(lettersInChains).ToArray(); // single letters can be in any order relative to each other long combinations = 1; foreach (var pair in singleLetterCounts) { combinations *= Factorial(pair.Item2); combinations %= Base; } // chains can be in any order relative to each other, and to the independent letters var independentBlockCount = independentSingleLetters.Count() + sortedPairs.Length; combinations *= Factorial(independentBlockCount); combinations %= Base; return combinations; } private static long Factorial(int x) { long fact = 1; while (x > 1) { fact *= x; fact %= Base; x--; } return fact; } private static Pair[][] GetFixedChains(Pair[] pairs) { var remainingPairs = pairs.ToList(); var sorted = new List<Pair[]>(); while (remainingPairs.Count > 0) { var chain = new List<Pair>(); var current = remainingPairs[0]; remainingPairs.RemoveAt(0); chain.Add(current); int index; var first = current; while ((index = remainingPairs.FindIndex(p => p.Last == first.First)) >= 0) { first = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Insert(0, first); } var last = current; while ((index = remainingPairs.FindIndex(p => p.First == last.Last)) >= 0) { last = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Add(last); } if (last.Last == first.First) return null; sorted.Add(chain.ToArray()); } return sorted.ToArray(); } private static string RemoveConsecutive(string arg) { var builder = new StringBuilder(arg.Length); char current = \\'\\\\0\\'; foreach (var c in arg) { if (c != current) { builder.Append(c); current = c; } } return builder.ToString(); } private static void Main(string[] args) { TestCase[] cases; using (var reader = new StreamReader(testFileName + \".in\")) using (var writer = new StreamWriter(testFileName + \".out\")) { cases = ParseCases(reader).ToArray(); for (int caseIndex = 0; caseIndex < cases.Length; caseIndex++) { var testCase = cases[caseIndex]; var solution = Solve(testCase); writer.WriteLine(\"Case #{0}: {1}\", caseIndex + 1, solution); } } } } }'", "code2": "#include <stdio.h> #include <stdlib.h> #include <string.h> #define M 1000000007LL //char *train[10]; int N; int count; int embedded[26]; int oneletter[26]; int endswith[26]; int startswith[26]; int impossible=0; int used; int segment; char *destutter(char *s) { static char buf2[200]; char *d=buf2; char last=0; while (*s) { if (*s!=last) last=*d++ = *s; s++; } *d=0; return buf2; } void readtrains(void) { int i,len,j; static char buff[200]; char *b; impossible=0; scanf(\"%d\",&N); for (i=0;i<26;i++) { embedded[i]=0; oneletter[i]=0; endswith[i]=-1; startswith[i]=-1; } for (i=0;i<N;i++) { scanf(\"%s\",buff); b=destutter(buff); len=strlen(b); if (len==1) { oneletter[*b-\\'a\\']++; continue; } if (startswith[*b-\\'a\\']>=0) impossible++; if (endswith[b[len-1]-\\'a\\']>=0) impossible++; startswith[*b-\\'a\\']=b[len-1]-\\'a\\'; endswith[b[len-1]-\\'a\\']=*b-\\'a\\'; for (j=1;j<len-1;j++) embedded[b[j]-\\'a\\']++; } } int modtimes(int a, int b) { return (int)((1LL*a*b) % M); } int factorial(int n) { int f=1; int i; if (n<=1) return 1; for (i=2;i<=n;i++) f=modtimes(f,i); return f; } void countonlyi(int i) { segment++; //printf(\"countonly %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); } void countendi(int i) { segment++; //printf(\"countend %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! while (1) { if ((1<<i) & used) {impossible++;return;} used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); i=endswith[i]; if (i<0) break; } } void countstarti(int i) { int used2=1<<i; //printf(\" Cs %c\\ \",i+\\'a\\'); while (startswith[i]>=0) { i=startswith[i]; //printf(\" cs %c\\ \",i+\\'a\\'); if (used2 & (1<<i)) { //printf(\"imp\\ \"); impossible++;return; } used2|=1<<i; } countendi(i); } void counttrains(void) { int i; count=1; used=0; segment=0; for (i=0;i<26;i++) { if (impossible || embedded[i]>1 || embedded[i] && (startswith[i]>=0 || endswith[i]>=0)) { printf(\"0\\ \"); //impossible return; } } i=0; while (i<26 && !impossible) { if (startswith[i]>=0 && !((1<<i) & used)) countstarti(i); if (endswith[i]>=0 && !((1<<i) & used)) countendi(i); if (oneletter[i]>0 && !((1<<i) & used)) countonlyi(i); i++; } if (impossible) printf(\"0\\ \"); else printf(\"%d\\ \",count); } void dump(void) { int i; printf(\"\\ \"); for (i=0;i<26;i++) { if (startswith[i]<0 && endswith[i]<0 && embedded[i]==0 && oneletter[i]==0) continue; printf(\" %c : ->%c %c<- em=%d 1L=%d\\ \",i+\\'a\\',startswith[i]+\\'a\\',endswith[i]+\\'a\\',embedded[i],oneletter[i]); } } int main(int argc, char **argv) { int tc,i; scanf(\"%d\",&tc); for (i=1;i<=tc;i++) { printf(\"Case #%d: \",i); readtrains(); //dump(); counttrains(); } return 0; } '"}
{"code1": "// uses http://introcs.cs.princeton.edu/java/stdlib/StdIn.java public class Train { static final int MOD = 1_000_000_007; public static long calc(String[] cars) { long result = 1; int n = cars.length; for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) { //System.out.println(java.util.Arrays.toString(cars)); int solocount = 0; int start = -1; int mid = -1; int end = -1; int solo = -1; for (int i=0; i<n; i++) { if (cars[i] == null) { } else if (cars[i].matches(\"\"+ch+\\'+\\')) { solocount++; result *= solocount; result %= MOD; cars[i] = null; solo = i; } else if (cars[i].matches(ch+\"+[^\"+ch+\"]+\")) { if (start != -1) return 0; start = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+\")) { if (end != -1) return 0; end = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+[^\"+ch+\"]+\")) { if (mid != -1) return 0; mid = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\")) { } else return 0; } //System.out.println(ch+\" \"+solocount+\" \"+start+\" \"+solo+\" \"+end+\" \"+result); if (mid == -1 && solocount == 0 && start == -1 && end == -1) continue; if (mid != -1 && (solocount > 0 || start != -1 || end != -1)) return 0; if (mid != -1) continue; String repl = \"\"; if (end != -1) {repl += cars[end]; cars[end] = null;} if (solo != -1) repl += ch; if (start != -1) {repl += cars[start]; cars[start] = null;} if (start != -1) {cars[start] = repl;} else if (solo != -1) {cars[solo] = repl;} else cars[end] = repl; } int left = 0; for (String s : cars) if (s != null) { left ++; result *= left; result %= MOD; } return result; } public static void main(String[] args) { int q = StdIn.readInt(); for (int j=1; j<=q; j++) { int n = StdIn.readInt(); String[] cars = new String[n]; { for (int i=0; i<n; i++) cars[i] = StdIn.readString(); } System.out.printf(\"Case #%d: %d\\ \", j, calc(cars)); } } } '", "code2": "import static java.lang.Math.*; import java.io.*; import java.math.*; import java.util.*; public class ProblemBLarge { static class Car { String s; LinkedHashMap<Character, Long> numAddedSameCharCars = new LinkedHashMap<Character, Long>(); char getFirst() { return s.charAt(0); } char getLast() { return s.charAt(s.length() - 1); } void addAllSameChars(Car car) { for (Map.Entry<Character, Long> entry : car.numAddedSameCharCars.entrySet()) { Character key = entry.getKey(); Long value = numAddedSameCharCars.get(key); if (value == null) value = 0L; value += entry.getValue(); numAddedSameCharCars.put(key, value); } } @Override public String toString() { return \"\"+s+\" (\"+numAddedSameCharCars+\")\"; } } public class Case { LinkedHashSet<Car> cars = new LinkedHashSet<Car>(); LinkedHashSet<Car> carsToCheck = new LinkedHashSet<Car>(); public void solve(int caseIndex) { for (Car car : cars) { if (isSameCharCar(car)) { car.numAddedSameCharCars.put(car.s.charAt(0), 1L); } } // System.out.println(\"Cars: \"+cars); carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); // LinkedHashSet<Car> carsWithSameChar = new LinkedHashSet<Car>(); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); if (isSameCharCar(car)) { for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } } carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } BigInteger result; if (!isValid()) { result = BigInteger.valueOf(0); } else { long mod = 1000000007L; result = BigInteger.valueOf(1); for (long i = 1; i <= cars.size(); i++) { result = result.multiply(BigInteger.valueOf(i)); } for (Car car : cars) { for (Long sameChars : car.numAddedSameCharCars.values()) { long a = 1; for (long i = 1; i <= sameChars; i++) { a *= i; a %= mod; } result = result.multiply(BigInteger.valueOf(a)); } } result = result.mod(BigInteger.valueOf(mod)); } // long result; // if (!isValid()) { // result = 0; // } // else { // long mod = 1000000007L; // // result = 1; // for (long i = 1; i <= cars.size(); i++) { // result *= i; // result %= mod; // } // // for (Car car : cars) { // for (Long sameChars : car.numAddedSameCharCars.values()) { // long a = 1; // for (long i = 1; i <= sameChars; i++) { // a *= i; // a %= mod; // } // result *= a; // result %= mod; // } // } // } println(\"Case #\" + (caseIndex + 1) + \": \" + result); } void combineCars(Car car1, Car car2) { Car car = new Car(); car.s = car1.s + car2.s; car.addAllSameChars(car1); car.addAllSameChars(car2); // car.numAddedSameCharCars = car1.numAddedSameCharCars + car2.numAddedSameCharCars; cars.add(car); carsToCheck.add(car); cars.remove(car1); carsToCheck.remove(car1); cars.remove(car2); carsToCheck.remove(car2); // System.out.println(\"Cars: \"+cars); } boolean isSameCharCar(Car car) { String s = car.s; for (int k = 0; k < s.length(); k++) { if (s.charAt(k) != s.charAt(0)) { return false; } } return true; } boolean isValid() { LinkedHashSet<Character> processed = new LinkedHashSet<>(); Character last = null; for (Car car : cars) { String s = car.s; for (int k = 0; k < s.length(); k++) { char ch = s.charAt(k); // System.out.println(\"Current: \"+ch); if (last != null && last.charValue() == ch) { // System.out.println(\"Last: \"+last+\", processed: \"+processed); } else { if (processed.contains(ch)) return false; processed.add(ch); } last = ch; } } return true; } long factorial(long p) { long result = 1; for (long i = 2; i <= p; i++) result *= i; return result; } } public void run() throws Exception { BufferedReader r = new BufferedReader(new FileReader(\"input.txt\")); int numCases = new InputParser(r.readLine()).readInt(); for (int caseIndex = 0; caseIndex < numCases; caseIndex++) { Case c = new Case(); InputParser p = new InputParser(r.readLine()); int numCars = p.readInt(); p = new InputParser(r.readLine()); for (int i = 0; i < numCars; i++) { Car car = new Car(); car.s = p.readToken(); c.cars.add(car); } c.solve(caseIndex); } r.close(); } public static void main(String[] args) throws Exception { fileWriter = new PrintWriter(new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"output.txt\")))); new ProblemBLarge().run(); fileWriter.close(); } public static class InputParser { String text; int pos; public InputParser(String text) { this.text = text; } public void skipSpaces() { while (pos < text.length()) { if (text.charAt(pos) != \\' \\') break; pos++; } } public String readUntil(char expectedChar) { StringBuilder b = new StringBuilder(); while (pos < text.length()) { char ch = text.charAt(pos); if (ch == expectedChar) break; b.append(ch); pos++; } return b.toString(); } public String readToken() { skipSpaces(); return readUntil(\\' \\'); } public int readInt() { return Integer.parseInt(readToken()); } public long readLong() { return Long.parseLong(readToken()); } public double readDouble() { return Double.parseDouble(readToken()); } public char readChar() { char ch = text.charAt(pos); pos++; return ch; } public void readExpectedString(String s) { for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (readChar() != ch) throw new RuntimeException(\"Expected: \"+ch); } } } public static PrintWriter fileWriter; public static void print(String text) { fileWriter.print(text); System.out.print(text); } public static void println(String text) { fileWriter.println(text); System.out.println(text); } public static <Key, Value> void addToMultiMapArrayList(Key key, Value value, Map<Key, ArrayList<Value>> map) { ArrayList<Value> list = map.get(key); if (list == null) { list = new ArrayList<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> void addToMultiMapLinkedHashSet(Key key, Value value, Map<Key, LinkedHashSet<Value>> map) { LinkedHashSet<Value> list = map.get(key); if (list == null) { list = new LinkedHashSet<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> ArrayList<Value> getMultiMapValues(Map<Key, Collection<Value>> map) { ArrayList<Value> result = new ArrayList<Value>(); for (Collection<Value> list : map.values()) { result.addAll(list); } return result; } // binarySearch(, , 0.000000001, new Function<Double, Integer>() { // public Integer evaluate(Double key) { // return ; // } // }); public static double binarySearch(double low, double high, double precision, Function<Double, Integer> f) { if (high < low) throw new RuntimeException(\"High (\"+high+\") cannot be smaller than low (\"+low+\")\"); { int lowValue = f.evaluate(low); if (lowValue == 0) return low; if (lowValue > 0) throw new RuntimeException(\"Unsuitable low: \"+low); } { int highValue = f.evaluate(high); if (highValue == 0) return high; if (highValue < 0) throw new RuntimeException(\"Unsuitable high: \"+high); } while (true) { double mid = (low + high) * 0.5; if (abs(high - low) < precision) { return mid; } int c = f.evaluate(mid); if (c < 0) low = mid; else if (c > 0) high = mid; else return mid; } } public static <T> LinkedHashSet<T> intersection(Set<T> s1, Set<T> s2) { if (s2.size() < s1.size()) { Set<T> temp = s1; s1 = s2; s2 = temp; } LinkedHashSet<T> result = new LinkedHashSet<T>(); for (T o : s1) { if (s2.contains(o)) result.add(o); } return result; } public static interface Function<Key, Value> { public Value evaluate(Key key); } public static class Int2 { int x, y; public Int2(int x, int y) { this.x = x; this.y = y; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Int2 other = (Int2) obj; if (x != other.x) return false; if (y != other.y) return false; return true; } @Override public String toString() { return \"(\"+x+\",\"+y+\")\"; } } } '"}
{"code1": "#include <iostream> #include <fstream> #include <string> #include <algorithm> #include <cstdlib> #include <cstring> #include <set> #include <map> #include <vector> #include <stack> #include <queue> #include <deque> #include <iomanip> #include <cassert> typedef long long ll; typedef unsigned long long ull; using namespace std; bool is_aaa(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] != c) return false; } return true; } bool is_aax(const string& s, char c) { return s[0] == c; } bool is_yaa(const string& s, char c) { return s[(int)s.size() - 1] == c; } bool is_uav(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] == c) return true; } return false; } int fragment_count(const string& s, char c) { int result = 0; int n = (int)s.size(); int i = 0; while (i < n) { if (s[i] != c) i++; else { int j = i; while (j + 1 < n && s[j + 1] == c) j++; result++; i = j + 1; } } return result; } const int MAXN = 109; int N; string s[MAXN]; vector<string> pieces; const ll MOD = 1000000007; ll fact[MAXN]; ll solve(void) { pieces.clear(); for (int i = 0; i < N; i++) pieces.push_back(s[i]); ll result = 1; for (char c = \\'a\\'; c <= \\'z\\'; c++) { vector<string> aaa; vector<string> aax; vector<string> yaa; vector<string> uav; vector<string> other; for (int i = 0; i < pieces.size(); i++) { if (is_aaa(pieces[i], c)) aaa.push_back(pieces[i]); else if (is_aax(pieces[i], c)) aax.push_back(pieces[i]); else if (is_yaa(pieces[i], c)) yaa.push_back(pieces[i]); else if (is_uav(pieces[i], c)) uav.push_back(pieces[i]); else other.push_back(pieces[i]); } if (uav.size() != 0) { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0 && uav.size()==1 && fragment_count(uav[0], c)==1) { ; } else return 0LL; } else { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0) { ; // no constraints at all } else { if (yaa.size() <= 1 && aax.size() <= 1) { if (yaa.size() == 1) { if (fragment_count(yaa[0], c) > 1) return 0LL; } if (aax.size() == 1) { if (fragment_count(aax[0], c) > 1) return 0LL; } result *= fact[aaa.size()]; result %= MOD; pieces = other; string new_piece; if (yaa.size() != 0) new_piece += yaa[0]; for (int i = 0; i < aaa.size(); i++) new_piece += aaa[i]; if (aax.size() != 0) new_piece += aax[0]; pieces.push_back(new_piece); } else return 0LL; } } } result *= fact[pieces.size()]; result %= MOD; return result; } void solve_B(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; fact[0] = 1LL; for (int i = 1; i < MAXN; i++) fact[i] = (fact[i - 1] * i) % MOD; for (int tt = 1; tt <= T; tt++) { for (int i = 0; i < MAXN; i++) s[i] = \"\"; in >> N; for (int i = 0; i < N; i++) in >> s[i]; ll temp = solve(); out << \"Case #\" << tt << \": \"; out << temp; out << \\'\\ \\'; } in.close(); out.close(); } int main() { //solve_A(); solve_B(); //solve_C(); return 0; } void solve_(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; for (int tt = 1; tt <= T; tt++) { out << \"Case #\" << tt << \": \"; } in.close(); out.close(); }'", "code2": "import java.util.HashSet; import java.util.Scanner; import java.util.Set; public class B { static final long BASE = 1000000007; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int cases = sc.nextInt(); long[] factorial = new long[101]; factorial[0] = 1; for (int i = 1; i < 101; i++) { factorial[i] = (factorial[i - 1] * i) % BASE; } for (int caseNum = 1; caseNum <= cases; caseNum++) { int N = sc.nextInt(); String[] cars = new String[N]; Set<Character> interior = new HashSet<Character>(); int[] singleLetterStrs = new int[26]; int[] starts = new int[26]; int[] ends = new int[26]; char[] next = new char[26]; boolean possible = true; for (int i = 0; i < N; i++) { cars[i] = sc.next(); int firstChar = cars[i].charAt(0) - \\'a\\'; char lastChar = cars[i].charAt(cars[i].length() - 1); if (isSingleLetter(cars[i])) { int index = firstChar; singleLetterStrs[index]++; } else { for (Character ch : getInteriorChars(cars[i])) { if (interior.contains(ch)) { possible = false; break; } interior.add(ch); } starts[firstChar]++; ends[lastChar - \\'a\\']++; next[firstChar] = lastChar; } } int numGroups = 0; for (int i = 0; i < 26; i++) { if (!possible) { break; } char ch = (char) (\\'a\\' + i); if (interior.contains(ch) && (singleLetterStrs[i] + starts[i] + ends[i] > 0)) { possible = false; } if (starts[i] > 1 || ends[i] > 1) { possible = false; } if (singleLetterStrs[i] > 0 && starts[i] == 0 && ends[i] == 0) { numGroups++; } else if (starts[i] == 1 && ends[i] == 0) { numGroups++; } } possible = possible && !hasCycles(next); System.out.print(\"Case #\" + caseNum + \": \"); if (!possible) { System.out.println(0); continue; } long ways = 1; for (int i = 0; i < 26; i++) { ways = (ways * factorial[singleLetterStrs[i]]) % BASE; } ways = (ways * factorial[numGroups]) % BASE; System.out.println(ways); } } private static boolean hasCycles(char[] next) { for (int i = 0; i < 26; i++) { if (next[i] == 0) { continue; } char start = (char) (\\'a\\' + i); int currIndex = i; while (next[currIndex] != 0 && next[currIndex] != start) { currIndex = next[currIndex] - \\'a\\'; } if (next[currIndex] == start) { return true; } } return false; } private static Set<Character> getInteriorChars(String str) { Set<Character> chars = new HashSet<Character>(); if (isSingleLetter(str)) { return chars; } int startIndex = 0; while (str.charAt(startIndex + 1) == str.charAt(0)) { startIndex++; } int endIndex = str.length() - 1; while (str.charAt(endIndex - 1) == str.charAt(str.length() - 1)) { endIndex--; } for (int i = startIndex + 1; i < endIndex; i++) { chars.add(str.charAt(i)); } return chars; } private static boolean isSingleLetter(String str) { char ch = str.charAt(0); for (int i = 1; i < str.length(); i++) { if (str.charAt(i) != ch) { return false; } } return true; } } '"}
{"code1": "#include <stdio.h> #include <stdlib.h> #include <math.h> #include <ctype.h> #include <string.h> int TC, T; int Cars; char Car[120][120]; char Visited[130]; int Stack[120]; int Used[120]; int i, x, y, L, Ans; char Last; int DFS(int Level){ if (Level==Cars){ int i, x; Last = Car[Stack[0]][0]; memset(Visited, 0, sizeof(Visited)); Visited[Last] = 1; for (i=0; i<Cars; i++){ L = strlen(Car[Stack[i]]); for (x=0; x<L; x++){ if (Car[Stack[i]][x]==Last) continue; if (Visited[Car[Stack[i]][x]]) return ; Visited[Car[Stack[i]][x]] = 1; Last = Car[Stack[i]][x]; } } Ans++; return ; } int i; for (i=0; i<Cars; i++) if (!Used[i]){ Used[i] = 1; Stack[Level] = i; DFS(Level+1); Used[i] = 0; } } int main(){ freopen(\"B-small-attempt0.in\", \"r\", stdin); freopen(\"B-small-attempt0.out\", \"w\", stdout); scanf(\"%d\", &TC); for (T=1; T<=TC; T++){ printf(\"Case #%d: \", T); scanf(\"%d\", &Cars); for (i=0; i<Cars; i++) scanf(\"%s\", Car[i]); Ans = 0; DFS(0); printf(\"%d\\ \", Ans); } return 0; } '", "code2": "#!/usr/bin/pypy import itertools,math,sys def simple_solve(N,S): S = sorted(S) cnt = 0 for perm in itertools.permutations(S): z = \"\".join(perm) chars = [False for _ in range(26)] last = \\'\\' for c in z: if last==c: continue last = c if chars[ord(c)-ord(\\'a\\')]: break chars[ord(c)-ord(\\'a\\')] = True else: cnt += 1 return cnt def true_solve(N,S): rz = {} for c in range(26): char = chr(c+ord(\\'a\\')) cnt_inside = cnt_left = cnt_right = cnt_full = 0 left_char = right_char = \"\" for z in S: h = False last = \"\" for x in z: if x==char and h and last != char: return 0 if x==char: h = True last = x if z[0] == z[-1] == char: cnt_full += 1 elif z[0] == char: cnt_left += 1 right_char = z[-1] elif z[-1] == char: cnt_right += 1 left_char = z[0] elif h: cnt_inside += 1 if cnt_inside > 1 or cnt_inside > 0 and cnt_left+cnt_right+cnt_full>0 or cnt_left>1 or cnt_right>1: return 0 if cnt_inside == 0 and cnt_left+cnt_right+cnt_full>0: rz[char] = ((left_char,right_char,math.factorial(cnt_full))) blocks = 0 bb = 1 while rz: for c,v in rz.items(): if v[0]==\"\": break else: return 0 del rz[c] bb *= v[2] while v[1] != \"\": if v[1] not in rz: return 0 v = rz.pop(v[1]) bb *= v[2] blocks += 1 return math.factorial(blocks)*bb%1000000007 def solve(): N = int(raw_input()) S = raw_input().strip().split() val1 = true_solve(N,S) #val2 = simple_solve(N,S) #if val1 != val2: # print \"Bad\" # print N,S # print val1,val2 # sys.exit(1) return val1 T = int(raw_input()) for t in range(1,T+1): print \"Case #%d:\"%t,solve() '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Linq; using System.Numerics; using System.Text; using System.Threading.Tasks; namespace GCJ2014R1CB { class Program { /// <summary> /// \\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe6\\x95\\xb0 /// </summary> static int ThreadCount = 1; /// <summary> /// \\xe9\\x80\\xb2\\xe6\\x8d\\x97\\xe3\\x82\\x92\\xe8\\xa1\\xa8\\xe7\\xa4\\xba\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 /// </summary> static bool Verbose = true; static int ProgressInterval = 1; class Solver { public List<string> SolveAll(int threadId, StreamReader sr) { // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ int TestCase = int.Parse(sr.ReadLine()); // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ List<string> outputs = new List<string>(); for (int testCase = 0; testCase < TestCase; testCase++) { // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ int N = int.Parse(sr.ReadLine()); string l = sr.ReadLine(); // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ #region if (testCase % ThreadCount != threadId) { // \\xe3\\x81\\x93\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xae\\xe6\\x8b\\x85\\xe5\\xbd\\x93\\xe3\\x81\\xa7\\xe3\\x81\\xaf\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe3\\x81\\xae\\xe3\\x81\\xa7\\xe8\\xa7\\xa3\\xe3\\x81\\x8b\\xe3\\x81\\xaa\\xe3\\x81\\x84 continue; } if (Verbose) { if (testCase % ProgressInterval == 0) { Console.Error.WriteLine(testCase + \" / \" + TestCase); } } #endregion // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ string output = Solve(testCase, l); // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ outputs.Add(output); } return outputs; } const long Mod = 1000000007; string Solve(int testCase, string l) { if (testCase == -1) { } List<string> ts = l.Split(\\' \\').ToList(); BigInteger ans = 1; for(char c = \\'a\\'; c <= \\'z\\'; c++) { int ct = 0; string ns = \"\"; for(int i = 0; i < ts.Count; i++) { if (ts[i].First() == c && ts[i].Last() == c) { ns += ts[i]; ct++; ans *= ct; ts.RemoveAt(i); i--; } } if (ct > 0) { ts.Add(ns); } } for(;;) { bool f = Update(ts, true); if (f == false) { break; } } for(;;) { bool f = Update(ts, false); if (f == false) { break; } } string all = string.Concat(ts); for(char c = \\'a\\'; c <= \\'z\\'; c++) { int first = all.IndexOf(c); if (first < 0) { continue; } int last = all.LastIndexOf(c); for(int i = first; i < last; i++) { if (all[i] != c) { return \"0\"; } } } for(int i = 1; i <= ts.Count; i++) { ans *= i; } ans %= Mod; return ans.ToString(); } static bool Update(List<string> ts, bool primary) { int N = ts.Count(); for(int i = 0; i < N; i++) { if (primary && ts[i].First() != ts[i].Last()) { continue; } for(int j = 0; j < N; j++) { if (i == j) { continue; } if (ts[i].Last() == ts[j].First()) { ts[i] += ts[j]; ts.RemoveAt(j); return true; } } } return false; } } static void Main(string[] args) { // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\x84\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\x9f\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\xab\\xe5\\xaf\\xbe\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe5\\x87\\xa6\\xe7\\x90\\x86\\xe3\\x82\\x92\\xe8\\xa1\\x8c\\xe3\\x81\\x86\\xe3\\x80\\x82 // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe3\\x82\\xab\\xe3\\x83\\xac\\xe3\\x83\\xb3\\xe3\\x83\\x88\\xe3\\x83\\x87\\xe3\\x82\\xa3\\xe3\\x83\\xac\\xe3\\x82\\xaf\\xe3\\x83\\x88\\xe3\\x83\\xaa\\xe3\\x81\\xae large \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81 // small \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81sample.in \\xe3\\x82\\x92\\xe9\\xa0\\x86\\xe3\\x81\\xab\\xe6\\xa4\\x9c\\xe7\\xb4\\xa2\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 // large \\xe3\\x82\\x84 small \\xe3\\x81\\x8c\\xe8\\xa4\\x87\\xe6\\x95\\xb0\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe5\\x90\\x8d\\xe5\\x89\\x8d\\xe3\\x81\\xa7\\xe3\\x82\\xbd\\xe3\\x83\\xbc\\xe3\\x83\\x88\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe4\\xb8\\x80\\xe7\\x95\\xaa\\xe6\\x9c\\x80\\xe5\\xbe\\x8c\\xe3\\x81\\xae\\xe3\\x82\\x92\\xe4\\xbd\\xbf\\xe3\\x81\\x86\\xe3\\x80\\x82 string inputName = null; if (args.Length > 0) { if (File.Exists(args[0]) == false) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } inputName = args[0]; } if (inputName == null) { List<string> larges = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"large\") && fi.Name.EndsWith(\".in\")) { larges.Add(fi.FullName); } } if (larges.Count > 0) { larges.Sort(); inputName = larges[larges.Count - 1]; } } if (inputName == null) { List<string> smalls = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"small\") && fi.Name.EndsWith(\".in\")) { smalls.Add(fi.FullName); } } if (smalls.Count > 0) { smalls.Sort(); inputName = smalls[smalls.Count - 1]; } } if (inputName == null) { foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.ToLower() == \"sample.in\") { inputName = fi.FullName; break; } } } if (inputName == null) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } // \\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe5\\x85\\x88\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x82\\x92\\xe6\\xb1\\xba\\xe5\\xae\\x9a\\xe3\\x81\\x97\\xe3\\x80\\x81\\xe5\\x90\\x8c\\xe5\\x90\\x8d\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x83\\xaa\\xe3\\x83\\x8d\\xe3\\x83\\xbc\\xe3\\x83\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 string outputName = inputName; if (outputName.EndsWith(\".in\")) { outputName = outputName.Substring(0, outputName.Length - 3); } outputName += \".out\"; if (File.Exists(outputName)) { int rev = 1; while (File.Exists(outputName + \".\" + rev)) { rev++; } File.Move(outputName, outputName + \".\" + rev); } // \\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82ThreadCount == 1 \\xe3\\x81\\xaa\\xe3\\x82\\x89\\xe3\\x80\\x81\\xe7\\x8f\\xbe\\xe5\\x9c\\xa8\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xa7\\xe3\\x80\\x81\\xe3\\x81\\x9d\\xe3\\x82\\x8c\\xe4\\xbb\\xa5\\xe5\\xa4\\x96\\xe3\\x81\\xaa\\xe3\\x82\\x89 Parallel \\xe3\\x81\\xa7\\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 List<string>[] outputs = new List<string>[ThreadCount]; if (ThreadCount == 1) { for (int i = 0; i < ThreadCount; i++) { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } } } else { Parallel.For(0, ThreadCount, i => { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } }); } // \\xe7\\xb5\\x90\\xe6\\x9e\\x9c\\xe3\\x82\\x92\\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82Case # \\xe3\\x81\\xaf\\xe3\\x81\\x93\\xe3\\x81\\x93\\xe3\\x81\\xa7\\xe4\\xbb\\x98\\xe5\\x8a\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 using (StreamWriter sw = new StreamWriter(outputName)) { for (int i = 0; ; i++) { if (outputs[i % ThreadCount].Count > i / ThreadCount) { sw.WriteLine(\"Case #\" + (i + 1) + \": \" + outputs[i % ThreadCount][i / ThreadCount]); } else { break; } } } } } } '", "code2": "#include<stdio.h> #include<stdlib.h> #include<string.h> #define MOD 1000000007LL int t,T,n,N; long long frac[128]; long long C; char s[128][128]; long long ans; char start[128];/*First Letter*/ char end[128];/*Last Letter*/ char blocked[256]; /*Internal characters*/ int first; int tmp; int c; int only_start[256]; int only_end[256]; int loops[256]; int done[256]; int num_frag; char tmp2; char tmp3; int main(){ scanf(\"%d\",&T); frac[0]=1; for(C=1;C<120;C++) frac[C]=(frac[C-1]*C)%MOD; for(t=1;t<=T;t++){ scanf(\"%d\",&N); for(n=1;n<=N;n++){scanf(\"%s\",&s[n][0]);} for(c=0;c<256;c++) { blocked[c]=0; only_start[c]=0; only_end[c]=0; loops[c]=0; } ans=1; for(n=1;n<=N;n++) { tmp=strlen(s[n]); first=1; start[n]=s[n][0]; end[n]=s[n][tmp-1]; for(c=1;c<tmp;c++) { if (s[n][c]!=s[n][c-1]) { if (blocked[s[n][c]]==1) ans=0; if (first==0) { blocked[s[n][c-1]]=1; } first=0; } } if ((start[n]==end[n])&&(first==0)) ans=0; } if (ans==1) { for(n=1;n<=N;n++) { if (blocked[start[n]]==1) ans=0; if (blocked[end[n]]==1) ans=0; } } if (ans==1) { for(n=1;n<=N;n++) { if (start[n]==end[n]) {loops[start[n]]++;} else { only_start[start[n]]++; only_end[end[n]]++; } } for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if (only_start[tmp2]>1) ans=0; if (only_end[tmp2]>1) ans=0; } } if (ans==1) { num_frag=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) num_frag++; if ((only_start[tmp2]==0)&&(only_end[tmp2]==0)&&(loops[tmp2]>0)) num_frag++; ans*=frac[loops[tmp2]]; ans%=MOD; } ans*=frac[num_frag]; ans%=MOD; } /*Detect cycles*/ if (ans!=0) { for(c=0;c<256;c++) done[c]=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) { tmp3=tmp2; do{ for(n=1;n<=N;n++) { if ((start[n]==tmp3)&&(start[n]!=end[n])) break; } done[n]=1; tmp3=end[n]; } while (only_start[tmp3]==1); } } for(n=1;n<=N;n++) { if ((done[n]==0)&&(start[n]!=end[n])) ans=0; } } printf(\"Case #%d: \",t); printf(\"%lld\\ \",ans); } return 0; } '"}
{"code1": "//#pragma comment(linker, \"/STACK:134217728\") #include <iostream> #include <sstream> #include <cstdio> #include <cstdlib> #include <cmath> #include <cctype> #include <cstring> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> #include <numeric> using namespace std; typedef long long Int; typedef pair<int,int> PII; typedef vector<int> VInt; #define FOR(i, a, b) for(i = (a); i < (b); ++i) #define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i) #define CLEAR(a, b) memset(a, b, sizeof(a)) #define SIZE(a) int((a).size()) #define ALL(a) (a).begin(),(a).end() #define PB push_back #define MP make_pair #define MOD 1000000007 string S[256]; int A[256]; int C[256]; int Next[256]; int Prev[256]; int B[256]; Int dfs(int a) { if (a == -1) return 1; B[a] = 1; Int res = 1; int i; FOR(i, 0, C[a]) res = res * (i + 1) % MOD; return res * dfs(Next[a]) % MOD; } Int f(int n) { CLEAR(A, 0); CLEAR(C, 0); CLEAR(Next, -1); CLEAR(Prev, -1); int i, j; FOR(i, 0, n) { char first = S[i].front(); char last = S[i].back(); FOR(j, 1, SIZE(S[i]) - 1) { char mid = S[i][j]; if (A[mid] == 0) ++A[mid]; else return 0; } if (first == last) { if (SIZE(S[i]) == 1) ++C[first]; else return 0; } else { if (Next[first] != -1) return 0; if (Prev[last] != -1) return 0; Next[first] = last; Prev[last] = first; } } FOR(i, 0, 256) if (A[i] != 0 && (C[i] != 0 || Next[i] != -1 || Prev[i] != -1)) return 0; Int res = 1; int cnt = 0; CLEAR(B, 0); FOR(i, 0, 256) if (B[i] == 0 && Prev[i] == -1) { if (C[i] != 0 || Next[i] != -1) ++cnt; res *= dfs(i); res %= MOD; } FOR(i, 0, cnt) res = res * (i + 1) % MOD; FOR(i, 0, 256) if (B[i] == 0) return 0; return res; } int SolveTest(int test) { int n; scanf(\"%d\", &n); int i, j; FOR(i, 0, n) { char buf[128]; scanf(\"%s\", buf); int len = strlen(buf); string s; int prev = 0; FOR(j, 1, len + 1) if (j == len || buf[j] != buf[prev]) { s.push_back(buf[prev]); prev = j; } S[i] = s; } printf(\"Case #%d: %d\\ \", test + 1, int(f(n))); return 0; } int main() { freopen(\"b.in\", \"r\", stdin); freopen(\"b.out\", \"w\", stdout); int T, t; char buf[1 << 7]; gets(buf); sscanf(buf, \"%d\", &T); FOR(t, 0, T) { fprintf(stderr, \"Solving %d/%d\\ \", t + 1, T); SolveTest(t); } return 0; }; '", "code2": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Linq; using System.Text; using System.IO; namespace ProblemA { class Program { static void Main(string[] args) { using (var sr = new StreamReader(@\"..\\\\..\\\\B-small-attempt0.in\")) { using (var sw = new StreamWriter(@\"..\\\\..\\\\B-small-attempt0.out\")) { var T = int.Parse(sr.ReadLine()); for (int t = 1; t <= T; t++) { sr.ReadLine(); var s = sr.ReadLine().Split(); var k = Enumerable.Range(0, s.Length).ToArray(); int res = 0; do { //for (int i = 0; i < k.Length; i++) //{ // Console.Write(k[i]); // Console.Write(\" \"); //} //Console.WriteLine(); //continue; var u = new bool[50]; int i; for (i = 0; i < k.Length; i++) { int j; for (j = 0; j < s[k[i]].Length; j++) { if (u[s[k[i]][j] - \\'a\\']) { if (j > 0) { if (s[k[i]][j - 1] != s[k[i]][j]) { break; } } else { if (s[k[i - 1]][s[k[i - 1]].Length - 1] != s[k[i]][j]) { break; } } } u[s[k[i]][j] - \\'a\\'] = true; } if (j < s[k[i]].Length) { break; } } if (i == k.Length) { res++; } } while (NextPermutation(k)); sw.WriteLine(\"Case #{0}: {1}\", t, res); } } } } private static bool NextPermutation(int[] numList) { /* Knuths 1. Find the largest index j such that a[j] < a[j + 1]. If no such index exists, the permutation is the last permutation. 2. Find the largest index l such that a[j] < a[l]. Since j + 1 is such an index, l is well defined and satisfies j < l. 3. Swap a[j] with a[l]. 4. Reverse the sequence from a[j + 1] up to and including the final element a[n]. */ var largestIndex = -1; for (var i = numList.Length - 2; i >= 0; i--) { if (numList[i] < numList[i + 1]) { largestIndex = i; break; } } if (largestIndex < 0) return false; var largestIndex2 = -1; for (var i = numList.Length - 1; i >= 0; i--) { if (numList[largestIndex] < numList[i]) { largestIndex2 = i; break; } } var tmp = numList[largestIndex]; numList[largestIndex] = numList[largestIndex2]; numList[largestIndex2] = tmp; for (int i = largestIndex + 1, j = numList.Length - 1; i < j; i++, j--) { tmp = numList[i]; numList[i] = numList[j]; numList[j] = tmp; } return true; } } } '"}
{"code1": "import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStream; import java.io.PrintStream; import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; import static java.lang.Integer.*; import static java.lang.Character.*; public class B { Scanner scan; public B(Scanner s) { this.scan = s; } String[]A; long brut(char last, boolean[]U,boolean[]L) { long r =0; boolean all=true; for(int i=0;i<A.length;i++){ if(U[i])continue; all=false; boolean[]nl = L.clone(); char lc = \\'#\\'; for(char c:A[i].toCharArray()){ if(nl[c]) { if(lc!=c && !(c==last && c==A[i].charAt(0)))return 0; } nl[c]=true; } U[i]=true; r += brut(A[i].charAt(A[i].length()-1),U, nl); U[i]=false; } if(all)return 1; return r%1000000007; } public String solve() { int n = scan.nextInt(); A = new String[n]; for(int i=0;i<n;i++){ A[i]= \"\";String s =scan.next(); for(int j=0;j<s.length();j++) { if(A[i].length()==0 || A[i].charAt(A[i].length()-1)!=s.charAt(j))A[i]+=s.charAt(j); } System.out.print(A[i] +\" \"); } // System.out.println(); /* long res = brut(\\'#\\', new boolean[n], new boolean[256]); return \"\"+res; */ boolean[]EQ = new boolean[n]; for(int sn=0;sn<n;sn++){ String s = A[sn]; int d=0; boolean[] v = new boolean[256]; for(int i=0;i<s.length();i++){ if(v[s.charAt(i)] && s.charAt(i-1)!=s.charAt(i))return \"0\"; if(!v[s.charAt(i)]) { d++; v[s.charAt(i)]=true; } if(i>0 && s.charAt(i)!=s.charAt(0) && i+1<s.length() && s.charAt(i) !=s.charAt(s.length()-1)){ for(int j=0;j<n;j++){ if(j==sn)continue; for(char c:A[j].toCharArray()) { if(c==s.charAt(i))return \"0\"; } } } } EQ[sn]=d==1; } for(int i=0;i<n;i++)for(int j=0;j<n;j++){ if(i==j)continue; if(EQ[i]||EQ[j])continue; if(A[i].charAt(0)==A[j].charAt(0))return \"0\"; if(A[i].charAt(A[i].length()-1)==A[j].charAt(A[j].length()-1))return \"0\"; } boolean[][]M = new boolean[n][n]; int[]inc = new int[n]; int[]out = new int[n]; int parts =0; for(int i=0;i<n;i++){ if(EQ[i])continue; parts++; for(int j=0;j<n;j++){ if(EQ[j]||i==j)continue; if(A[i].charAt(A[i].length()-1)==A[j].charAt(0)){ M[i][j]=true; inc[j]++; out[i]++; } } } for(int i=0;i<n;i++)if(inc[i]>1||out[i]>1)return \"0\"; int ch=0; boolean cover[]=new boolean[n]; ArrayList<String> seg = new ArrayList<>(); for(int i=0;i<n;i++){ if(EQ[i])continue; if(inc[i]==0 && out[i]==0){ seg.add(A[i].charAt(0)+\"\"+A[i].charAt(A[i].length()-1)); cover[i]=true; } if(inc[i]>0 || out[i]==0)continue; String s =\"\"+A[i].charAt(0); int p =i; cover[p]=true; while(out[p]>0){ for(int j=0;j<n;j++) if(M[p][j]){ p=j; cover[p]=true; } } s+=A[p].charAt(A[p].length()-1); seg.add(s); } for(int i=0;i<n;i++)if(!EQ[i]&&!cover[i])return \"0\"; long res = 1; int free =0; long mod = 1000000007; for(char c = \\'a\\';c<=\\'z\\';c++){ int count=0;boolean att = false; for(int i=0;i<n;i++){ if(EQ[i]){ if(A[i].charAt(0)==c)count++; } } if(count==0)continue; for(int i=0;i<A.length;i++){ String s = A[i]; if(EQ[i])continue; if(s.charAt(0)==c || s.charAt(s.length()-1)==c)att=true; } if(!att && count >0)free++; for(int i=1;i<=count;i++)res = (res*i)%mod; } for(int i=1;i<=seg.size()+free;i++)res = (res*i)%mod; return \"\"+res; } int intLine(){ return parseInt(scan.nextLine()); } public static void main(String[] args) throws Exception{ Locale.setDefault(Locale.US); String cn = B.class.getName(); String sampleName = cn+\"-sample.in\"; String smallName = cn+\"-small-attempt4.in\"; String largeName = cn+\"-large.in\"; String name = largeName; String outName = name.substring(0, name.indexOf(\\'.\\'))+\".out\"; InputStream in = new BufferedInputStream(new FileInputStream(name)); PrintStream out = new PrintStream(new File(outName)); //PrintStream out = System.out; Scanner scan = new Scanner(in); int N = parseInt(scan.nextLine()); for(int c=1;c<=N;c++) { String res = new B(scan).solve(); out.printf(\"Case #%d: %s\\ \",c, res); System.err.println(c + \" done\"); } System.err.println(\"All done\"); } } '", "code2": "//Orz Sevenkplus #include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<ctime> #include<cctype> #include<complex> #include<algorithm> #include<iostream> #include<vector> #include<queue> #include<set> #include<map> #include<bitset> #define un using namespace un std; #define pb push_back #define pf pop_front #define mp make_pair #define c0 first #define c1 second #define sqr(x)((x)*(x)) #define clr(x)memset(x,0,sizeof(x)) #define clr1(x)memset(x,-1,sizeof(x)) #define clr80(x)memset(x,0x80,sizeof(x)) #define clr7F(x)memset(x,0x7F,sizeof(x)) #define ll long long #ifdef __unix__ #define LLD \"%lld\" #else #define LLD \"%I64d\" #endif #define pii pair<int,int> #define pip pair<int,pii> #define vi vector<int> #define vpi vector<pii> #define pq priority_queue template<typename T>inline bool chkmin(T&a,T b){return a>b?a=b,1:0;} template<typename T>inline bool chkmax(T&a,T b){return a<b?a=b,1:0;} #define modadd(a,b,c)(((a)+(b))%(c)) #define modmul(a,b,c)((int)(((ll)(a)*(b))%(c))) #define P 1000000007 #define getint(x){\\\\ char __next__char__;bool __nega__int__=0;\\\\ while(!isdigit(__next__char__=getchar())&&__next__char__!=\\'-\\');\\\\ __next__char__==\\'-\\'?(x=0,__nega__int__=1):(x=__next__char__-48);\\\\ while(isdigit(__next__char__=getchar()))x=x*10+__next__char__-48;\\\\ if(__nega__int__)x=-x;\\\\ } #define getint2(x1,x2){getint(x1);getint(x2);} #define getint3(x1,x2,x3){getint(x1);getint(x2);getint(x3);} #define getint4(x1,x2,x3,x4){getint(x1);getint(x2);getint(x3);getint(x4);} #define getint5(x1,x2,x3,x4,x5){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);} #define getint6(x1,x2,x3,x4,x5,x6){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);getint(x6);} char strr[200][200]; int f[26],b[26],e[26],l[200],s[26]; bool v[26]; bool check(int i){ char*str=strr[i]; clr(v); for(int j=l[i]-1;j--;){ if(str[j]!=str[j+1]){ if(v[str[j+1]-\\'a\\'])return 0; v[str[j+1]-\\'a\\']=1; } } return !v[str[0]-\\'a\\']; } int F[26]; int fa(int x){ int r=F[x],y=r; while(r!=F[r])r=F[r]; while((F[x]=r)!=(x=y))y=F[y]; return r; } int run(){ int n,ans=1; getint(n); clr(f); clr(b); clr(e); clr(s); for(int i=26;i--;)F[i]=i; for(int i=-1;++i!=n;){ clr(v); scanf(\"%s\",strr[i]); l[i]=strlen(strr[i]); char*str=strr[i]; if(str[0]==str[l[i]-1]){ e[str[0]-\\'a\\']++; ans=(ll)ans*e[str[0]-\\'a\\']%P; }else{ int x=fa(str[0]-\\'a\\'); int y=fa(str[l[i]-1]-\\'a\\'); if(x==y)return 0; F[x]=y; if(f[str[0]-\\'a\\']++){ return 0; } if(b[str[l[i]-1]-\\'a\\']++){ return 0; } } for(int j=l[i];j--;)v[str[j]-\\'a\\']=1; for(int j=26;j--;)s[j]+=v[j]; } for(int i=-1;++i!=n;){ char*str=strr[i]; if(!check(i)){ return 0; } for(int j=l[i];j--;) if(str[j]!=str[l[i]-1]&&str[j]!=str[0]){ if(s[str[j]-\\'a\\']>1)return 0; } } int q=0; for(int i=26;i--;){ if((e[i]||b[i])&&F[i]==i)q++; } while(q){ ans=(ll)ans*q%P; q--; } return ans; } int main(){ int T; getint(T); for(int t=1;t<=T;t++){ printf(\"Case #%d: %d\\ \",t,run()); } return 0; } '"}
{"code1": "def withoutDuplication(s): res = [] prev = -1 for c in s: i = ord(c) - ord(\\'a\\') if i != prev: res.append(i) prev = i return res mod = 1000000007 def fact(n): if n <= 1: return 1 return n*fact(n-1)%mod def solve(strs): n = 26 inE, outE, midE, badE = [0]*n, [0]*n, [0]*n, [0]*n g = [-1]*n for s in strs: letters = withoutDuplication(s) if len(letters) == 1: midE[letters[0]] += 1 else: outE[letters[0]] += 1 inE[letters[-1]] += 1 g[letters[0]] = letters[-1] for c in letters[1:-1]: badE[c] += 1 # print inE[:4], outE[:4], midE[:4], badE[:4], g[:4] for i in xrange(n): if badE[i] > 0 and inE[i] + outE[i] + midE[i] + badE[i] > 1: return 0 if inE[i] > 1 or outE[i] > 1: return 0 seen, nc = [False]*n, 0 for i in xrange(n): if seen[i] or inE[i] != 0: continue if outE[i] + midE[i] > 0: nc += 1 t = i while t != -1: seen[t] = True t = g[t] if len(filter(None, seen)) < n: return 0 #print nc res = fact(nc) for i in xrange(26): res *= fact(midE[i]) return res%mod T = int(raw_input()) for z in xrange(T): n = int(raw_input()) s = raw_input().strip().split(\\' \\') print \"Case #%d: %s\" % (z+1, solve(s))'", "code2": "#include <cstdlib> #include <cctype> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <vector> #include <string> #include <iostream> #include <sstream> #include <map> #include <set> #include <queue> #include <functional> using namespace std; typedef long long int64; #define PB push_back #define MP make_pair #define debug(x) cout<<(#x)<<\": \"<<(x)<<endl #define REP(i,n) for(int i=0;i<(n);++i) #define FOR(i,l,h) for(int i=(l);i<=(h);++i) #define FORD(i,h,l) for(int i=(h);i>=(l);--i) #define MOD 1000000007 inline int ADD(int a, int b) { a+=b; if (a>=MOD) a-=MOD; return (int)a; } inline void ADDTO(int &a, int b) { a+=b; if (a>=MOD) a-=MOD; } inline void SUBTO(int &a, int b) { a-=b; if (a<0) a+=MOD; } inline int MUL(int a, int b) { return (int)((int64)a*b%MOD); } int loop[30], indeg[30], oudeg[30], e[30][30], vis[30]; int fact[110], ans; void addEdge(char a, char b) { int u = a - \\'a\\', v = b - \\'a\\'; ++oudeg[u]; ++indeg[v]; e[u][v] = 1; } void dfs(int u) { vis[u] = 1; ans = MUL(ans, fact[loop[u]]); if (oudeg[u] > 0) { REP(v, 26) if (e[u][v] == 1) dfs(v); } } int main() { int tN; cin >> tN; fact[0] = 1; FOR(i, 1, 100) fact[i] = MUL(i, fact[i-1]); FOR(cN, 1, tN) { memset(loop, 0, sizeof(loop)); memset(indeg, 0, sizeof(indeg)); memset(oudeg, 0, sizeof(oudeg)); memset(e, 0, sizeof(e)); memset(vis, 0, sizeof(vis)); int n; cin >> n; REP(i, n) { string s; cin >> s; bool same = 1; REP(i, s.size()) { if (s[i] != s[0]) same = 0; if (i && s[i] != s[i-1]) addEdge(s[i-1], s[i]); } if (same) ++loop[s[0] - \\'a\\']; } bool nosol = 0; REP(i, 26) if (indeg[i] > 1 || oudeg[i] > 1) nosol = 1; if (!nosol) { ans = 1; int ncc = 0; REP(i, 26) if (!vis[i] && indeg[i] == 0) { if (oudeg[i] > 0 || loop[i] > 0) ++ncc; dfs(i); } ans = MUL(ans, fact[ncc]); REP(i, 26) if (!vis[i]) nosol = 1; } printf(\"Case #%d: \", cN); if (nosol) puts(\"0\"); else printf(\"%d\\ \", ans); } } '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; namespace CodeJam { internal class TestCase { public string[] Cars; } internal class Pair { public char First { get; set; } public char Last { get; set; } } internal class Program { private const string testFileName = \"B-large\"; private const int Base = 1000000007; public static IEnumerable<TestCase> ParseCases(TextReader reader) { var testCaseCount = int.Parse(reader.ReadLine()); for (var i = 0; i < testCaseCount; i++) { var carCount = int.Parse(reader.ReadLine()); var cars = reader.ReadLine().Split(); yield return new TestCase { Cars = cars }; } } private static long Solve(TestCase testCase) { // 3 types of cars // single letters: aaa // two letters: aabb // multiple letters aabcddd // simplify consecutive letters var withoutRuns = testCase.Cars.Select(RemoveConsecutive).ToArray(); var singleLetters = withoutRuns.Where(c => c.Length == 1).Select(c => c[0]).ToArray(); var hiddenLetters = withoutRuns.Where(c => c.Length > 2).SelectMany(c => c.Substring(1, c.Length - 2)).Distinct().ToArray(); var pairs = withoutRuns.Where(c => c.Length > 1).Select(c => new Pair { First = c[0], Last = c[c.Length - 1] }).ToArray(); // eliminate case 3 now if (pairs.Any(p => hiddenLetters.Contains(p.First) || hiddenLetters.Contains(p.Last)) || singleLetters.Any(hiddenLetters.Contains)) return 0; // we know just have to find orderings for pairs and single letters. // check that all the pairs can be ordered successfully if (pairs.Select(p => p.First).Distinct().Count() != pairs.Count() || pairs.Select(p => p.Last).Distinct().Count() != pairs.Count()) return 0; //check the groups that have an order imposed on them by the pairs var sortedPairs = GetFixedChains(pairs); if (sortedPairs == null) return 0; var singleLetterCounts = singleLetters.GroupBy(c => c, (key, values) => Tuple.Create(key, values.Count())); var lettersInChains = sortedPairs.SelectMany(p => p).SelectMany(p => new[] { p.First, p.Last }).Distinct(); var independentSingleLetters = singleLetters.Except(lettersInChains).ToArray(); // single letters can be in any order relative to each other long combinations = 1; foreach (var pair in singleLetterCounts) { combinations *= Factorial(pair.Item2); combinations %= Base; } // chains can be in any order relative to each other, and to the independent letters var independentBlockCount = independentSingleLetters.Count() + sortedPairs.Length; combinations *= Factorial(independentBlockCount); combinations %= Base; return combinations; } private static long Factorial(int x) { long fact = 1; while (x > 1) { fact *= x; fact %= Base; x--; } return fact; } private static Pair[][] GetFixedChains(Pair[] pairs) { var remainingPairs = pairs.ToList(); var sorted = new List<Pair[]>(); while (remainingPairs.Count > 0) { var chain = new List<Pair>(); var current = remainingPairs[0]; remainingPairs.RemoveAt(0); chain.Add(current); int index; var first = current; while ((index = remainingPairs.FindIndex(p => p.Last == first.First)) >= 0) { first = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Insert(0, first); } var last = current; while ((index = remainingPairs.FindIndex(p => p.First == last.Last)) >= 0) { last = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Add(last); } if (last.Last == first.First) return null; sorted.Add(chain.ToArray()); } return sorted.ToArray(); } private static string RemoveConsecutive(string arg) { var builder = new StringBuilder(arg.Length); char current = \\'\\\\0\\'; foreach (var c in arg) { if (c != current) { builder.Append(c); current = c; } } return builder.ToString(); } private static void Main(string[] args) { TestCase[] cases; using (var reader = new StreamReader(testFileName + \".in\")) using (var writer = new StreamWriter(testFileName + \".out\")) { cases = ParseCases(reader).ToArray(); for (int caseIndex = 0; caseIndex < cases.Length; caseIndex++) { var testCase = cases[caseIndex]; var solution = Solve(testCase); writer.WriteLine(\"Case #{0}: {1}\", caseIndex + 1, solution); } } } } }'", "code2": "#include <stdio.h> #include <stdlib.h> #include <string.h> #define M 1000000007LL //char *train[10]; int N; int count; int embedded[26]; int oneletter[26]; int endswith[26]; int startswith[26]; int impossible=0; int used; int segment; char *destutter(char *s) { static char buf2[200]; char *d=buf2; char last=0; while (*s) { if (*s!=last) last=*d++ = *s; s++; } *d=0; return buf2; } void readtrains(void) { int i,len,j; static char buff[200]; char *b; impossible=0; scanf(\"%d\",&N); for (i=0;i<26;i++) { embedded[i]=0; oneletter[i]=0; endswith[i]=-1; startswith[i]=-1; } for (i=0;i<N;i++) { scanf(\"%s\",buff); b=destutter(buff); len=strlen(b); if (len==1) { oneletter[*b-\\'a\\']++; continue; } if (startswith[*b-\\'a\\']>=0) impossible++; if (endswith[b[len-1]-\\'a\\']>=0) impossible++; startswith[*b-\\'a\\']=b[len-1]-\\'a\\'; endswith[b[len-1]-\\'a\\']=*b-\\'a\\'; for (j=1;j<len-1;j++) embedded[b[j]-\\'a\\']++; } } int modtimes(int a, int b) { return (int)((1LL*a*b) % M); } int factorial(int n) { int f=1; int i; if (n<=1) return 1; for (i=2;i<=n;i++) f=modtimes(f,i); return f; } void countonlyi(int i) { segment++; //printf(\"countonly %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); } void countendi(int i) { segment++; //printf(\"countend %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! while (1) { if ((1<<i) & used) {impossible++;return;} used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); i=endswith[i]; if (i<0) break; } } void countstarti(int i) { int used2=1<<i; //printf(\" Cs %c\\ \",i+\\'a\\'); while (startswith[i]>=0) { i=startswith[i]; //printf(\" cs %c\\ \",i+\\'a\\'); if (used2 & (1<<i)) { //printf(\"imp\\ \"); impossible++;return; } used2|=1<<i; } countendi(i); } void counttrains(void) { int i; count=1; used=0; segment=0; for (i=0;i<26;i++) { if (impossible || embedded[i]>1 || embedded[i] && (startswith[i]>=0 || endswith[i]>=0)) { printf(\"0\\ \"); //impossible return; } } i=0; while (i<26 && !impossible) { if (startswith[i]>=0 && !((1<<i) & used)) countstarti(i); if (endswith[i]>=0 && !((1<<i) & used)) countendi(i); if (oneletter[i]>0 && !((1<<i) & used)) countonlyi(i); i++; } if (impossible) printf(\"0\\ \"); else printf(\"%d\\ \",count); } void dump(void) { int i; printf(\"\\ \"); for (i=0;i<26;i++) { if (startswith[i]<0 && endswith[i]<0 && embedded[i]==0 && oneletter[i]==0) continue; printf(\" %c : ->%c %c<- em=%d 1L=%d\\ \",i+\\'a\\',startswith[i]+\\'a\\',endswith[i]+\\'a\\',embedded[i],oneletter[i]); } } int main(int argc, char **argv) { int tc,i; scanf(\"%d\",&tc); for (i=1;i<=tc;i++) { printf(\"Case #%d: \",i); readtrains(); //dump(); counttrains(); } return 0; } '"}
{"code1": "// uses http://introcs.cs.princeton.edu/java/stdlib/StdIn.java public class Train { static final int MOD = 1_000_000_007; public static long calc(String[] cars) { long result = 1; int n = cars.length; for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) { //System.out.println(java.util.Arrays.toString(cars)); int solocount = 0; int start = -1; int mid = -1; int end = -1; int solo = -1; for (int i=0; i<n; i++) { if (cars[i] == null) { } else if (cars[i].matches(\"\"+ch+\\'+\\')) { solocount++; result *= solocount; result %= MOD; cars[i] = null; solo = i; } else if (cars[i].matches(ch+\"+[^\"+ch+\"]+\")) { if (start != -1) return 0; start = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+\")) { if (end != -1) return 0; end = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+[^\"+ch+\"]+\")) { if (mid != -1) return 0; mid = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\")) { } else return 0; } //System.out.println(ch+\" \"+solocount+\" \"+start+\" \"+solo+\" \"+end+\" \"+result); if (mid == -1 && solocount == 0 && start == -1 && end == -1) continue; if (mid != -1 && (solocount > 0 || start != -1 || end != -1)) return 0; if (mid != -1) continue; String repl = \"\"; if (end != -1) {repl += cars[end]; cars[end] = null;} if (solo != -1) repl += ch; if (start != -1) {repl += cars[start]; cars[start] = null;} if (start != -1) {cars[start] = repl;} else if (solo != -1) {cars[solo] = repl;} else cars[end] = repl; } int left = 0; for (String s : cars) if (s != null) { left ++; result *= left; result %= MOD; } return result; } public static void main(String[] args) { int q = StdIn.readInt(); for (int j=1; j<=q; j++) { int n = StdIn.readInt(); String[] cars = new String[n]; { for (int i=0; i<n; i++) cars[i] = StdIn.readString(); } System.out.printf(\"Case #%d: %d\\ \", j, calc(cars)); } } } '", "code2": "import static java.lang.Math.*; import java.io.*; import java.math.*; import java.util.*; public class ProblemBLarge { static class Car { String s; LinkedHashMap<Character, Long> numAddedSameCharCars = new LinkedHashMap<Character, Long>(); char getFirst() { return s.charAt(0); } char getLast() { return s.charAt(s.length() - 1); } void addAllSameChars(Car car) { for (Map.Entry<Character, Long> entry : car.numAddedSameCharCars.entrySet()) { Character key = entry.getKey(); Long value = numAddedSameCharCars.get(key); if (value == null) value = 0L; value += entry.getValue(); numAddedSameCharCars.put(key, value); } } @Override public String toString() { return \"\"+s+\" (\"+numAddedSameCharCars+\")\"; } } public class Case { LinkedHashSet<Car> cars = new LinkedHashSet<Car>(); LinkedHashSet<Car> carsToCheck = new LinkedHashSet<Car>(); public void solve(int caseIndex) { for (Car car : cars) { if (isSameCharCar(car)) { car.numAddedSameCharCars.put(car.s.charAt(0), 1L); } } // System.out.println(\"Cars: \"+cars); carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); // LinkedHashSet<Car> carsWithSameChar = new LinkedHashSet<Car>(); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); if (isSameCharCar(car)) { for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } } carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } BigInteger result; if (!isValid()) { result = BigInteger.valueOf(0); } else { long mod = 1000000007L; result = BigInteger.valueOf(1); for (long i = 1; i <= cars.size(); i++) { result = result.multiply(BigInteger.valueOf(i)); } for (Car car : cars) { for (Long sameChars : car.numAddedSameCharCars.values()) { long a = 1; for (long i = 1; i <= sameChars; i++) { a *= i; a %= mod; } result = result.multiply(BigInteger.valueOf(a)); } } result = result.mod(BigInteger.valueOf(mod)); } // long result; // if (!isValid()) { // result = 0; // } // else { // long mod = 1000000007L; // // result = 1; // for (long i = 1; i <= cars.size(); i++) { // result *= i; // result %= mod; // } // // for (Car car : cars) { // for (Long sameChars : car.numAddedSameCharCars.values()) { // long a = 1; // for (long i = 1; i <= sameChars; i++) { // a *= i; // a %= mod; // } // result *= a; // result %= mod; // } // } // } println(\"Case #\" + (caseIndex + 1) + \": \" + result); } void combineCars(Car car1, Car car2) { Car car = new Car(); car.s = car1.s + car2.s; car.addAllSameChars(car1); car.addAllSameChars(car2); // car.numAddedSameCharCars = car1.numAddedSameCharCars + car2.numAddedSameCharCars; cars.add(car); carsToCheck.add(car); cars.remove(car1); carsToCheck.remove(car1); cars.remove(car2); carsToCheck.remove(car2); // System.out.println(\"Cars: \"+cars); } boolean isSameCharCar(Car car) { String s = car.s; for (int k = 0; k < s.length(); k++) { if (s.charAt(k) != s.charAt(0)) { return false; } } return true; } boolean isValid() { LinkedHashSet<Character> processed = new LinkedHashSet<>(); Character last = null; for (Car car : cars) { String s = car.s; for (int k = 0; k < s.length(); k++) { char ch = s.charAt(k); // System.out.println(\"Current: \"+ch); if (last != null && last.charValue() == ch) { // System.out.println(\"Last: \"+last+\", processed: \"+processed); } else { if (processed.contains(ch)) return false; processed.add(ch); } last = ch; } } return true; } long factorial(long p) { long result = 1; for (long i = 2; i <= p; i++) result *= i; return result; } } public void run() throws Exception { BufferedReader r = new BufferedReader(new FileReader(\"input.txt\")); int numCases = new InputParser(r.readLine()).readInt(); for (int caseIndex = 0; caseIndex < numCases; caseIndex++) { Case c = new Case(); InputParser p = new InputParser(r.readLine()); int numCars = p.readInt(); p = new InputParser(r.readLine()); for (int i = 0; i < numCars; i++) { Car car = new Car(); car.s = p.readToken(); c.cars.add(car); } c.solve(caseIndex); } r.close(); } public static void main(String[] args) throws Exception { fileWriter = new PrintWriter(new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"output.txt\")))); new ProblemBLarge().run(); fileWriter.close(); } public static class InputParser { String text; int pos; public InputParser(String text) { this.text = text; } public void skipSpaces() { while (pos < text.length()) { if (text.charAt(pos) != \\' \\') break; pos++; } } public String readUntil(char expectedChar) { StringBuilder b = new StringBuilder(); while (pos < text.length()) { char ch = text.charAt(pos); if (ch == expectedChar) break; b.append(ch); pos++; } return b.toString(); } public String readToken() { skipSpaces(); return readUntil(\\' \\'); } public int readInt() { return Integer.parseInt(readToken()); } public long readLong() { return Long.parseLong(readToken()); } public double readDouble() { return Double.parseDouble(readToken()); } public char readChar() { char ch = text.charAt(pos); pos++; return ch; } public void readExpectedString(String s) { for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (readChar() != ch) throw new RuntimeException(\"Expected: \"+ch); } } } public static PrintWriter fileWriter; public static void print(String text) { fileWriter.print(text); System.out.print(text); } public static void println(String text) { fileWriter.println(text); System.out.println(text); } public static <Key, Value> void addToMultiMapArrayList(Key key, Value value, Map<Key, ArrayList<Value>> map) { ArrayList<Value> list = map.get(key); if (list == null) { list = new ArrayList<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> void addToMultiMapLinkedHashSet(Key key, Value value, Map<Key, LinkedHashSet<Value>> map) { LinkedHashSet<Value> list = map.get(key); if (list == null) { list = new LinkedHashSet<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> ArrayList<Value> getMultiMapValues(Map<Key, Collection<Value>> map) { ArrayList<Value> result = new ArrayList<Value>(); for (Collection<Value> list : map.values()) { result.addAll(list); } return result; } // binarySearch(, , 0.000000001, new Function<Double, Integer>() { // public Integer evaluate(Double key) { // return ; // } // }); public static double binarySearch(double low, double high, double precision, Function<Double, Integer> f) { if (high < low) throw new RuntimeException(\"High (\"+high+\") cannot be smaller than low (\"+low+\")\"); { int lowValue = f.evaluate(low); if (lowValue == 0) return low; if (lowValue > 0) throw new RuntimeException(\"Unsuitable low: \"+low); } { int highValue = f.evaluate(high); if (highValue == 0) return high; if (highValue < 0) throw new RuntimeException(\"Unsuitable high: \"+high); } while (true) { double mid = (low + high) * 0.5; if (abs(high - low) < precision) { return mid; } int c = f.evaluate(mid); if (c < 0) low = mid; else if (c > 0) high = mid; else return mid; } } public static <T> LinkedHashSet<T> intersection(Set<T> s1, Set<T> s2) { if (s2.size() < s1.size()) { Set<T> temp = s1; s1 = s2; s2 = temp; } LinkedHashSet<T> result = new LinkedHashSet<T>(); for (T o : s1) { if (s2.contains(o)) result.add(o); } return result; } public static interface Function<Key, Value> { public Value evaluate(Key key); } public static class Int2 { int x, y; public Int2(int x, int y) { this.x = x; this.y = y; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Int2 other = (Int2) obj; if (x != other.x) return false; if (y != other.y) return false; return true; } @Override public String toString() { return \"(\"+x+\",\"+y+\")\"; } } } '"}
{"code1": "#include <iostream> #include <fstream> #include <string> #include <algorithm> #include <cstdlib> #include <cstring> #include <set> #include <map> #include <vector> #include <stack> #include <queue> #include <deque> #include <iomanip> #include <cassert> typedef long long ll; typedef unsigned long long ull; using namespace std; bool is_aaa(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] != c) return false; } return true; } bool is_aax(const string& s, char c) { return s[0] == c; } bool is_yaa(const string& s, char c) { return s[(int)s.size() - 1] == c; } bool is_uav(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] == c) return true; } return false; } int fragment_count(const string& s, char c) { int result = 0; int n = (int)s.size(); int i = 0; while (i < n) { if (s[i] != c) i++; else { int j = i; while (j + 1 < n && s[j + 1] == c) j++; result++; i = j + 1; } } return result; } const int MAXN = 109; int N; string s[MAXN]; vector<string> pieces; const ll MOD = 1000000007; ll fact[MAXN]; ll solve(void) { pieces.clear(); for (int i = 0; i < N; i++) pieces.push_back(s[i]); ll result = 1; for (char c = \\'a\\'; c <= \\'z\\'; c++) { vector<string> aaa; vector<string> aax; vector<string> yaa; vector<string> uav; vector<string> other; for (int i = 0; i < pieces.size(); i++) { if (is_aaa(pieces[i], c)) aaa.push_back(pieces[i]); else if (is_aax(pieces[i], c)) aax.push_back(pieces[i]); else if (is_yaa(pieces[i], c)) yaa.push_back(pieces[i]); else if (is_uav(pieces[i], c)) uav.push_back(pieces[i]); else other.push_back(pieces[i]); } if (uav.size() != 0) { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0 && uav.size()==1 && fragment_count(uav[0], c)==1) { ; } else return 0LL; } else { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0) { ; // no constraints at all } else { if (yaa.size() <= 1 && aax.size() <= 1) { if (yaa.size() == 1) { if (fragment_count(yaa[0], c) > 1) return 0LL; } if (aax.size() == 1) { if (fragment_count(aax[0], c) > 1) return 0LL; } result *= fact[aaa.size()]; result %= MOD; pieces = other; string new_piece; if (yaa.size() != 0) new_piece += yaa[0]; for (int i = 0; i < aaa.size(); i++) new_piece += aaa[i]; if (aax.size() != 0) new_piece += aax[0]; pieces.push_back(new_piece); } else return 0LL; } } } result *= fact[pieces.size()]; result %= MOD; return result; } void solve_B(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; fact[0] = 1LL; for (int i = 1; i < MAXN; i++) fact[i] = (fact[i - 1] * i) % MOD; for (int tt = 1; tt <= T; tt++) { for (int i = 0; i < MAXN; i++) s[i] = \"\"; in >> N; for (int i = 0; i < N; i++) in >> s[i]; ll temp = solve(); out << \"Case #\" << tt << \": \"; out << temp; out << \\'\\ \\'; } in.close(); out.close(); } int main() { //solve_A(); solve_B(); //solve_C(); return 0; } void solve_(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; for (int tt = 1; tt <= T; tt++) { out << \"Case #\" << tt << \": \"; } in.close(); out.close(); }'", "code2": "import java.util.HashSet; import java.util.Scanner; import java.util.Set; public class B { static final long BASE = 1000000007; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int cases = sc.nextInt(); long[] factorial = new long[101]; factorial[0] = 1; for (int i = 1; i < 101; i++) { factorial[i] = (factorial[i - 1] * i) % BASE; } for (int caseNum = 1; caseNum <= cases; caseNum++) { int N = sc.nextInt(); String[] cars = new String[N]; Set<Character> interior = new HashSet<Character>(); int[] singleLetterStrs = new int[26]; int[] starts = new int[26]; int[] ends = new int[26]; char[] next = new char[26]; boolean possible = true; for (int i = 0; i < N; i++) { cars[i] = sc.next(); int firstChar = cars[i].charAt(0) - \\'a\\'; char lastChar = cars[i].charAt(cars[i].length() - 1); if (isSingleLetter(cars[i])) { int index = firstChar; singleLetterStrs[index]++; } else { for (Character ch : getInteriorChars(cars[i])) { if (interior.contains(ch)) { possible = false; break; } interior.add(ch); } starts[firstChar]++; ends[lastChar - \\'a\\']++; next[firstChar] = lastChar; } } int numGroups = 0; for (int i = 0; i < 26; i++) { if (!possible) { break; } char ch = (char) (\\'a\\' + i); if (interior.contains(ch) && (singleLetterStrs[i] + starts[i] + ends[i] > 0)) { possible = false; } if (starts[i] > 1 || ends[i] > 1) { possible = false; } if (singleLetterStrs[i] > 0 && starts[i] == 0 && ends[i] == 0) { numGroups++; } else if (starts[i] == 1 && ends[i] == 0) { numGroups++; } } possible = possible && !hasCycles(next); System.out.print(\"Case #\" + caseNum + \": \"); if (!possible) { System.out.println(0); continue; } long ways = 1; for (int i = 0; i < 26; i++) { ways = (ways * factorial[singleLetterStrs[i]]) % BASE; } ways = (ways * factorial[numGroups]) % BASE; System.out.println(ways); } } private static boolean hasCycles(char[] next) { for (int i = 0; i < 26; i++) { if (next[i] == 0) { continue; } char start = (char) (\\'a\\' + i); int currIndex = i; while (next[currIndex] != 0 && next[currIndex] != start) { currIndex = next[currIndex] - \\'a\\'; } if (next[currIndex] == start) { return true; } } return false; } private static Set<Character> getInteriorChars(String str) { Set<Character> chars = new HashSet<Character>(); if (isSingleLetter(str)) { return chars; } int startIndex = 0; while (str.charAt(startIndex + 1) == str.charAt(0)) { startIndex++; } int endIndex = str.length() - 1; while (str.charAt(endIndex - 1) == str.charAt(str.length() - 1)) { endIndex--; } for (int i = startIndex + 1; i < endIndex; i++) { chars.add(str.charAt(i)); } return chars; } private static boolean isSingleLetter(String str) { char ch = str.charAt(0); for (int i = 1; i < str.length(); i++) { if (str.charAt(i) != ch) { return false; } } return true; } } '"}
{"code1": "#include <stdio.h> #include <stdlib.h> #include <math.h> #include <ctype.h> #include <string.h> int TC, T; int Cars; char Car[120][120]; char Visited[130]; int Stack[120]; int Used[120]; int i, x, y, L, Ans; char Last; int DFS(int Level){ if (Level==Cars){ int i, x; Last = Car[Stack[0]][0]; memset(Visited, 0, sizeof(Visited)); Visited[Last] = 1; for (i=0; i<Cars; i++){ L = strlen(Car[Stack[i]]); for (x=0; x<L; x++){ if (Car[Stack[i]][x]==Last) continue; if (Visited[Car[Stack[i]][x]]) return ; Visited[Car[Stack[i]][x]] = 1; Last = Car[Stack[i]][x]; } } Ans++; return ; } int i; for (i=0; i<Cars; i++) if (!Used[i]){ Used[i] = 1; Stack[Level] = i; DFS(Level+1); Used[i] = 0; } } int main(){ freopen(\"B-small-attempt0.in\", \"r\", stdin); freopen(\"B-small-attempt0.out\", \"w\", stdout); scanf(\"%d\", &TC); for (T=1; T<=TC; T++){ printf(\"Case #%d: \", T); scanf(\"%d\", &Cars); for (i=0; i<Cars; i++) scanf(\"%s\", Car[i]); Ans = 0; DFS(0); printf(\"%d\\ \", Ans); } return 0; } '", "code2": "#!/usr/bin/pypy import itertools,math,sys def simple_solve(N,S): S = sorted(S) cnt = 0 for perm in itertools.permutations(S): z = \"\".join(perm) chars = [False for _ in range(26)] last = \\'\\' for c in z: if last==c: continue last = c if chars[ord(c)-ord(\\'a\\')]: break chars[ord(c)-ord(\\'a\\')] = True else: cnt += 1 return cnt def true_solve(N,S): rz = {} for c in range(26): char = chr(c+ord(\\'a\\')) cnt_inside = cnt_left = cnt_right = cnt_full = 0 left_char = right_char = \"\" for z in S: h = False last = \"\" for x in z: if x==char and h and last != char: return 0 if x==char: h = True last = x if z[0] == z[-1] == char: cnt_full += 1 elif z[0] == char: cnt_left += 1 right_char = z[-1] elif z[-1] == char: cnt_right += 1 left_char = z[0] elif h: cnt_inside += 1 if cnt_inside > 1 or cnt_inside > 0 and cnt_left+cnt_right+cnt_full>0 or cnt_left>1 or cnt_right>1: return 0 if cnt_inside == 0 and cnt_left+cnt_right+cnt_full>0: rz[char] = ((left_char,right_char,math.factorial(cnt_full))) blocks = 0 bb = 1 while rz: for c,v in rz.items(): if v[0]==\"\": break else: return 0 del rz[c] bb *= v[2] while v[1] != \"\": if v[1] not in rz: return 0 v = rz.pop(v[1]) bb *= v[2] blocks += 1 return math.factorial(blocks)*bb%1000000007 def solve(): N = int(raw_input()) S = raw_input().strip().split() val1 = true_solve(N,S) #val2 = simple_solve(N,S) #if val1 != val2: # print \"Bad\" # print N,S # print val1,val2 # sys.exit(1) return val1 T = int(raw_input()) for t in range(1,T+1): print \"Case #%d:\"%t,solve() '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Linq; using System.Numerics; using System.Text; using System.Threading.Tasks; namespace GCJ2014R1CB { class Program { /// <summary> /// \\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe6\\x95\\xb0 /// </summary> static int ThreadCount = 1; /// <summary> /// \\xe9\\x80\\xb2\\xe6\\x8d\\x97\\xe3\\x82\\x92\\xe8\\xa1\\xa8\\xe7\\xa4\\xba\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 /// </summary> static bool Verbose = true; static int ProgressInterval = 1; class Solver { public List<string> SolveAll(int threadId, StreamReader sr) { // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ int TestCase = int.Parse(sr.ReadLine()); // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ List<string> outputs = new List<string>(); for (int testCase = 0; testCase < TestCase; testCase++) { // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ int N = int.Parse(sr.ReadLine()); string l = sr.ReadLine(); // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ #region if (testCase % ThreadCount != threadId) { // \\xe3\\x81\\x93\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xae\\xe6\\x8b\\x85\\xe5\\xbd\\x93\\xe3\\x81\\xa7\\xe3\\x81\\xaf\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe3\\x81\\xae\\xe3\\x81\\xa7\\xe8\\xa7\\xa3\\xe3\\x81\\x8b\\xe3\\x81\\xaa\\xe3\\x81\\x84 continue; } if (Verbose) { if (testCase % ProgressInterval == 0) { Console.Error.WriteLine(testCase + \" / \" + TestCase); } } #endregion // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ string output = Solve(testCase, l); // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ outputs.Add(output); } return outputs; } const long Mod = 1000000007; string Solve(int testCase, string l) { if (testCase == -1) { } List<string> ts = l.Split(\\' \\').ToList(); BigInteger ans = 1; for(char c = \\'a\\'; c <= \\'z\\'; c++) { int ct = 0; string ns = \"\"; for(int i = 0; i < ts.Count; i++) { if (ts[i].First() == c && ts[i].Last() == c) { ns += ts[i]; ct++; ans *= ct; ts.RemoveAt(i); i--; } } if (ct > 0) { ts.Add(ns); } } for(;;) { bool f = Update(ts, true); if (f == false) { break; } } for(;;) { bool f = Update(ts, false); if (f == false) { break; } } string all = string.Concat(ts); for(char c = \\'a\\'; c <= \\'z\\'; c++) { int first = all.IndexOf(c); if (first < 0) { continue; } int last = all.LastIndexOf(c); for(int i = first; i < last; i++) { if (all[i] != c) { return \"0\"; } } } for(int i = 1; i <= ts.Count; i++) { ans *= i; } ans %= Mod; return ans.ToString(); } static bool Update(List<string> ts, bool primary) { int N = ts.Count(); for(int i = 0; i < N; i++) { if (primary && ts[i].First() != ts[i].Last()) { continue; } for(int j = 0; j < N; j++) { if (i == j) { continue; } if (ts[i].Last() == ts[j].First()) { ts[i] += ts[j]; ts.RemoveAt(j); return true; } } } return false; } } static void Main(string[] args) { // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\x84\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\x9f\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\xab\\xe5\\xaf\\xbe\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe5\\x87\\xa6\\xe7\\x90\\x86\\xe3\\x82\\x92\\xe8\\xa1\\x8c\\xe3\\x81\\x86\\xe3\\x80\\x82 // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe3\\x82\\xab\\xe3\\x83\\xac\\xe3\\x83\\xb3\\xe3\\x83\\x88\\xe3\\x83\\x87\\xe3\\x82\\xa3\\xe3\\x83\\xac\\xe3\\x82\\xaf\\xe3\\x83\\x88\\xe3\\x83\\xaa\\xe3\\x81\\xae large \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81 // small \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81sample.in \\xe3\\x82\\x92\\xe9\\xa0\\x86\\xe3\\x81\\xab\\xe6\\xa4\\x9c\\xe7\\xb4\\xa2\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 // large \\xe3\\x82\\x84 small \\xe3\\x81\\x8c\\xe8\\xa4\\x87\\xe6\\x95\\xb0\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe5\\x90\\x8d\\xe5\\x89\\x8d\\xe3\\x81\\xa7\\xe3\\x82\\xbd\\xe3\\x83\\xbc\\xe3\\x83\\x88\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe4\\xb8\\x80\\xe7\\x95\\xaa\\xe6\\x9c\\x80\\xe5\\xbe\\x8c\\xe3\\x81\\xae\\xe3\\x82\\x92\\xe4\\xbd\\xbf\\xe3\\x81\\x86\\xe3\\x80\\x82 string inputName = null; if (args.Length > 0) { if (File.Exists(args[0]) == false) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } inputName = args[0]; } if (inputName == null) { List<string> larges = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"large\") && fi.Name.EndsWith(\".in\")) { larges.Add(fi.FullName); } } if (larges.Count > 0) { larges.Sort(); inputName = larges[larges.Count - 1]; } } if (inputName == null) { List<string> smalls = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"small\") && fi.Name.EndsWith(\".in\")) { smalls.Add(fi.FullName); } } if (smalls.Count > 0) { smalls.Sort(); inputName = smalls[smalls.Count - 1]; } } if (inputName == null) { foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.ToLower() == \"sample.in\") { inputName = fi.FullName; break; } } } if (inputName == null) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } // \\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe5\\x85\\x88\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x82\\x92\\xe6\\xb1\\xba\\xe5\\xae\\x9a\\xe3\\x81\\x97\\xe3\\x80\\x81\\xe5\\x90\\x8c\\xe5\\x90\\x8d\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x83\\xaa\\xe3\\x83\\x8d\\xe3\\x83\\xbc\\xe3\\x83\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 string outputName = inputName; if (outputName.EndsWith(\".in\")) { outputName = outputName.Substring(0, outputName.Length - 3); } outputName += \".out\"; if (File.Exists(outputName)) { int rev = 1; while (File.Exists(outputName + \".\" + rev)) { rev++; } File.Move(outputName, outputName + \".\" + rev); } // \\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82ThreadCount == 1 \\xe3\\x81\\xaa\\xe3\\x82\\x89\\xe3\\x80\\x81\\xe7\\x8f\\xbe\\xe5\\x9c\\xa8\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xa7\\xe3\\x80\\x81\\xe3\\x81\\x9d\\xe3\\x82\\x8c\\xe4\\xbb\\xa5\\xe5\\xa4\\x96\\xe3\\x81\\xaa\\xe3\\x82\\x89 Parallel \\xe3\\x81\\xa7\\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 List<string>[] outputs = new List<string>[ThreadCount]; if (ThreadCount == 1) { for (int i = 0; i < ThreadCount; i++) { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } } } else { Parallel.For(0, ThreadCount, i => { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } }); } // \\xe7\\xb5\\x90\\xe6\\x9e\\x9c\\xe3\\x82\\x92\\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82Case # \\xe3\\x81\\xaf\\xe3\\x81\\x93\\xe3\\x81\\x93\\xe3\\x81\\xa7\\xe4\\xbb\\x98\\xe5\\x8a\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 using (StreamWriter sw = new StreamWriter(outputName)) { for (int i = 0; ; i++) { if (outputs[i % ThreadCount].Count > i / ThreadCount) { sw.WriteLine(\"Case #\" + (i + 1) + \": \" + outputs[i % ThreadCount][i / ThreadCount]); } else { break; } } } } } } '", "code2": "#include<stdio.h> #include<stdlib.h> #include<string.h> #define MOD 1000000007LL int t,T,n,N; long long frac[128]; long long C; char s[128][128]; long long ans; char start[128];/*First Letter*/ char end[128];/*Last Letter*/ char blocked[256]; /*Internal characters*/ int first; int tmp; int c; int only_start[256]; int only_end[256]; int loops[256]; int done[256]; int num_frag; char tmp2; char tmp3; int main(){ scanf(\"%d\",&T); frac[0]=1; for(C=1;C<120;C++) frac[C]=(frac[C-1]*C)%MOD; for(t=1;t<=T;t++){ scanf(\"%d\",&N); for(n=1;n<=N;n++){scanf(\"%s\",&s[n][0]);} for(c=0;c<256;c++) { blocked[c]=0; only_start[c]=0; only_end[c]=0; loops[c]=0; } ans=1; for(n=1;n<=N;n++) { tmp=strlen(s[n]); first=1; start[n]=s[n][0]; end[n]=s[n][tmp-1]; for(c=1;c<tmp;c++) { if (s[n][c]!=s[n][c-1]) { if (blocked[s[n][c]]==1) ans=0; if (first==0) { blocked[s[n][c-1]]=1; } first=0; } } if ((start[n]==end[n])&&(first==0)) ans=0; } if (ans==1) { for(n=1;n<=N;n++) { if (blocked[start[n]]==1) ans=0; if (blocked[end[n]]==1) ans=0; } } if (ans==1) { for(n=1;n<=N;n++) { if (start[n]==end[n]) {loops[start[n]]++;} else { only_start[start[n]]++; only_end[end[n]]++; } } for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if (only_start[tmp2]>1) ans=0; if (only_end[tmp2]>1) ans=0; } } if (ans==1) { num_frag=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) num_frag++; if ((only_start[tmp2]==0)&&(only_end[tmp2]==0)&&(loops[tmp2]>0)) num_frag++; ans*=frac[loops[tmp2]]; ans%=MOD; } ans*=frac[num_frag]; ans%=MOD; } /*Detect cycles*/ if (ans!=0) { for(c=0;c<256;c++) done[c]=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) { tmp3=tmp2; do{ for(n=1;n<=N;n++) { if ((start[n]==tmp3)&&(start[n]!=end[n])) break; } done[n]=1; tmp3=end[n]; } while (only_start[tmp3]==1); } } for(n=1;n<=N;n++) { if ((done[n]==0)&&(start[n]!=end[n])) ans=0; } } printf(\"Case #%d: \",t); printf(\"%lld\\ \",ans); } return 0; } '"}
{"code1": "//#pragma comment(linker, \"/STACK:134217728\") #include <iostream> #include <sstream> #include <cstdio> #include <cstdlib> #include <cmath> #include <cctype> #include <cstring> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> #include <numeric> using namespace std; typedef long long Int; typedef pair<int,int> PII; typedef vector<int> VInt; #define FOR(i, a, b) for(i = (a); i < (b); ++i) #define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i) #define CLEAR(a, b) memset(a, b, sizeof(a)) #define SIZE(a) int((a).size()) #define ALL(a) (a).begin(),(a).end() #define PB push_back #define MP make_pair #define MOD 1000000007 string S[256]; int A[256]; int C[256]; int Next[256]; int Prev[256]; int B[256]; Int dfs(int a) { if (a == -1) return 1; B[a] = 1; Int res = 1; int i; FOR(i, 0, C[a]) res = res * (i + 1) % MOD; return res * dfs(Next[a]) % MOD; } Int f(int n) { CLEAR(A, 0); CLEAR(C, 0); CLEAR(Next, -1); CLEAR(Prev, -1); int i, j; FOR(i, 0, n) { char first = S[i].front(); char last = S[i].back(); FOR(j, 1, SIZE(S[i]) - 1) { char mid = S[i][j]; if (A[mid] == 0) ++A[mid]; else return 0; } if (first == last) { if (SIZE(S[i]) == 1) ++C[first]; else return 0; } else { if (Next[first] != -1) return 0; if (Prev[last] != -1) return 0; Next[first] = last; Prev[last] = first; } } FOR(i, 0, 256) if (A[i] != 0 && (C[i] != 0 || Next[i] != -1 || Prev[i] != -1)) return 0; Int res = 1; int cnt = 0; CLEAR(B, 0); FOR(i, 0, 256) if (B[i] == 0 && Prev[i] == -1) { if (C[i] != 0 || Next[i] != -1) ++cnt; res *= dfs(i); res %= MOD; } FOR(i, 0, cnt) res = res * (i + 1) % MOD; FOR(i, 0, 256) if (B[i] == 0) return 0; return res; } int SolveTest(int test) { int n; scanf(\"%d\", &n); int i, j; FOR(i, 0, n) { char buf[128]; scanf(\"%s\", buf); int len = strlen(buf); string s; int prev = 0; FOR(j, 1, len + 1) if (j == len || buf[j] != buf[prev]) { s.push_back(buf[prev]); prev = j; } S[i] = s; } printf(\"Case #%d: %d\\ \", test + 1, int(f(n))); return 0; } int main() { freopen(\"b.in\", \"r\", stdin); freopen(\"b.out\", \"w\", stdout); int T, t; char buf[1 << 7]; gets(buf); sscanf(buf, \"%d\", &T); FOR(t, 0, T) { fprintf(stderr, \"Solving %d/%d\\ \", t + 1, T); SolveTest(t); } return 0; }; '", "code2": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Linq; using System.Text; using System.IO; namespace ProblemA { class Program { static void Main(string[] args) { using (var sr = new StreamReader(@\"..\\\\..\\\\B-small-attempt0.in\")) { using (var sw = new StreamWriter(@\"..\\\\..\\\\B-small-attempt0.out\")) { var T = int.Parse(sr.ReadLine()); for (int t = 1; t <= T; t++) { sr.ReadLine(); var s = sr.ReadLine().Split(); var k = Enumerable.Range(0, s.Length).ToArray(); int res = 0; do { //for (int i = 0; i < k.Length; i++) //{ // Console.Write(k[i]); // Console.Write(\" \"); //} //Console.WriteLine(); //continue; var u = new bool[50]; int i; for (i = 0; i < k.Length; i++) { int j; for (j = 0; j < s[k[i]].Length; j++) { if (u[s[k[i]][j] - \\'a\\']) { if (j > 0) { if (s[k[i]][j - 1] != s[k[i]][j]) { break; } } else { if (s[k[i - 1]][s[k[i - 1]].Length - 1] != s[k[i]][j]) { break; } } } u[s[k[i]][j] - \\'a\\'] = true; } if (j < s[k[i]].Length) { break; } } if (i == k.Length) { res++; } } while (NextPermutation(k)); sw.WriteLine(\"Case #{0}: {1}\", t, res); } } } } private static bool NextPermutation(int[] numList) { /* Knuths 1. Find the largest index j such that a[j] < a[j + 1]. If no such index exists, the permutation is the last permutation. 2. Find the largest index l such that a[j] < a[l]. Since j + 1 is such an index, l is well defined and satisfies j < l. 3. Swap a[j] with a[l]. 4. Reverse the sequence from a[j + 1] up to and including the final element a[n]. */ var largestIndex = -1; for (var i = numList.Length - 2; i >= 0; i--) { if (numList[i] < numList[i + 1]) { largestIndex = i; break; } } if (largestIndex < 0) return false; var largestIndex2 = -1; for (var i = numList.Length - 1; i >= 0; i--) { if (numList[largestIndex] < numList[i]) { largestIndex2 = i; break; } } var tmp = numList[largestIndex]; numList[largestIndex] = numList[largestIndex2]; numList[largestIndex2] = tmp; for (int i = largestIndex + 1, j = numList.Length - 1; i < j; i++, j--) { tmp = numList[i]; numList[i] = numList[j]; numList[j] = tmp; } return true; } } } '"}
{"code1": "import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStream; import java.io.PrintStream; import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; import static java.lang.Integer.*; import static java.lang.Character.*; public class B { Scanner scan; public B(Scanner s) { this.scan = s; } String[]A; long brut(char last, boolean[]U,boolean[]L) { long r =0; boolean all=true; for(int i=0;i<A.length;i++){ if(U[i])continue; all=false; boolean[]nl = L.clone(); char lc = \\'#\\'; for(char c:A[i].toCharArray()){ if(nl[c]) { if(lc!=c && !(c==last && c==A[i].charAt(0)))return 0; } nl[c]=true; } U[i]=true; r += brut(A[i].charAt(A[i].length()-1),U, nl); U[i]=false; } if(all)return 1; return r%1000000007; } public String solve() { int n = scan.nextInt(); A = new String[n]; for(int i=0;i<n;i++){ A[i]= \"\";String s =scan.next(); for(int j=0;j<s.length();j++) { if(A[i].length()==0 || A[i].charAt(A[i].length()-1)!=s.charAt(j))A[i]+=s.charAt(j); } System.out.print(A[i] +\" \"); } // System.out.println(); /* long res = brut(\\'#\\', new boolean[n], new boolean[256]); return \"\"+res; */ boolean[]EQ = new boolean[n]; for(int sn=0;sn<n;sn++){ String s = A[sn]; int d=0; boolean[] v = new boolean[256]; for(int i=0;i<s.length();i++){ if(v[s.charAt(i)] && s.charAt(i-1)!=s.charAt(i))return \"0\"; if(!v[s.charAt(i)]) { d++; v[s.charAt(i)]=true; } if(i>0 && s.charAt(i)!=s.charAt(0) && i+1<s.length() && s.charAt(i) !=s.charAt(s.length()-1)){ for(int j=0;j<n;j++){ if(j==sn)continue; for(char c:A[j].toCharArray()) { if(c==s.charAt(i))return \"0\"; } } } } EQ[sn]=d==1; } for(int i=0;i<n;i++)for(int j=0;j<n;j++){ if(i==j)continue; if(EQ[i]||EQ[j])continue; if(A[i].charAt(0)==A[j].charAt(0))return \"0\"; if(A[i].charAt(A[i].length()-1)==A[j].charAt(A[j].length()-1))return \"0\"; } boolean[][]M = new boolean[n][n]; int[]inc = new int[n]; int[]out = new int[n]; int parts =0; for(int i=0;i<n;i++){ if(EQ[i])continue; parts++; for(int j=0;j<n;j++){ if(EQ[j]||i==j)continue; if(A[i].charAt(A[i].length()-1)==A[j].charAt(0)){ M[i][j]=true; inc[j]++; out[i]++; } } } for(int i=0;i<n;i++)if(inc[i]>1||out[i]>1)return \"0\"; int ch=0; boolean cover[]=new boolean[n]; ArrayList<String> seg = new ArrayList<>(); for(int i=0;i<n;i++){ if(EQ[i])continue; if(inc[i]==0 && out[i]==0){ seg.add(A[i].charAt(0)+\"\"+A[i].charAt(A[i].length()-1)); cover[i]=true; } if(inc[i]>0 || out[i]==0)continue; String s =\"\"+A[i].charAt(0); int p =i; cover[p]=true; while(out[p]>0){ for(int j=0;j<n;j++) if(M[p][j]){ p=j; cover[p]=true; } } s+=A[p].charAt(A[p].length()-1); seg.add(s); } for(int i=0;i<n;i++)if(!EQ[i]&&!cover[i])return \"0\"; long res = 1; int free =0; long mod = 1000000007; for(char c = \\'a\\';c<=\\'z\\';c++){ int count=0;boolean att = false; for(int i=0;i<n;i++){ if(EQ[i]){ if(A[i].charAt(0)==c)count++; } } if(count==0)continue; for(int i=0;i<A.length;i++){ String s = A[i]; if(EQ[i])continue; if(s.charAt(0)==c || s.charAt(s.length()-1)==c)att=true; } if(!att && count >0)free++; for(int i=1;i<=count;i++)res = (res*i)%mod; } for(int i=1;i<=seg.size()+free;i++)res = (res*i)%mod; return \"\"+res; } int intLine(){ return parseInt(scan.nextLine()); } public static void main(String[] args) throws Exception{ Locale.setDefault(Locale.US); String cn = B.class.getName(); String sampleName = cn+\"-sample.in\"; String smallName = cn+\"-small-attempt4.in\"; String largeName = cn+\"-large.in\"; String name = largeName; String outName = name.substring(0, name.indexOf(\\'.\\'))+\".out\"; InputStream in = new BufferedInputStream(new FileInputStream(name)); PrintStream out = new PrintStream(new File(outName)); //PrintStream out = System.out; Scanner scan = new Scanner(in); int N = parseInt(scan.nextLine()); for(int c=1;c<=N;c++) { String res = new B(scan).solve(); out.printf(\"Case #%d: %s\\ \",c, res); System.err.println(c + \" done\"); } System.err.println(\"All done\"); } } '", "code2": "//Orz Sevenkplus #include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<ctime> #include<cctype> #include<complex> #include<algorithm> #include<iostream> #include<vector> #include<queue> #include<set> #include<map> #include<bitset> #define un using namespace un std; #define pb push_back #define pf pop_front #define mp make_pair #define c0 first #define c1 second #define sqr(x)((x)*(x)) #define clr(x)memset(x,0,sizeof(x)) #define clr1(x)memset(x,-1,sizeof(x)) #define clr80(x)memset(x,0x80,sizeof(x)) #define clr7F(x)memset(x,0x7F,sizeof(x)) #define ll long long #ifdef __unix__ #define LLD \"%lld\" #else #define LLD \"%I64d\" #endif #define pii pair<int,int> #define pip pair<int,pii> #define vi vector<int> #define vpi vector<pii> #define pq priority_queue template<typename T>inline bool chkmin(T&a,T b){return a>b?a=b,1:0;} template<typename T>inline bool chkmax(T&a,T b){return a<b?a=b,1:0;} #define modadd(a,b,c)(((a)+(b))%(c)) #define modmul(a,b,c)((int)(((ll)(a)*(b))%(c))) #define P 1000000007 #define getint(x){\\\\ char __next__char__;bool __nega__int__=0;\\\\ while(!isdigit(__next__char__=getchar())&&__next__char__!=\\'-\\');\\\\ __next__char__==\\'-\\'?(x=0,__nega__int__=1):(x=__next__char__-48);\\\\ while(isdigit(__next__char__=getchar()))x=x*10+__next__char__-48;\\\\ if(__nega__int__)x=-x;\\\\ } #define getint2(x1,x2){getint(x1);getint(x2);} #define getint3(x1,x2,x3){getint(x1);getint(x2);getint(x3);} #define getint4(x1,x2,x3,x4){getint(x1);getint(x2);getint(x3);getint(x4);} #define getint5(x1,x2,x3,x4,x5){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);} #define getint6(x1,x2,x3,x4,x5,x6){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);getint(x6);} char strr[200][200]; int f[26],b[26],e[26],l[200],s[26]; bool v[26]; bool check(int i){ char*str=strr[i]; clr(v); for(int j=l[i]-1;j--;){ if(str[j]!=str[j+1]){ if(v[str[j+1]-\\'a\\'])return 0; v[str[j+1]-\\'a\\']=1; } } return !v[str[0]-\\'a\\']; } int F[26]; int fa(int x){ int r=F[x],y=r; while(r!=F[r])r=F[r]; while((F[x]=r)!=(x=y))y=F[y]; return r; } int run(){ int n,ans=1; getint(n); clr(f); clr(b); clr(e); clr(s); for(int i=26;i--;)F[i]=i; for(int i=-1;++i!=n;){ clr(v); scanf(\"%s\",strr[i]); l[i]=strlen(strr[i]); char*str=strr[i]; if(str[0]==str[l[i]-1]){ e[str[0]-\\'a\\']++; ans=(ll)ans*e[str[0]-\\'a\\']%P; }else{ int x=fa(str[0]-\\'a\\'); int y=fa(str[l[i]-1]-\\'a\\'); if(x==y)return 0; F[x]=y; if(f[str[0]-\\'a\\']++){ return 0; } if(b[str[l[i]-1]-\\'a\\']++){ return 0; } } for(int j=l[i];j--;)v[str[j]-\\'a\\']=1; for(int j=26;j--;)s[j]+=v[j]; } for(int i=-1;++i!=n;){ char*str=strr[i]; if(!check(i)){ return 0; } for(int j=l[i];j--;) if(str[j]!=str[l[i]-1]&&str[j]!=str[0]){ if(s[str[j]-\\'a\\']>1)return 0; } } int q=0; for(int i=26;i--;){ if((e[i]||b[i])&&F[i]==i)q++; } while(q){ ans=(ll)ans*q%P; q--; } return ans; } int main(){ int T; getint(T); for(int t=1;t<=T;t++){ printf(\"Case #%d: %d\\ \",t,run()); } return 0; } '"}
{"code1": "def withoutDuplication(s): res = [] prev = -1 for c in s: i = ord(c) - ord(\\'a\\') if i != prev: res.append(i) prev = i return res mod = 1000000007 def fact(n): if n <= 1: return 1 return n*fact(n-1)%mod def solve(strs): n = 26 inE, outE, midE, badE = [0]*n, [0]*n, [0]*n, [0]*n g = [-1]*n for s in strs: letters = withoutDuplication(s) if len(letters) == 1: midE[letters[0]] += 1 else: outE[letters[0]] += 1 inE[letters[-1]] += 1 g[letters[0]] = letters[-1] for c in letters[1:-1]: badE[c] += 1 # print inE[:4], outE[:4], midE[:4], badE[:4], g[:4] for i in xrange(n): if badE[i] > 0 and inE[i] + outE[i] + midE[i] + badE[i] > 1: return 0 if inE[i] > 1 or outE[i] > 1: return 0 seen, nc = [False]*n, 0 for i in xrange(n): if seen[i] or inE[i] != 0: continue if outE[i] + midE[i] > 0: nc += 1 t = i while t != -1: seen[t] = True t = g[t] if len(filter(None, seen)) < n: return 0 #print nc res = fact(nc) for i in xrange(26): res *= fact(midE[i]) return res%mod T = int(raw_input()) for z in xrange(T): n = int(raw_input()) s = raw_input().strip().split(\\' \\') print \"Case #%d: %s\" % (z+1, solve(s))'", "code2": "#include <cstdlib> #include <cctype> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <vector> #include <string> #include <iostream> #include <sstream> #include <map> #include <set> #include <queue> #include <functional> using namespace std; typedef long long int64; #define PB push_back #define MP make_pair #define debug(x) cout<<(#x)<<\": \"<<(x)<<endl #define REP(i,n) for(int i=0;i<(n);++i) #define FOR(i,l,h) for(int i=(l);i<=(h);++i) #define FORD(i,h,l) for(int i=(h);i>=(l);--i) #define MOD 1000000007 inline int ADD(int a, int b) { a+=b; if (a>=MOD) a-=MOD; return (int)a; } inline void ADDTO(int &a, int b) { a+=b; if (a>=MOD) a-=MOD; } inline void SUBTO(int &a, int b) { a-=b; if (a<0) a+=MOD; } inline int MUL(int a, int b) { return (int)((int64)a*b%MOD); } int loop[30], indeg[30], oudeg[30], e[30][30], vis[30]; int fact[110], ans; void addEdge(char a, char b) { int u = a - \\'a\\', v = b - \\'a\\'; ++oudeg[u]; ++indeg[v]; e[u][v] = 1; } void dfs(int u) { vis[u] = 1; ans = MUL(ans, fact[loop[u]]); if (oudeg[u] > 0) { REP(v, 26) if (e[u][v] == 1) dfs(v); } } int main() { int tN; cin >> tN; fact[0] = 1; FOR(i, 1, 100) fact[i] = MUL(i, fact[i-1]); FOR(cN, 1, tN) { memset(loop, 0, sizeof(loop)); memset(indeg, 0, sizeof(indeg)); memset(oudeg, 0, sizeof(oudeg)); memset(e, 0, sizeof(e)); memset(vis, 0, sizeof(vis)); int n; cin >> n; REP(i, n) { string s; cin >> s; bool same = 1; REP(i, s.size()) { if (s[i] != s[0]) same = 0; if (i && s[i] != s[i-1]) addEdge(s[i-1], s[i]); } if (same) ++loop[s[0] - \\'a\\']; } bool nosol = 0; REP(i, 26) if (indeg[i] > 1 || oudeg[i] > 1) nosol = 1; if (!nosol) { ans = 1; int ncc = 0; REP(i, 26) if (!vis[i] && indeg[i] == 0) { if (oudeg[i] > 0 || loop[i] > 0) ++ncc; dfs(i); } ans = MUL(ans, fact[ncc]); REP(i, 26) if (!vis[i]) nosol = 1; } printf(\"Case #%d: \", cN); if (nosol) puts(\"0\"); else printf(\"%d\\ \", ans); } } '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; namespace CodeJam { internal class TestCase { public string[] Cars; } internal class Pair { public char First { get; set; } public char Last { get; set; } } internal class Program { private const string testFileName = \"B-large\"; private const int Base = 1000000007; public static IEnumerable<TestCase> ParseCases(TextReader reader) { var testCaseCount = int.Parse(reader.ReadLine()); for (var i = 0; i < testCaseCount; i++) { var carCount = int.Parse(reader.ReadLine()); var cars = reader.ReadLine().Split(); yield return new TestCase { Cars = cars }; } } private static long Solve(TestCase testCase) { // 3 types of cars // single letters: aaa // two letters: aabb // multiple letters aabcddd // simplify consecutive letters var withoutRuns = testCase.Cars.Select(RemoveConsecutive).ToArray(); var singleLetters = withoutRuns.Where(c => c.Length == 1).Select(c => c[0]).ToArray(); var hiddenLetters = withoutRuns.Where(c => c.Length > 2).SelectMany(c => c.Substring(1, c.Length - 2)).Distinct().ToArray(); var pairs = withoutRuns.Where(c => c.Length > 1).Select(c => new Pair { First = c[0], Last = c[c.Length - 1] }).ToArray(); // eliminate case 3 now if (pairs.Any(p => hiddenLetters.Contains(p.First) || hiddenLetters.Contains(p.Last)) || singleLetters.Any(hiddenLetters.Contains)) return 0; // we know just have to find orderings for pairs and single letters. // check that all the pairs can be ordered successfully if (pairs.Select(p => p.First).Distinct().Count() != pairs.Count() || pairs.Select(p => p.Last).Distinct().Count() != pairs.Count()) return 0; //check the groups that have an order imposed on them by the pairs var sortedPairs = GetFixedChains(pairs); if (sortedPairs == null) return 0; var singleLetterCounts = singleLetters.GroupBy(c => c, (key, values) => Tuple.Create(key, values.Count())); var lettersInChains = sortedPairs.SelectMany(p => p).SelectMany(p => new[] { p.First, p.Last }).Distinct(); var independentSingleLetters = singleLetters.Except(lettersInChains).ToArray(); // single letters can be in any order relative to each other long combinations = 1; foreach (var pair in singleLetterCounts) { combinations *= Factorial(pair.Item2); combinations %= Base; } // chains can be in any order relative to each other, and to the independent letters var independentBlockCount = independentSingleLetters.Count() + sortedPairs.Length; combinations *= Factorial(independentBlockCount); combinations %= Base; return combinations; } private static long Factorial(int x) { long fact = 1; while (x > 1) { fact *= x; fact %= Base; x--; } return fact; } private static Pair[][] GetFixedChains(Pair[] pairs) { var remainingPairs = pairs.ToList(); var sorted = new List<Pair[]>(); while (remainingPairs.Count > 0) { var chain = new List<Pair>(); var current = remainingPairs[0]; remainingPairs.RemoveAt(0); chain.Add(current); int index; var first = current; while ((index = remainingPairs.FindIndex(p => p.Last == first.First)) >= 0) { first = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Insert(0, first); } var last = current; while ((index = remainingPairs.FindIndex(p => p.First == last.Last)) >= 0) { last = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Add(last); } if (last.Last == first.First) return null; sorted.Add(chain.ToArray()); } return sorted.ToArray(); } private static string RemoveConsecutive(string arg) { var builder = new StringBuilder(arg.Length); char current = \\'\\\\0\\'; foreach (var c in arg) { if (c != current) { builder.Append(c); current = c; } } return builder.ToString(); } private static void Main(string[] args) { TestCase[] cases; using (var reader = new StreamReader(testFileName + \".in\")) using (var writer = new StreamWriter(testFileName + \".out\")) { cases = ParseCases(reader).ToArray(); for (int caseIndex = 0; caseIndex < cases.Length; caseIndex++) { var testCase = cases[caseIndex]; var solution = Solve(testCase); writer.WriteLine(\"Case #{0}: {1}\", caseIndex + 1, solution); } } } } }'", "code2": "#include <stdio.h> #include <stdlib.h> #include <string.h> #define M 1000000007LL //char *train[10]; int N; int count; int embedded[26]; int oneletter[26]; int endswith[26]; int startswith[26]; int impossible=0; int used; int segment; char *destutter(char *s) { static char buf2[200]; char *d=buf2; char last=0; while (*s) { if (*s!=last) last=*d++ = *s; s++; } *d=0; return buf2; } void readtrains(void) { int i,len,j; static char buff[200]; char *b; impossible=0; scanf(\"%d\",&N); for (i=0;i<26;i++) { embedded[i]=0; oneletter[i]=0; endswith[i]=-1; startswith[i]=-1; } for (i=0;i<N;i++) { scanf(\"%s\",buff); b=destutter(buff); len=strlen(b); if (len==1) { oneletter[*b-\\'a\\']++; continue; } if (startswith[*b-\\'a\\']>=0) impossible++; if (endswith[b[len-1]-\\'a\\']>=0) impossible++; startswith[*b-\\'a\\']=b[len-1]-\\'a\\'; endswith[b[len-1]-\\'a\\']=*b-\\'a\\'; for (j=1;j<len-1;j++) embedded[b[j]-\\'a\\']++; } } int modtimes(int a, int b) { return (int)((1LL*a*b) % M); } int factorial(int n) { int f=1; int i; if (n<=1) return 1; for (i=2;i<=n;i++) f=modtimes(f,i); return f; } void countonlyi(int i) { segment++; //printf(\"countonly %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); } void countendi(int i) { segment++; //printf(\"countend %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! while (1) { if ((1<<i) & used) {impossible++;return;} used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); i=endswith[i]; if (i<0) break; } } void countstarti(int i) { int used2=1<<i; //printf(\" Cs %c\\ \",i+\\'a\\'); while (startswith[i]>=0) { i=startswith[i]; //printf(\" cs %c\\ \",i+\\'a\\'); if (used2 & (1<<i)) { //printf(\"imp\\ \"); impossible++;return; } used2|=1<<i; } countendi(i); } void counttrains(void) { int i; count=1; used=0; segment=0; for (i=0;i<26;i++) { if (impossible || embedded[i]>1 || embedded[i] && (startswith[i]>=0 || endswith[i]>=0)) { printf(\"0\\ \"); //impossible return; } } i=0; while (i<26 && !impossible) { if (startswith[i]>=0 && !((1<<i) & used)) countstarti(i); if (endswith[i]>=0 && !((1<<i) & used)) countendi(i); if (oneletter[i]>0 && !((1<<i) & used)) countonlyi(i); i++; } if (impossible) printf(\"0\\ \"); else printf(\"%d\\ \",count); } void dump(void) { int i; printf(\"\\ \"); for (i=0;i<26;i++) { if (startswith[i]<0 && endswith[i]<0 && embedded[i]==0 && oneletter[i]==0) continue; printf(\" %c : ->%c %c<- em=%d 1L=%d\\ \",i+\\'a\\',startswith[i]+\\'a\\',endswith[i]+\\'a\\',embedded[i],oneletter[i]); } } int main(int argc, char **argv) { int tc,i; scanf(\"%d\",&tc); for (i=1;i<=tc;i++) { printf(\"Case #%d: \",i); readtrains(); //dump(); counttrains(); } return 0; } '"}
{"code1": "// uses http://introcs.cs.princeton.edu/java/stdlib/StdIn.java public class Train { static final int MOD = 1_000_000_007; public static long calc(String[] cars) { long result = 1; int n = cars.length; for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) { //System.out.println(java.util.Arrays.toString(cars)); int solocount = 0; int start = -1; int mid = -1; int end = -1; int solo = -1; for (int i=0; i<n; i++) { if (cars[i] == null) { } else if (cars[i].matches(\"\"+ch+\\'+\\')) { solocount++; result *= solocount; result %= MOD; cars[i] = null; solo = i; } else if (cars[i].matches(ch+\"+[^\"+ch+\"]+\")) { if (start != -1) return 0; start = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+\")) { if (end != -1) return 0; end = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+[^\"+ch+\"]+\")) { if (mid != -1) return 0; mid = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\")) { } else return 0; } //System.out.println(ch+\" \"+solocount+\" \"+start+\" \"+solo+\" \"+end+\" \"+result); if (mid == -1 && solocount == 0 && start == -1 && end == -1) continue; if (mid != -1 && (solocount > 0 || start != -1 || end != -1)) return 0; if (mid != -1) continue; String repl = \"\"; if (end != -1) {repl += cars[end]; cars[end] = null;} if (solo != -1) repl += ch; if (start != -1) {repl += cars[start]; cars[start] = null;} if (start != -1) {cars[start] = repl;} else if (solo != -1) {cars[solo] = repl;} else cars[end] = repl; } int left = 0; for (String s : cars) if (s != null) { left ++; result *= left; result %= MOD; } return result; } public static void main(String[] args) { int q = StdIn.readInt(); for (int j=1; j<=q; j++) { int n = StdIn.readInt(); String[] cars = new String[n]; { for (int i=0; i<n; i++) cars[i] = StdIn.readString(); } System.out.printf(\"Case #%d: %d\\ \", j, calc(cars)); } } } '", "code2": "import static java.lang.Math.*; import java.io.*; import java.math.*; import java.util.*; public class ProblemBLarge { static class Car { String s; LinkedHashMap<Character, Long> numAddedSameCharCars = new LinkedHashMap<Character, Long>(); char getFirst() { return s.charAt(0); } char getLast() { return s.charAt(s.length() - 1); } void addAllSameChars(Car car) { for (Map.Entry<Character, Long> entry : car.numAddedSameCharCars.entrySet()) { Character key = entry.getKey(); Long value = numAddedSameCharCars.get(key); if (value == null) value = 0L; value += entry.getValue(); numAddedSameCharCars.put(key, value); } } @Override public String toString() { return \"\"+s+\" (\"+numAddedSameCharCars+\")\"; } } public class Case { LinkedHashSet<Car> cars = new LinkedHashSet<Car>(); LinkedHashSet<Car> carsToCheck = new LinkedHashSet<Car>(); public void solve(int caseIndex) { for (Car car : cars) { if (isSameCharCar(car)) { car.numAddedSameCharCars.put(car.s.charAt(0), 1L); } } // System.out.println(\"Cars: \"+cars); carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); // LinkedHashSet<Car> carsWithSameChar = new LinkedHashSet<Car>(); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); if (isSameCharCar(car)) { for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } } carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } BigInteger result; if (!isValid()) { result = BigInteger.valueOf(0); } else { long mod = 1000000007L; result = BigInteger.valueOf(1); for (long i = 1; i <= cars.size(); i++) { result = result.multiply(BigInteger.valueOf(i)); } for (Car car : cars) { for (Long sameChars : car.numAddedSameCharCars.values()) { long a = 1; for (long i = 1; i <= sameChars; i++) { a *= i; a %= mod; } result = result.multiply(BigInteger.valueOf(a)); } } result = result.mod(BigInteger.valueOf(mod)); } // long result; // if (!isValid()) { // result = 0; // } // else { // long mod = 1000000007L; // // result = 1; // for (long i = 1; i <= cars.size(); i++) { // result *= i; // result %= mod; // } // // for (Car car : cars) { // for (Long sameChars : car.numAddedSameCharCars.values()) { // long a = 1; // for (long i = 1; i <= sameChars; i++) { // a *= i; // a %= mod; // } // result *= a; // result %= mod; // } // } // } println(\"Case #\" + (caseIndex + 1) + \": \" + result); } void combineCars(Car car1, Car car2) { Car car = new Car(); car.s = car1.s + car2.s; car.addAllSameChars(car1); car.addAllSameChars(car2); // car.numAddedSameCharCars = car1.numAddedSameCharCars + car2.numAddedSameCharCars; cars.add(car); carsToCheck.add(car); cars.remove(car1); carsToCheck.remove(car1); cars.remove(car2); carsToCheck.remove(car2); // System.out.println(\"Cars: \"+cars); } boolean isSameCharCar(Car car) { String s = car.s; for (int k = 0; k < s.length(); k++) { if (s.charAt(k) != s.charAt(0)) { return false; } } return true; } boolean isValid() { LinkedHashSet<Character> processed = new LinkedHashSet<>(); Character last = null; for (Car car : cars) { String s = car.s; for (int k = 0; k < s.length(); k++) { char ch = s.charAt(k); // System.out.println(\"Current: \"+ch); if (last != null && last.charValue() == ch) { // System.out.println(\"Last: \"+last+\", processed: \"+processed); } else { if (processed.contains(ch)) return false; processed.add(ch); } last = ch; } } return true; } long factorial(long p) { long result = 1; for (long i = 2; i <= p; i++) result *= i; return result; } } public void run() throws Exception { BufferedReader r = new BufferedReader(new FileReader(\"input.txt\")); int numCases = new InputParser(r.readLine()).readInt(); for (int caseIndex = 0; caseIndex < numCases; caseIndex++) { Case c = new Case(); InputParser p = new InputParser(r.readLine()); int numCars = p.readInt(); p = new InputParser(r.readLine()); for (int i = 0; i < numCars; i++) { Car car = new Car(); car.s = p.readToken(); c.cars.add(car); } c.solve(caseIndex); } r.close(); } public static void main(String[] args) throws Exception { fileWriter = new PrintWriter(new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"output.txt\")))); new ProblemBLarge().run(); fileWriter.close(); } public static class InputParser { String text; int pos; public InputParser(String text) { this.text = text; } public void skipSpaces() { while (pos < text.length()) { if (text.charAt(pos) != \\' \\') break; pos++; } } public String readUntil(char expectedChar) { StringBuilder b = new StringBuilder(); while (pos < text.length()) { char ch = text.charAt(pos); if (ch == expectedChar) break; b.append(ch); pos++; } return b.toString(); } public String readToken() { skipSpaces(); return readUntil(\\' \\'); } public int readInt() { return Integer.parseInt(readToken()); } public long readLong() { return Long.parseLong(readToken()); } public double readDouble() { return Double.parseDouble(readToken()); } public char readChar() { char ch = text.charAt(pos); pos++; return ch; } public void readExpectedString(String s) { for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (readChar() != ch) throw new RuntimeException(\"Expected: \"+ch); } } } public static PrintWriter fileWriter; public static void print(String text) { fileWriter.print(text); System.out.print(text); } public static void println(String text) { fileWriter.println(text); System.out.println(text); } public static <Key, Value> void addToMultiMapArrayList(Key key, Value value, Map<Key, ArrayList<Value>> map) { ArrayList<Value> list = map.get(key); if (list == null) { list = new ArrayList<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> void addToMultiMapLinkedHashSet(Key key, Value value, Map<Key, LinkedHashSet<Value>> map) { LinkedHashSet<Value> list = map.get(key); if (list == null) { list = new LinkedHashSet<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> ArrayList<Value> getMultiMapValues(Map<Key, Collection<Value>> map) { ArrayList<Value> result = new ArrayList<Value>(); for (Collection<Value> list : map.values()) { result.addAll(list); } return result; } // binarySearch(, , 0.000000001, new Function<Double, Integer>() { // public Integer evaluate(Double key) { // return ; // } // }); public static double binarySearch(double low, double high, double precision, Function<Double, Integer> f) { if (high < low) throw new RuntimeException(\"High (\"+high+\") cannot be smaller than low (\"+low+\")\"); { int lowValue = f.evaluate(low); if (lowValue == 0) return low; if (lowValue > 0) throw new RuntimeException(\"Unsuitable low: \"+low); } { int highValue = f.evaluate(high); if (highValue == 0) return high; if (highValue < 0) throw new RuntimeException(\"Unsuitable high: \"+high); } while (true) { double mid = (low + high) * 0.5; if (abs(high - low) < precision) { return mid; } int c = f.evaluate(mid); if (c < 0) low = mid; else if (c > 0) high = mid; else return mid; } } public static <T> LinkedHashSet<T> intersection(Set<T> s1, Set<T> s2) { if (s2.size() < s1.size()) { Set<T> temp = s1; s1 = s2; s2 = temp; } LinkedHashSet<T> result = new LinkedHashSet<T>(); for (T o : s1) { if (s2.contains(o)) result.add(o); } return result; } public static interface Function<Key, Value> { public Value evaluate(Key key); } public static class Int2 { int x, y; public Int2(int x, int y) { this.x = x; this.y = y; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Int2 other = (Int2) obj; if (x != other.x) return false; if (y != other.y) return false; return true; } @Override public String toString() { return \"(\"+x+\",\"+y+\")\"; } } } '"}
{"code1": "#include <iostream> #include <fstream> #include <string> #include <algorithm> #include <cstdlib> #include <cstring> #include <set> #include <map> #include <vector> #include <stack> #include <queue> #include <deque> #include <iomanip> #include <cassert> typedef long long ll; typedef unsigned long long ull; using namespace std; bool is_aaa(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] != c) return false; } return true; } bool is_aax(const string& s, char c) { return s[0] == c; } bool is_yaa(const string& s, char c) { return s[(int)s.size() - 1] == c; } bool is_uav(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] == c) return true; } return false; } int fragment_count(const string& s, char c) { int result = 0; int n = (int)s.size(); int i = 0; while (i < n) { if (s[i] != c) i++; else { int j = i; while (j + 1 < n && s[j + 1] == c) j++; result++; i = j + 1; } } return result; } const int MAXN = 109; int N; string s[MAXN]; vector<string> pieces; const ll MOD = 1000000007; ll fact[MAXN]; ll solve(void) { pieces.clear(); for (int i = 0; i < N; i++) pieces.push_back(s[i]); ll result = 1; for (char c = \\'a\\'; c <= \\'z\\'; c++) { vector<string> aaa; vector<string> aax; vector<string> yaa; vector<string> uav; vector<string> other; for (int i = 0; i < pieces.size(); i++) { if (is_aaa(pieces[i], c)) aaa.push_back(pieces[i]); else if (is_aax(pieces[i], c)) aax.push_back(pieces[i]); else if (is_yaa(pieces[i], c)) yaa.push_back(pieces[i]); else if (is_uav(pieces[i], c)) uav.push_back(pieces[i]); else other.push_back(pieces[i]); } if (uav.size() != 0) { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0 && uav.size()==1 && fragment_count(uav[0], c)==1) { ; } else return 0LL; } else { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0) { ; // no constraints at all } else { if (yaa.size() <= 1 && aax.size() <= 1) { if (yaa.size() == 1) { if (fragment_count(yaa[0], c) > 1) return 0LL; } if (aax.size() == 1) { if (fragment_count(aax[0], c) > 1) return 0LL; } result *= fact[aaa.size()]; result %= MOD; pieces = other; string new_piece; if (yaa.size() != 0) new_piece += yaa[0]; for (int i = 0; i < aaa.size(); i++) new_piece += aaa[i]; if (aax.size() != 0) new_piece += aax[0]; pieces.push_back(new_piece); } else return 0LL; } } } result *= fact[pieces.size()]; result %= MOD; return result; } void solve_B(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; fact[0] = 1LL; for (int i = 1; i < MAXN; i++) fact[i] = (fact[i - 1] * i) % MOD; for (int tt = 1; tt <= T; tt++) { for (int i = 0; i < MAXN; i++) s[i] = \"\"; in >> N; for (int i = 0; i < N; i++) in >> s[i]; ll temp = solve(); out << \"Case #\" << tt << \": \"; out << temp; out << \\'\\ \\'; } in.close(); out.close(); } int main() { //solve_A(); solve_B(); //solve_C(); return 0; } void solve_(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; for (int tt = 1; tt <= T; tt++) { out << \"Case #\" << tt << \": \"; } in.close(); out.close(); }'", "code2": "import java.util.HashSet; import java.util.Scanner; import java.util.Set; public class B { static final long BASE = 1000000007; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int cases = sc.nextInt(); long[] factorial = new long[101]; factorial[0] = 1; for (int i = 1; i < 101; i++) { factorial[i] = (factorial[i - 1] * i) % BASE; } for (int caseNum = 1; caseNum <= cases; caseNum++) { int N = sc.nextInt(); String[] cars = new String[N]; Set<Character> interior = new HashSet<Character>(); int[] singleLetterStrs = new int[26]; int[] starts = new int[26]; int[] ends = new int[26]; char[] next = new char[26]; boolean possible = true; for (int i = 0; i < N; i++) { cars[i] = sc.next(); int firstChar = cars[i].charAt(0) - \\'a\\'; char lastChar = cars[i].charAt(cars[i].length() - 1); if (isSingleLetter(cars[i])) { int index = firstChar; singleLetterStrs[index]++; } else { for (Character ch : getInteriorChars(cars[i])) { if (interior.contains(ch)) { possible = false; break; } interior.add(ch); } starts[firstChar]++; ends[lastChar - \\'a\\']++; next[firstChar] = lastChar; } } int numGroups = 0; for (int i = 0; i < 26; i++) { if (!possible) { break; } char ch = (char) (\\'a\\' + i); if (interior.contains(ch) && (singleLetterStrs[i] + starts[i] + ends[i] > 0)) { possible = false; } if (starts[i] > 1 || ends[i] > 1) { possible = false; } if (singleLetterStrs[i] > 0 && starts[i] == 0 && ends[i] == 0) { numGroups++; } else if (starts[i] == 1 && ends[i] == 0) { numGroups++; } } possible = possible && !hasCycles(next); System.out.print(\"Case #\" + caseNum + \": \"); if (!possible) { System.out.println(0); continue; } long ways = 1; for (int i = 0; i < 26; i++) { ways = (ways * factorial[singleLetterStrs[i]]) % BASE; } ways = (ways * factorial[numGroups]) % BASE; System.out.println(ways); } } private static boolean hasCycles(char[] next) { for (int i = 0; i < 26; i++) { if (next[i] == 0) { continue; } char start = (char) (\\'a\\' + i); int currIndex = i; while (next[currIndex] != 0 && next[currIndex] != start) { currIndex = next[currIndex] - \\'a\\'; } if (next[currIndex] == start) { return true; } } return false; } private static Set<Character> getInteriorChars(String str) { Set<Character> chars = new HashSet<Character>(); if (isSingleLetter(str)) { return chars; } int startIndex = 0; while (str.charAt(startIndex + 1) == str.charAt(0)) { startIndex++; } int endIndex = str.length() - 1; while (str.charAt(endIndex - 1) == str.charAt(str.length() - 1)) { endIndex--; } for (int i = startIndex + 1; i < endIndex; i++) { chars.add(str.charAt(i)); } return chars; } private static boolean isSingleLetter(String str) { char ch = str.charAt(0); for (int i = 1; i < str.length(); i++) { if (str.charAt(i) != ch) { return false; } } return true; } } '"}
{"code1": "#include <stdio.h> #include <stdlib.h> #include <math.h> #include <ctype.h> #include <string.h> int TC, T; int Cars; char Car[120][120]; char Visited[130]; int Stack[120]; int Used[120]; int i, x, y, L, Ans; char Last; int DFS(int Level){ if (Level==Cars){ int i, x; Last = Car[Stack[0]][0]; memset(Visited, 0, sizeof(Visited)); Visited[Last] = 1; for (i=0; i<Cars; i++){ L = strlen(Car[Stack[i]]); for (x=0; x<L; x++){ if (Car[Stack[i]][x]==Last) continue; if (Visited[Car[Stack[i]][x]]) return ; Visited[Car[Stack[i]][x]] = 1; Last = Car[Stack[i]][x]; } } Ans++; return ; } int i; for (i=0; i<Cars; i++) if (!Used[i]){ Used[i] = 1; Stack[Level] = i; DFS(Level+1); Used[i] = 0; } } int main(){ freopen(\"B-small-attempt0.in\", \"r\", stdin); freopen(\"B-small-attempt0.out\", \"w\", stdout); scanf(\"%d\", &TC); for (T=1; T<=TC; T++){ printf(\"Case #%d: \", T); scanf(\"%d\", &Cars); for (i=0; i<Cars; i++) scanf(\"%s\", Car[i]); Ans = 0; DFS(0); printf(\"%d\\ \", Ans); } return 0; } '", "code2": "#!/usr/bin/pypy import itertools,math,sys def simple_solve(N,S): S = sorted(S) cnt = 0 for perm in itertools.permutations(S): z = \"\".join(perm) chars = [False for _ in range(26)] last = \\'\\' for c in z: if last==c: continue last = c if chars[ord(c)-ord(\\'a\\')]: break chars[ord(c)-ord(\\'a\\')] = True else: cnt += 1 return cnt def true_solve(N,S): rz = {} for c in range(26): char = chr(c+ord(\\'a\\')) cnt_inside = cnt_left = cnt_right = cnt_full = 0 left_char = right_char = \"\" for z in S: h = False last = \"\" for x in z: if x==char and h and last != char: return 0 if x==char: h = True last = x if z[0] == z[-1] == char: cnt_full += 1 elif z[0] == char: cnt_left += 1 right_char = z[-1] elif z[-1] == char: cnt_right += 1 left_char = z[0] elif h: cnt_inside += 1 if cnt_inside > 1 or cnt_inside > 0 and cnt_left+cnt_right+cnt_full>0 or cnt_left>1 or cnt_right>1: return 0 if cnt_inside == 0 and cnt_left+cnt_right+cnt_full>0: rz[char] = ((left_char,right_char,math.factorial(cnt_full))) blocks = 0 bb = 1 while rz: for c,v in rz.items(): if v[0]==\"\": break else: return 0 del rz[c] bb *= v[2] while v[1] != \"\": if v[1] not in rz: return 0 v = rz.pop(v[1]) bb *= v[2] blocks += 1 return math.factorial(blocks)*bb%1000000007 def solve(): N = int(raw_input()) S = raw_input().strip().split() val1 = true_solve(N,S) #val2 = simple_solve(N,S) #if val1 != val2: # print \"Bad\" # print N,S # print val1,val2 # sys.exit(1) return val1 T = int(raw_input()) for t in range(1,T+1): print \"Case #%d:\"%t,solve() '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Linq; using System.Numerics; using System.Text; using System.Threading.Tasks; namespace GCJ2014R1CB { class Program { /// <summary> /// \\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe6\\x95\\xb0 /// </summary> static int ThreadCount = 1; /// <summary> /// \\xe9\\x80\\xb2\\xe6\\x8d\\x97\\xe3\\x82\\x92\\xe8\\xa1\\xa8\\xe7\\xa4\\xba\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 /// </summary> static bool Verbose = true; static int ProgressInterval = 1; class Solver { public List<string> SolveAll(int threadId, StreamReader sr) { // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ int TestCase = int.Parse(sr.ReadLine()); // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ List<string> outputs = new List<string>(); for (int testCase = 0; testCase < TestCase; testCase++) { // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ int N = int.Parse(sr.ReadLine()); string l = sr.ReadLine(); // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ #region if (testCase % ThreadCount != threadId) { // \\xe3\\x81\\x93\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xae\\xe6\\x8b\\x85\\xe5\\xbd\\x93\\xe3\\x81\\xa7\\xe3\\x81\\xaf\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe3\\x81\\xae\\xe3\\x81\\xa7\\xe8\\xa7\\xa3\\xe3\\x81\\x8b\\xe3\\x81\\xaa\\xe3\\x81\\x84 continue; } if (Verbose) { if (testCase % ProgressInterval == 0) { Console.Error.WriteLine(testCase + \" / \" + TestCase); } } #endregion // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ string output = Solve(testCase, l); // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ outputs.Add(output); } return outputs; } const long Mod = 1000000007; string Solve(int testCase, string l) { if (testCase == -1) { } List<string> ts = l.Split(\\' \\').ToList(); BigInteger ans = 1; for(char c = \\'a\\'; c <= \\'z\\'; c++) { int ct = 0; string ns = \"\"; for(int i = 0; i < ts.Count; i++) { if (ts[i].First() == c && ts[i].Last() == c) { ns += ts[i]; ct++; ans *= ct; ts.RemoveAt(i); i--; } } if (ct > 0) { ts.Add(ns); } } for(;;) { bool f = Update(ts, true); if (f == false) { break; } } for(;;) { bool f = Update(ts, false); if (f == false) { break; } } string all = string.Concat(ts); for(char c = \\'a\\'; c <= \\'z\\'; c++) { int first = all.IndexOf(c); if (first < 0) { continue; } int last = all.LastIndexOf(c); for(int i = first; i < last; i++) { if (all[i] != c) { return \"0\"; } } } for(int i = 1; i <= ts.Count; i++) { ans *= i; } ans %= Mod; return ans.ToString(); } static bool Update(List<string> ts, bool primary) { int N = ts.Count(); for(int i = 0; i < N; i++) { if (primary && ts[i].First() != ts[i].Last()) { continue; } for(int j = 0; j < N; j++) { if (i == j) { continue; } if (ts[i].Last() == ts[j].First()) { ts[i] += ts[j]; ts.RemoveAt(j); return true; } } } return false; } } static void Main(string[] args) { // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\x84\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\x9f\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\xab\\xe5\\xaf\\xbe\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe5\\x87\\xa6\\xe7\\x90\\x86\\xe3\\x82\\x92\\xe8\\xa1\\x8c\\xe3\\x81\\x86\\xe3\\x80\\x82 // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe3\\x82\\xab\\xe3\\x83\\xac\\xe3\\x83\\xb3\\xe3\\x83\\x88\\xe3\\x83\\x87\\xe3\\x82\\xa3\\xe3\\x83\\xac\\xe3\\x82\\xaf\\xe3\\x83\\x88\\xe3\\x83\\xaa\\xe3\\x81\\xae large \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81 // small \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81sample.in \\xe3\\x82\\x92\\xe9\\xa0\\x86\\xe3\\x81\\xab\\xe6\\xa4\\x9c\\xe7\\xb4\\xa2\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 // large \\xe3\\x82\\x84 small \\xe3\\x81\\x8c\\xe8\\xa4\\x87\\xe6\\x95\\xb0\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe5\\x90\\x8d\\xe5\\x89\\x8d\\xe3\\x81\\xa7\\xe3\\x82\\xbd\\xe3\\x83\\xbc\\xe3\\x83\\x88\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe4\\xb8\\x80\\xe7\\x95\\xaa\\xe6\\x9c\\x80\\xe5\\xbe\\x8c\\xe3\\x81\\xae\\xe3\\x82\\x92\\xe4\\xbd\\xbf\\xe3\\x81\\x86\\xe3\\x80\\x82 string inputName = null; if (args.Length > 0) { if (File.Exists(args[0]) == false) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } inputName = args[0]; } if (inputName == null) { List<string> larges = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"large\") && fi.Name.EndsWith(\".in\")) { larges.Add(fi.FullName); } } if (larges.Count > 0) { larges.Sort(); inputName = larges[larges.Count - 1]; } } if (inputName == null) { List<string> smalls = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"small\") && fi.Name.EndsWith(\".in\")) { smalls.Add(fi.FullName); } } if (smalls.Count > 0) { smalls.Sort(); inputName = smalls[smalls.Count - 1]; } } if (inputName == null) { foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.ToLower() == \"sample.in\") { inputName = fi.FullName; break; } } } if (inputName == null) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } // \\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe5\\x85\\x88\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x82\\x92\\xe6\\xb1\\xba\\xe5\\xae\\x9a\\xe3\\x81\\x97\\xe3\\x80\\x81\\xe5\\x90\\x8c\\xe5\\x90\\x8d\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x83\\xaa\\xe3\\x83\\x8d\\xe3\\x83\\xbc\\xe3\\x83\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 string outputName = inputName; if (outputName.EndsWith(\".in\")) { outputName = outputName.Substring(0, outputName.Length - 3); } outputName += \".out\"; if (File.Exists(outputName)) { int rev = 1; while (File.Exists(outputName + \".\" + rev)) { rev++; } File.Move(outputName, outputName + \".\" + rev); } // \\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82ThreadCount == 1 \\xe3\\x81\\xaa\\xe3\\x82\\x89\\xe3\\x80\\x81\\xe7\\x8f\\xbe\\xe5\\x9c\\xa8\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xa7\\xe3\\x80\\x81\\xe3\\x81\\x9d\\xe3\\x82\\x8c\\xe4\\xbb\\xa5\\xe5\\xa4\\x96\\xe3\\x81\\xaa\\xe3\\x82\\x89 Parallel \\xe3\\x81\\xa7\\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 List<string>[] outputs = new List<string>[ThreadCount]; if (ThreadCount == 1) { for (int i = 0; i < ThreadCount; i++) { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } } } else { Parallel.For(0, ThreadCount, i => { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } }); } // \\xe7\\xb5\\x90\\xe6\\x9e\\x9c\\xe3\\x82\\x92\\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82Case # \\xe3\\x81\\xaf\\xe3\\x81\\x93\\xe3\\x81\\x93\\xe3\\x81\\xa7\\xe4\\xbb\\x98\\xe5\\x8a\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 using (StreamWriter sw = new StreamWriter(outputName)) { for (int i = 0; ; i++) { if (outputs[i % ThreadCount].Count > i / ThreadCount) { sw.WriteLine(\"Case #\" + (i + 1) + \": \" + outputs[i % ThreadCount][i / ThreadCount]); } else { break; } } } } } } '", "code2": "#include<stdio.h> #include<stdlib.h> #include<string.h> #define MOD 1000000007LL int t,T,n,N; long long frac[128]; long long C; char s[128][128]; long long ans; char start[128];/*First Letter*/ char end[128];/*Last Letter*/ char blocked[256]; /*Internal characters*/ int first; int tmp; int c; int only_start[256]; int only_end[256]; int loops[256]; int done[256]; int num_frag; char tmp2; char tmp3; int main(){ scanf(\"%d\",&T); frac[0]=1; for(C=1;C<120;C++) frac[C]=(frac[C-1]*C)%MOD; for(t=1;t<=T;t++){ scanf(\"%d\",&N); for(n=1;n<=N;n++){scanf(\"%s\",&s[n][0]);} for(c=0;c<256;c++) { blocked[c]=0; only_start[c]=0; only_end[c]=0; loops[c]=0; } ans=1; for(n=1;n<=N;n++) { tmp=strlen(s[n]); first=1; start[n]=s[n][0]; end[n]=s[n][tmp-1]; for(c=1;c<tmp;c++) { if (s[n][c]!=s[n][c-1]) { if (blocked[s[n][c]]==1) ans=0; if (first==0) { blocked[s[n][c-1]]=1; } first=0; } } if ((start[n]==end[n])&&(first==0)) ans=0; } if (ans==1) { for(n=1;n<=N;n++) { if (blocked[start[n]]==1) ans=0; if (blocked[end[n]]==1) ans=0; } } if (ans==1) { for(n=1;n<=N;n++) { if (start[n]==end[n]) {loops[start[n]]++;} else { only_start[start[n]]++; only_end[end[n]]++; } } for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if (only_start[tmp2]>1) ans=0; if (only_end[tmp2]>1) ans=0; } } if (ans==1) { num_frag=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) num_frag++; if ((only_start[tmp2]==0)&&(only_end[tmp2]==0)&&(loops[tmp2]>0)) num_frag++; ans*=frac[loops[tmp2]]; ans%=MOD; } ans*=frac[num_frag]; ans%=MOD; } /*Detect cycles*/ if (ans!=0) { for(c=0;c<256;c++) done[c]=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) { tmp3=tmp2; do{ for(n=1;n<=N;n++) { if ((start[n]==tmp3)&&(start[n]!=end[n])) break; } done[n]=1; tmp3=end[n]; } while (only_start[tmp3]==1); } } for(n=1;n<=N;n++) { if ((done[n]==0)&&(start[n]!=end[n])) ans=0; } } printf(\"Case #%d: \",t); printf(\"%lld\\ \",ans); } return 0; } '"}
{"code1": "//#pragma comment(linker, \"/STACK:134217728\") #include <iostream> #include <sstream> #include <cstdio> #include <cstdlib> #include <cmath> #include <cctype> #include <cstring> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> #include <numeric> using namespace std; typedef long long Int; typedef pair<int,int> PII; typedef vector<int> VInt; #define FOR(i, a, b) for(i = (a); i < (b); ++i) #define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i) #define CLEAR(a, b) memset(a, b, sizeof(a)) #define SIZE(a) int((a).size()) #define ALL(a) (a).begin(),(a).end() #define PB push_back #define MP make_pair #define MOD 1000000007 string S[256]; int A[256]; int C[256]; int Next[256]; int Prev[256]; int B[256]; Int dfs(int a) { if (a == -1) return 1; B[a] = 1; Int res = 1; int i; FOR(i, 0, C[a]) res = res * (i + 1) % MOD; return res * dfs(Next[a]) % MOD; } Int f(int n) { CLEAR(A, 0); CLEAR(C, 0); CLEAR(Next, -1); CLEAR(Prev, -1); int i, j; FOR(i, 0, n) { char first = S[i].front(); char last = S[i].back(); FOR(j, 1, SIZE(S[i]) - 1) { char mid = S[i][j]; if (A[mid] == 0) ++A[mid]; else return 0; } if (first == last) { if (SIZE(S[i]) == 1) ++C[first]; else return 0; } else { if (Next[first] != -1) return 0; if (Prev[last] != -1) return 0; Next[first] = last; Prev[last] = first; } } FOR(i, 0, 256) if (A[i] != 0 && (C[i] != 0 || Next[i] != -1 || Prev[i] != -1)) return 0; Int res = 1; int cnt = 0; CLEAR(B, 0); FOR(i, 0, 256) if (B[i] == 0 && Prev[i] == -1) { if (C[i] != 0 || Next[i] != -1) ++cnt; res *= dfs(i); res %= MOD; } FOR(i, 0, cnt) res = res * (i + 1) % MOD; FOR(i, 0, 256) if (B[i] == 0) return 0; return res; } int SolveTest(int test) { int n; scanf(\"%d\", &n); int i, j; FOR(i, 0, n) { char buf[128]; scanf(\"%s\", buf); int len = strlen(buf); string s; int prev = 0; FOR(j, 1, len + 1) if (j == len || buf[j] != buf[prev]) { s.push_back(buf[prev]); prev = j; } S[i] = s; } printf(\"Case #%d: %d\\ \", test + 1, int(f(n))); return 0; } int main() { freopen(\"b.in\", \"r\", stdin); freopen(\"b.out\", \"w\", stdout); int T, t; char buf[1 << 7]; gets(buf); sscanf(buf, \"%d\", &T); FOR(t, 0, T) { fprintf(stderr, \"Solving %d/%d\\ \", t + 1, T); SolveTest(t); } return 0; }; '", "code2": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Linq; using System.Text; using System.IO; namespace ProblemA { class Program { static void Main(string[] args) { using (var sr = new StreamReader(@\"..\\\\..\\\\B-small-attempt0.in\")) { using (var sw = new StreamWriter(@\"..\\\\..\\\\B-small-attempt0.out\")) { var T = int.Parse(sr.ReadLine()); for (int t = 1; t <= T; t++) { sr.ReadLine(); var s = sr.ReadLine().Split(); var k = Enumerable.Range(0, s.Length).ToArray(); int res = 0; do { //for (int i = 0; i < k.Length; i++) //{ // Console.Write(k[i]); // Console.Write(\" \"); //} //Console.WriteLine(); //continue; var u = new bool[50]; int i; for (i = 0; i < k.Length; i++) { int j; for (j = 0; j < s[k[i]].Length; j++) { if (u[s[k[i]][j] - \\'a\\']) { if (j > 0) { if (s[k[i]][j - 1] != s[k[i]][j]) { break; } } else { if (s[k[i - 1]][s[k[i - 1]].Length - 1] != s[k[i]][j]) { break; } } } u[s[k[i]][j] - \\'a\\'] = true; } if (j < s[k[i]].Length) { break; } } if (i == k.Length) { res++; } } while (NextPermutation(k)); sw.WriteLine(\"Case #{0}: {1}\", t, res); } } } } private static bool NextPermutation(int[] numList) { /* Knuths 1. Find the largest index j such that a[j] < a[j + 1]. If no such index exists, the permutation is the last permutation. 2. Find the largest index l such that a[j] < a[l]. Since j + 1 is such an index, l is well defined and satisfies j < l. 3. Swap a[j] with a[l]. 4. Reverse the sequence from a[j + 1] up to and including the final element a[n]. */ var largestIndex = -1; for (var i = numList.Length - 2; i >= 0; i--) { if (numList[i] < numList[i + 1]) { largestIndex = i; break; } } if (largestIndex < 0) return false; var largestIndex2 = -1; for (var i = numList.Length - 1; i >= 0; i--) { if (numList[largestIndex] < numList[i]) { largestIndex2 = i; break; } } var tmp = numList[largestIndex]; numList[largestIndex] = numList[largestIndex2]; numList[largestIndex2] = tmp; for (int i = largestIndex + 1, j = numList.Length - 1; i < j; i++, j--) { tmp = numList[i]; numList[i] = numList[j]; numList[j] = tmp; } return true; } } } '"}
{"code1": "import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStream; import java.io.PrintStream; import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; import static java.lang.Integer.*; import static java.lang.Character.*; public class B { Scanner scan; public B(Scanner s) { this.scan = s; } String[]A; long brut(char last, boolean[]U,boolean[]L) { long r =0; boolean all=true; for(int i=0;i<A.length;i++){ if(U[i])continue; all=false; boolean[]nl = L.clone(); char lc = \\'#\\'; for(char c:A[i].toCharArray()){ if(nl[c]) { if(lc!=c && !(c==last && c==A[i].charAt(0)))return 0; } nl[c]=true; } U[i]=true; r += brut(A[i].charAt(A[i].length()-1),U, nl); U[i]=false; } if(all)return 1; return r%1000000007; } public String solve() { int n = scan.nextInt(); A = new String[n]; for(int i=0;i<n;i++){ A[i]= \"\";String s =scan.next(); for(int j=0;j<s.length();j++) { if(A[i].length()==0 || A[i].charAt(A[i].length()-1)!=s.charAt(j))A[i]+=s.charAt(j); } System.out.print(A[i] +\" \"); } // System.out.println(); /* long res = brut(\\'#\\', new boolean[n], new boolean[256]); return \"\"+res; */ boolean[]EQ = new boolean[n]; for(int sn=0;sn<n;sn++){ String s = A[sn]; int d=0; boolean[] v = new boolean[256]; for(int i=0;i<s.length();i++){ if(v[s.charAt(i)] && s.charAt(i-1)!=s.charAt(i))return \"0\"; if(!v[s.charAt(i)]) { d++; v[s.charAt(i)]=true; } if(i>0 && s.charAt(i)!=s.charAt(0) && i+1<s.length() && s.charAt(i) !=s.charAt(s.length()-1)){ for(int j=0;j<n;j++){ if(j==sn)continue; for(char c:A[j].toCharArray()) { if(c==s.charAt(i))return \"0\"; } } } } EQ[sn]=d==1; } for(int i=0;i<n;i++)for(int j=0;j<n;j++){ if(i==j)continue; if(EQ[i]||EQ[j])continue; if(A[i].charAt(0)==A[j].charAt(0))return \"0\"; if(A[i].charAt(A[i].length()-1)==A[j].charAt(A[j].length()-1))return \"0\"; } boolean[][]M = new boolean[n][n]; int[]inc = new int[n]; int[]out = new int[n]; int parts =0; for(int i=0;i<n;i++){ if(EQ[i])continue; parts++; for(int j=0;j<n;j++){ if(EQ[j]||i==j)continue; if(A[i].charAt(A[i].length()-1)==A[j].charAt(0)){ M[i][j]=true; inc[j]++; out[i]++; } } } for(int i=0;i<n;i++)if(inc[i]>1||out[i]>1)return \"0\"; int ch=0; boolean cover[]=new boolean[n]; ArrayList<String> seg = new ArrayList<>(); for(int i=0;i<n;i++){ if(EQ[i])continue; if(inc[i]==0 && out[i]==0){ seg.add(A[i].charAt(0)+\"\"+A[i].charAt(A[i].length()-1)); cover[i]=true; } if(inc[i]>0 || out[i]==0)continue; String s =\"\"+A[i].charAt(0); int p =i; cover[p]=true; while(out[p]>0){ for(int j=0;j<n;j++) if(M[p][j]){ p=j; cover[p]=true; } } s+=A[p].charAt(A[p].length()-1); seg.add(s); } for(int i=0;i<n;i++)if(!EQ[i]&&!cover[i])return \"0\"; long res = 1; int free =0; long mod = 1000000007; for(char c = \\'a\\';c<=\\'z\\';c++){ int count=0;boolean att = false; for(int i=0;i<n;i++){ if(EQ[i]){ if(A[i].charAt(0)==c)count++; } } if(count==0)continue; for(int i=0;i<A.length;i++){ String s = A[i]; if(EQ[i])continue; if(s.charAt(0)==c || s.charAt(s.length()-1)==c)att=true; } if(!att && count >0)free++; for(int i=1;i<=count;i++)res = (res*i)%mod; } for(int i=1;i<=seg.size()+free;i++)res = (res*i)%mod; return \"\"+res; } int intLine(){ return parseInt(scan.nextLine()); } public static void main(String[] args) throws Exception{ Locale.setDefault(Locale.US); String cn = B.class.getName(); String sampleName = cn+\"-sample.in\"; String smallName = cn+\"-small-attempt4.in\"; String largeName = cn+\"-large.in\"; String name = largeName; String outName = name.substring(0, name.indexOf(\\'.\\'))+\".out\"; InputStream in = new BufferedInputStream(new FileInputStream(name)); PrintStream out = new PrintStream(new File(outName)); //PrintStream out = System.out; Scanner scan = new Scanner(in); int N = parseInt(scan.nextLine()); for(int c=1;c<=N;c++) { String res = new B(scan).solve(); out.printf(\"Case #%d: %s\\ \",c, res); System.err.println(c + \" done\"); } System.err.println(\"All done\"); } } '", "code2": "//Orz Sevenkplus #include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<ctime> #include<cctype> #include<complex> #include<algorithm> #include<iostream> #include<vector> #include<queue> #include<set> #include<map> #include<bitset> #define un using namespace un std; #define pb push_back #define pf pop_front #define mp make_pair #define c0 first #define c1 second #define sqr(x)((x)*(x)) #define clr(x)memset(x,0,sizeof(x)) #define clr1(x)memset(x,-1,sizeof(x)) #define clr80(x)memset(x,0x80,sizeof(x)) #define clr7F(x)memset(x,0x7F,sizeof(x)) #define ll long long #ifdef __unix__ #define LLD \"%lld\" #else #define LLD \"%I64d\" #endif #define pii pair<int,int> #define pip pair<int,pii> #define vi vector<int> #define vpi vector<pii> #define pq priority_queue template<typename T>inline bool chkmin(T&a,T b){return a>b?a=b,1:0;} template<typename T>inline bool chkmax(T&a,T b){return a<b?a=b,1:0;} #define modadd(a,b,c)(((a)+(b))%(c)) #define modmul(a,b,c)((int)(((ll)(a)*(b))%(c))) #define P 1000000007 #define getint(x){\\\\ char __next__char__;bool __nega__int__=0;\\\\ while(!isdigit(__next__char__=getchar())&&__next__char__!=\\'-\\');\\\\ __next__char__==\\'-\\'?(x=0,__nega__int__=1):(x=__next__char__-48);\\\\ while(isdigit(__next__char__=getchar()))x=x*10+__next__char__-48;\\\\ if(__nega__int__)x=-x;\\\\ } #define getint2(x1,x2){getint(x1);getint(x2);} #define getint3(x1,x2,x3){getint(x1);getint(x2);getint(x3);} #define getint4(x1,x2,x3,x4){getint(x1);getint(x2);getint(x3);getint(x4);} #define getint5(x1,x2,x3,x4,x5){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);} #define getint6(x1,x2,x3,x4,x5,x6){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);getint(x6);} char strr[200][200]; int f[26],b[26],e[26],l[200],s[26]; bool v[26]; bool check(int i){ char*str=strr[i]; clr(v); for(int j=l[i]-1;j--;){ if(str[j]!=str[j+1]){ if(v[str[j+1]-\\'a\\'])return 0; v[str[j+1]-\\'a\\']=1; } } return !v[str[0]-\\'a\\']; } int F[26]; int fa(int x){ int r=F[x],y=r; while(r!=F[r])r=F[r]; while((F[x]=r)!=(x=y))y=F[y]; return r; } int run(){ int n,ans=1; getint(n); clr(f); clr(b); clr(e); clr(s); for(int i=26;i--;)F[i]=i; for(int i=-1;++i!=n;){ clr(v); scanf(\"%s\",strr[i]); l[i]=strlen(strr[i]); char*str=strr[i]; if(str[0]==str[l[i]-1]){ e[str[0]-\\'a\\']++; ans=(ll)ans*e[str[0]-\\'a\\']%P; }else{ int x=fa(str[0]-\\'a\\'); int y=fa(str[l[i]-1]-\\'a\\'); if(x==y)return 0; F[x]=y; if(f[str[0]-\\'a\\']++){ return 0; } if(b[str[l[i]-1]-\\'a\\']++){ return 0; } } for(int j=l[i];j--;)v[str[j]-\\'a\\']=1; for(int j=26;j--;)s[j]+=v[j]; } for(int i=-1;++i!=n;){ char*str=strr[i]; if(!check(i)){ return 0; } for(int j=l[i];j--;) if(str[j]!=str[l[i]-1]&&str[j]!=str[0]){ if(s[str[j]-\\'a\\']>1)return 0; } } int q=0; for(int i=26;i--;){ if((e[i]||b[i])&&F[i]==i)q++; } while(q){ ans=(ll)ans*q%P; q--; } return ans; } int main(){ int T; getint(T); for(int t=1;t<=T;t++){ printf(\"Case #%d: %d\\ \",t,run()); } return 0; } '"}
{"code1": "def withoutDuplication(s): res = [] prev = -1 for c in s: i = ord(c) - ord(\\'a\\') if i != prev: res.append(i) prev = i return res mod = 1000000007 def fact(n): if n <= 1: return 1 return n*fact(n-1)%mod def solve(strs): n = 26 inE, outE, midE, badE = [0]*n, [0]*n, [0]*n, [0]*n g = [-1]*n for s in strs: letters = withoutDuplication(s) if len(letters) == 1: midE[letters[0]] += 1 else: outE[letters[0]] += 1 inE[letters[-1]] += 1 g[letters[0]] = letters[-1] for c in letters[1:-1]: badE[c] += 1 # print inE[:4], outE[:4], midE[:4], badE[:4], g[:4] for i in xrange(n): if badE[i] > 0 and inE[i] + outE[i] + midE[i] + badE[i] > 1: return 0 if inE[i] > 1 or outE[i] > 1: return 0 seen, nc = [False]*n, 0 for i in xrange(n): if seen[i] or inE[i] != 0: continue if outE[i] + midE[i] > 0: nc += 1 t = i while t != -1: seen[t] = True t = g[t] if len(filter(None, seen)) < n: return 0 #print nc res = fact(nc) for i in xrange(26): res *= fact(midE[i]) return res%mod T = int(raw_input()) for z in xrange(T): n = int(raw_input()) s = raw_input().strip().split(\\' \\') print \"Case #%d: %s\" % (z+1, solve(s))'", "code2": "#include <cstdlib> #include <cctype> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <vector> #include <string> #include <iostream> #include <sstream> #include <map> #include <set> #include <queue> #include <functional> using namespace std; typedef long long int64; #define PB push_back #define MP make_pair #define debug(x) cout<<(#x)<<\": \"<<(x)<<endl #define REP(i,n) for(int i=0;i<(n);++i) #define FOR(i,l,h) for(int i=(l);i<=(h);++i) #define FORD(i,h,l) for(int i=(h);i>=(l);--i) #define MOD 1000000007 inline int ADD(int a, int b) { a+=b; if (a>=MOD) a-=MOD; return (int)a; } inline void ADDTO(int &a, int b) { a+=b; if (a>=MOD) a-=MOD; } inline void SUBTO(int &a, int b) { a-=b; if (a<0) a+=MOD; } inline int MUL(int a, int b) { return (int)((int64)a*b%MOD); } int loop[30], indeg[30], oudeg[30], e[30][30], vis[30]; int fact[110], ans; void addEdge(char a, char b) { int u = a - \\'a\\', v = b - \\'a\\'; ++oudeg[u]; ++indeg[v]; e[u][v] = 1; } void dfs(int u) { vis[u] = 1; ans = MUL(ans, fact[loop[u]]); if (oudeg[u] > 0) { REP(v, 26) if (e[u][v] == 1) dfs(v); } } int main() { int tN; cin >> tN; fact[0] = 1; FOR(i, 1, 100) fact[i] = MUL(i, fact[i-1]); FOR(cN, 1, tN) { memset(loop, 0, sizeof(loop)); memset(indeg, 0, sizeof(indeg)); memset(oudeg, 0, sizeof(oudeg)); memset(e, 0, sizeof(e)); memset(vis, 0, sizeof(vis)); int n; cin >> n; REP(i, n) { string s; cin >> s; bool same = 1; REP(i, s.size()) { if (s[i] != s[0]) same = 0; if (i && s[i] != s[i-1]) addEdge(s[i-1], s[i]); } if (same) ++loop[s[0] - \\'a\\']; } bool nosol = 0; REP(i, 26) if (indeg[i] > 1 || oudeg[i] > 1) nosol = 1; if (!nosol) { ans = 1; int ncc = 0; REP(i, 26) if (!vis[i] && indeg[i] == 0) { if (oudeg[i] > 0 || loop[i] > 0) ++ncc; dfs(i); } ans = MUL(ans, fact[ncc]); REP(i, 26) if (!vis[i]) nosol = 1; } printf(\"Case #%d: \", cN); if (nosol) puts(\"0\"); else printf(\"%d\\ \", ans); } } '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; namespace CodeJam { internal class TestCase { public string[] Cars; } internal class Pair { public char First { get; set; } public char Last { get; set; } } internal class Program { private const string testFileName = \"B-large\"; private const int Base = 1000000007; public static IEnumerable<TestCase> ParseCases(TextReader reader) { var testCaseCount = int.Parse(reader.ReadLine()); for (var i = 0; i < testCaseCount; i++) { var carCount = int.Parse(reader.ReadLine()); var cars = reader.ReadLine().Split(); yield return new TestCase { Cars = cars }; } } private static long Solve(TestCase testCase) { // 3 types of cars // single letters: aaa // two letters: aabb // multiple letters aabcddd // simplify consecutive letters var withoutRuns = testCase.Cars.Select(RemoveConsecutive).ToArray(); var singleLetters = withoutRuns.Where(c => c.Length == 1).Select(c => c[0]).ToArray(); var hiddenLetters = withoutRuns.Where(c => c.Length > 2).SelectMany(c => c.Substring(1, c.Length - 2)).Distinct().ToArray(); var pairs = withoutRuns.Where(c => c.Length > 1).Select(c => new Pair { First = c[0], Last = c[c.Length - 1] }).ToArray(); // eliminate case 3 now if (pairs.Any(p => hiddenLetters.Contains(p.First) || hiddenLetters.Contains(p.Last)) || singleLetters.Any(hiddenLetters.Contains)) return 0; // we know just have to find orderings for pairs and single letters. // check that all the pairs can be ordered successfully if (pairs.Select(p => p.First).Distinct().Count() != pairs.Count() || pairs.Select(p => p.Last).Distinct().Count() != pairs.Count()) return 0; //check the groups that have an order imposed on them by the pairs var sortedPairs = GetFixedChains(pairs); if (sortedPairs == null) return 0; var singleLetterCounts = singleLetters.GroupBy(c => c, (key, values) => Tuple.Create(key, values.Count())); var lettersInChains = sortedPairs.SelectMany(p => p).SelectMany(p => new[] { p.First, p.Last }).Distinct(); var independentSingleLetters = singleLetters.Except(lettersInChains).ToArray(); // single letters can be in any order relative to each other long combinations = 1; foreach (var pair in singleLetterCounts) { combinations *= Factorial(pair.Item2); combinations %= Base; } // chains can be in any order relative to each other, and to the independent letters var independentBlockCount = independentSingleLetters.Count() + sortedPairs.Length; combinations *= Factorial(independentBlockCount); combinations %= Base; return combinations; } private static long Factorial(int x) { long fact = 1; while (x > 1) { fact *= x; fact %= Base; x--; } return fact; } private static Pair[][] GetFixedChains(Pair[] pairs) { var remainingPairs = pairs.ToList(); var sorted = new List<Pair[]>(); while (remainingPairs.Count > 0) { var chain = new List<Pair>(); var current = remainingPairs[0]; remainingPairs.RemoveAt(0); chain.Add(current); int index; var first = current; while ((index = remainingPairs.FindIndex(p => p.Last == first.First)) >= 0) { first = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Insert(0, first); } var last = current; while ((index = remainingPairs.FindIndex(p => p.First == last.Last)) >= 0) { last = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Add(last); } if (last.Last == first.First) return null; sorted.Add(chain.ToArray()); } return sorted.ToArray(); } private static string RemoveConsecutive(string arg) { var builder = new StringBuilder(arg.Length); char current = \\'\\\\0\\'; foreach (var c in arg) { if (c != current) { builder.Append(c); current = c; } } return builder.ToString(); } private static void Main(string[] args) { TestCase[] cases; using (var reader = new StreamReader(testFileName + \".in\")) using (var writer = new StreamWriter(testFileName + \".out\")) { cases = ParseCases(reader).ToArray(); for (int caseIndex = 0; caseIndex < cases.Length; caseIndex++) { var testCase = cases[caseIndex]; var solution = Solve(testCase); writer.WriteLine(\"Case #{0}: {1}\", caseIndex + 1, solution); } } } } }'", "code2": "#include <stdio.h> #include <stdlib.h> #include <string.h> #define M 1000000007LL //char *train[10]; int N; int count; int embedded[26]; int oneletter[26]; int endswith[26]; int startswith[26]; int impossible=0; int used; int segment; char *destutter(char *s) { static char buf2[200]; char *d=buf2; char last=0; while (*s) { if (*s!=last) last=*d++ = *s; s++; } *d=0; return buf2; } void readtrains(void) { int i,len,j; static char buff[200]; char *b; impossible=0; scanf(\"%d\",&N); for (i=0;i<26;i++) { embedded[i]=0; oneletter[i]=0; endswith[i]=-1; startswith[i]=-1; } for (i=0;i<N;i++) { scanf(\"%s\",buff); b=destutter(buff); len=strlen(b); if (len==1) { oneletter[*b-\\'a\\']++; continue; } if (startswith[*b-\\'a\\']>=0) impossible++; if (endswith[b[len-1]-\\'a\\']>=0) impossible++; startswith[*b-\\'a\\']=b[len-1]-\\'a\\'; endswith[b[len-1]-\\'a\\']=*b-\\'a\\'; for (j=1;j<len-1;j++) embedded[b[j]-\\'a\\']++; } } int modtimes(int a, int b) { return (int)((1LL*a*b) % M); } int factorial(int n) { int f=1; int i; if (n<=1) return 1; for (i=2;i<=n;i++) f=modtimes(f,i); return f; } void countonlyi(int i) { segment++; //printf(\"countonly %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); } void countendi(int i) { segment++; //printf(\"countend %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! while (1) { if ((1<<i) & used) {impossible++;return;} used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); i=endswith[i]; if (i<0) break; } } void countstarti(int i) { int used2=1<<i; //printf(\" Cs %c\\ \",i+\\'a\\'); while (startswith[i]>=0) { i=startswith[i]; //printf(\" cs %c\\ \",i+\\'a\\'); if (used2 & (1<<i)) { //printf(\"imp\\ \"); impossible++;return; } used2|=1<<i; } countendi(i); } void counttrains(void) { int i; count=1; used=0; segment=0; for (i=0;i<26;i++) { if (impossible || embedded[i]>1 || embedded[i] && (startswith[i]>=0 || endswith[i]>=0)) { printf(\"0\\ \"); //impossible return; } } i=0; while (i<26 && !impossible) { if (startswith[i]>=0 && !((1<<i) & used)) countstarti(i); if (endswith[i]>=0 && !((1<<i) & used)) countendi(i); if (oneletter[i]>0 && !((1<<i) & used)) countonlyi(i); i++; } if (impossible) printf(\"0\\ \"); else printf(\"%d\\ \",count); } void dump(void) { int i; printf(\"\\ \"); for (i=0;i<26;i++) { if (startswith[i]<0 && endswith[i]<0 && embedded[i]==0 && oneletter[i]==0) continue; printf(\" %c : ->%c %c<- em=%d 1L=%d\\ \",i+\\'a\\',startswith[i]+\\'a\\',endswith[i]+\\'a\\',embedded[i],oneletter[i]); } } int main(int argc, char **argv) { int tc,i; scanf(\"%d\",&tc); for (i=1;i<=tc;i++) { printf(\"Case #%d: \",i); readtrains(); //dump(); counttrains(); } return 0; } '"}
{"code1": "// uses http://introcs.cs.princeton.edu/java/stdlib/StdIn.java public class Train { static final int MOD = 1_000_000_007; public static long calc(String[] cars) { long result = 1; int n = cars.length; for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) { //System.out.println(java.util.Arrays.toString(cars)); int solocount = 0; int start = -1; int mid = -1; int end = -1; int solo = -1; for (int i=0; i<n; i++) { if (cars[i] == null) { } else if (cars[i].matches(\"\"+ch+\\'+\\')) { solocount++; result *= solocount; result %= MOD; cars[i] = null; solo = i; } else if (cars[i].matches(ch+\"+[^\"+ch+\"]+\")) { if (start != -1) return 0; start = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+\")) { if (end != -1) return 0; end = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+[^\"+ch+\"]+\")) { if (mid != -1) return 0; mid = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\")) { } else return 0; } //System.out.println(ch+\" \"+solocount+\" \"+start+\" \"+solo+\" \"+end+\" \"+result); if (mid == -1 && solocount == 0 && start == -1 && end == -1) continue; if (mid != -1 && (solocount > 0 || start != -1 || end != -1)) return 0; if (mid != -1) continue; String repl = \"\"; if (end != -1) {repl += cars[end]; cars[end] = null;} if (solo != -1) repl += ch; if (start != -1) {repl += cars[start]; cars[start] = null;} if (start != -1) {cars[start] = repl;} else if (solo != -1) {cars[solo] = repl;} else cars[end] = repl; } int left = 0; for (String s : cars) if (s != null) { left ++; result *= left; result %= MOD; } return result; } public static void main(String[] args) { int q = StdIn.readInt(); for (int j=1; j<=q; j++) { int n = StdIn.readInt(); String[] cars = new String[n]; { for (int i=0; i<n; i++) cars[i] = StdIn.readString(); } System.out.printf(\"Case #%d: %d\\ \", j, calc(cars)); } } } '", "code2": "import static java.lang.Math.*; import java.io.*; import java.math.*; import java.util.*; public class ProblemBLarge { static class Car { String s; LinkedHashMap<Character, Long> numAddedSameCharCars = new LinkedHashMap<Character, Long>(); char getFirst() { return s.charAt(0); } char getLast() { return s.charAt(s.length() - 1); } void addAllSameChars(Car car) { for (Map.Entry<Character, Long> entry : car.numAddedSameCharCars.entrySet()) { Character key = entry.getKey(); Long value = numAddedSameCharCars.get(key); if (value == null) value = 0L; value += entry.getValue(); numAddedSameCharCars.put(key, value); } } @Override public String toString() { return \"\"+s+\" (\"+numAddedSameCharCars+\")\"; } } public class Case { LinkedHashSet<Car> cars = new LinkedHashSet<Car>(); LinkedHashSet<Car> carsToCheck = new LinkedHashSet<Car>(); public void solve(int caseIndex) { for (Car car : cars) { if (isSameCharCar(car)) { car.numAddedSameCharCars.put(car.s.charAt(0), 1L); } } // System.out.println(\"Cars: \"+cars); carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); // LinkedHashSet<Car> carsWithSameChar = new LinkedHashSet<Car>(); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); if (isSameCharCar(car)) { for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } } carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } BigInteger result; if (!isValid()) { result = BigInteger.valueOf(0); } else { long mod = 1000000007L; result = BigInteger.valueOf(1); for (long i = 1; i <= cars.size(); i++) { result = result.multiply(BigInteger.valueOf(i)); } for (Car car : cars) { for (Long sameChars : car.numAddedSameCharCars.values()) { long a = 1; for (long i = 1; i <= sameChars; i++) { a *= i; a %= mod; } result = result.multiply(BigInteger.valueOf(a)); } } result = result.mod(BigInteger.valueOf(mod)); } // long result; // if (!isValid()) { // result = 0; // } // else { // long mod = 1000000007L; // // result = 1; // for (long i = 1; i <= cars.size(); i++) { // result *= i; // result %= mod; // } // // for (Car car : cars) { // for (Long sameChars : car.numAddedSameCharCars.values()) { // long a = 1; // for (long i = 1; i <= sameChars; i++) { // a *= i; // a %= mod; // } // result *= a; // result %= mod; // } // } // } println(\"Case #\" + (caseIndex + 1) + \": \" + result); } void combineCars(Car car1, Car car2) { Car car = new Car(); car.s = car1.s + car2.s; car.addAllSameChars(car1); car.addAllSameChars(car2); // car.numAddedSameCharCars = car1.numAddedSameCharCars + car2.numAddedSameCharCars; cars.add(car); carsToCheck.add(car); cars.remove(car1); carsToCheck.remove(car1); cars.remove(car2); carsToCheck.remove(car2); // System.out.println(\"Cars: \"+cars); } boolean isSameCharCar(Car car) { String s = car.s; for (int k = 0; k < s.length(); k++) { if (s.charAt(k) != s.charAt(0)) { return false; } } return true; } boolean isValid() { LinkedHashSet<Character> processed = new LinkedHashSet<>(); Character last = null; for (Car car : cars) { String s = car.s; for (int k = 0; k < s.length(); k++) { char ch = s.charAt(k); // System.out.println(\"Current: \"+ch); if (last != null && last.charValue() == ch) { // System.out.println(\"Last: \"+last+\", processed: \"+processed); } else { if (processed.contains(ch)) return false; processed.add(ch); } last = ch; } } return true; } long factorial(long p) { long result = 1; for (long i = 2; i <= p; i++) result *= i; return result; } } public void run() throws Exception { BufferedReader r = new BufferedReader(new FileReader(\"input.txt\")); int numCases = new InputParser(r.readLine()).readInt(); for (int caseIndex = 0; caseIndex < numCases; caseIndex++) { Case c = new Case(); InputParser p = new InputParser(r.readLine()); int numCars = p.readInt(); p = new InputParser(r.readLine()); for (int i = 0; i < numCars; i++) { Car car = new Car(); car.s = p.readToken(); c.cars.add(car); } c.solve(caseIndex); } r.close(); } public static void main(String[] args) throws Exception { fileWriter = new PrintWriter(new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"output.txt\")))); new ProblemBLarge().run(); fileWriter.close(); } public static class InputParser { String text; int pos; public InputParser(String text) { this.text = text; } public void skipSpaces() { while (pos < text.length()) { if (text.charAt(pos) != \\' \\') break; pos++; } } public String readUntil(char expectedChar) { StringBuilder b = new StringBuilder(); while (pos < text.length()) { char ch = text.charAt(pos); if (ch == expectedChar) break; b.append(ch); pos++; } return b.toString(); } public String readToken() { skipSpaces(); return readUntil(\\' \\'); } public int readInt() { return Integer.parseInt(readToken()); } public long readLong() { return Long.parseLong(readToken()); } public double readDouble() { return Double.parseDouble(readToken()); } public char readChar() { char ch = text.charAt(pos); pos++; return ch; } public void readExpectedString(String s) { for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (readChar() != ch) throw new RuntimeException(\"Expected: \"+ch); } } } public static PrintWriter fileWriter; public static void print(String text) { fileWriter.print(text); System.out.print(text); } public static void println(String text) { fileWriter.println(text); System.out.println(text); } public static <Key, Value> void addToMultiMapArrayList(Key key, Value value, Map<Key, ArrayList<Value>> map) { ArrayList<Value> list = map.get(key); if (list == null) { list = new ArrayList<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> void addToMultiMapLinkedHashSet(Key key, Value value, Map<Key, LinkedHashSet<Value>> map) { LinkedHashSet<Value> list = map.get(key); if (list == null) { list = new LinkedHashSet<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> ArrayList<Value> getMultiMapValues(Map<Key, Collection<Value>> map) { ArrayList<Value> result = new ArrayList<Value>(); for (Collection<Value> list : map.values()) { result.addAll(list); } return result; } // binarySearch(, , 0.000000001, new Function<Double, Integer>() { // public Integer evaluate(Double key) { // return ; // } // }); public static double binarySearch(double low, double high, double precision, Function<Double, Integer> f) { if (high < low) throw new RuntimeException(\"High (\"+high+\") cannot be smaller than low (\"+low+\")\"); { int lowValue = f.evaluate(low); if (lowValue == 0) return low; if (lowValue > 0) throw new RuntimeException(\"Unsuitable low: \"+low); } { int highValue = f.evaluate(high); if (highValue == 0) return high; if (highValue < 0) throw new RuntimeException(\"Unsuitable high: \"+high); } while (true) { double mid = (low + high) * 0.5; if (abs(high - low) < precision) { return mid; } int c = f.evaluate(mid); if (c < 0) low = mid; else if (c > 0) high = mid; else return mid; } } public static <T> LinkedHashSet<T> intersection(Set<T> s1, Set<T> s2) { if (s2.size() < s1.size()) { Set<T> temp = s1; s1 = s2; s2 = temp; } LinkedHashSet<T> result = new LinkedHashSet<T>(); for (T o : s1) { if (s2.contains(o)) result.add(o); } return result; } public static interface Function<Key, Value> { public Value evaluate(Key key); } public static class Int2 { int x, y; public Int2(int x, int y) { this.x = x; this.y = y; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Int2 other = (Int2) obj; if (x != other.x) return false; if (y != other.y) return false; return true; } @Override public String toString() { return \"(\"+x+\",\"+y+\")\"; } } } '"}
{"code1": "#include <iostream> #include <fstream> #include <string> #include <algorithm> #include <cstdlib> #include <cstring> #include <set> #include <map> #include <vector> #include <stack> #include <queue> #include <deque> #include <iomanip> #include <cassert> typedef long long ll; typedef unsigned long long ull; using namespace std; bool is_aaa(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] != c) return false; } return true; } bool is_aax(const string& s, char c) { return s[0] == c; } bool is_yaa(const string& s, char c) { return s[(int)s.size() - 1] == c; } bool is_uav(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] == c) return true; } return false; } int fragment_count(const string& s, char c) { int result = 0; int n = (int)s.size(); int i = 0; while (i < n) { if (s[i] != c) i++; else { int j = i; while (j + 1 < n && s[j + 1] == c) j++; result++; i = j + 1; } } return result; } const int MAXN = 109; int N; string s[MAXN]; vector<string> pieces; const ll MOD = 1000000007; ll fact[MAXN]; ll solve(void) { pieces.clear(); for (int i = 0; i < N; i++) pieces.push_back(s[i]); ll result = 1; for (char c = \\'a\\'; c <= \\'z\\'; c++) { vector<string> aaa; vector<string> aax; vector<string> yaa; vector<string> uav; vector<string> other; for (int i = 0; i < pieces.size(); i++) { if (is_aaa(pieces[i], c)) aaa.push_back(pieces[i]); else if (is_aax(pieces[i], c)) aax.push_back(pieces[i]); else if (is_yaa(pieces[i], c)) yaa.push_back(pieces[i]); else if (is_uav(pieces[i], c)) uav.push_back(pieces[i]); else other.push_back(pieces[i]); } if (uav.size() != 0) { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0 && uav.size()==1 && fragment_count(uav[0], c)==1) { ; } else return 0LL; } else { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0) { ; // no constraints at all } else { if (yaa.size() <= 1 && aax.size() <= 1) { if (yaa.size() == 1) { if (fragment_count(yaa[0], c) > 1) return 0LL; } if (aax.size() == 1) { if (fragment_count(aax[0], c) > 1) return 0LL; } result *= fact[aaa.size()]; result %= MOD; pieces = other; string new_piece; if (yaa.size() != 0) new_piece += yaa[0]; for (int i = 0; i < aaa.size(); i++) new_piece += aaa[i]; if (aax.size() != 0) new_piece += aax[0]; pieces.push_back(new_piece); } else return 0LL; } } } result *= fact[pieces.size()]; result %= MOD; return result; } void solve_B(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; fact[0] = 1LL; for (int i = 1; i < MAXN; i++) fact[i] = (fact[i - 1] * i) % MOD; for (int tt = 1; tt <= T; tt++) { for (int i = 0; i < MAXN; i++) s[i] = \"\"; in >> N; for (int i = 0; i < N; i++) in >> s[i]; ll temp = solve(); out << \"Case #\" << tt << \": \"; out << temp; out << \\'\\ \\'; } in.close(); out.close(); } int main() { //solve_A(); solve_B(); //solve_C(); return 0; } void solve_(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; for (int tt = 1; tt <= T; tt++) { out << \"Case #\" << tt << \": \"; } in.close(); out.close(); }'", "code2": "import java.util.HashSet; import java.util.Scanner; import java.util.Set; public class B { static final long BASE = 1000000007; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int cases = sc.nextInt(); long[] factorial = new long[101]; factorial[0] = 1; for (int i = 1; i < 101; i++) { factorial[i] = (factorial[i - 1] * i) % BASE; } for (int caseNum = 1; caseNum <= cases; caseNum++) { int N = sc.nextInt(); String[] cars = new String[N]; Set<Character> interior = new HashSet<Character>(); int[] singleLetterStrs = new int[26]; int[] starts = new int[26]; int[] ends = new int[26]; char[] next = new char[26]; boolean possible = true; for (int i = 0; i < N; i++) { cars[i] = sc.next(); int firstChar = cars[i].charAt(0) - \\'a\\'; char lastChar = cars[i].charAt(cars[i].length() - 1); if (isSingleLetter(cars[i])) { int index = firstChar; singleLetterStrs[index]++; } else { for (Character ch : getInteriorChars(cars[i])) { if (interior.contains(ch)) { possible = false; break; } interior.add(ch); } starts[firstChar]++; ends[lastChar - \\'a\\']++; next[firstChar] = lastChar; } } int numGroups = 0; for (int i = 0; i < 26; i++) { if (!possible) { break; } char ch = (char) (\\'a\\' + i); if (interior.contains(ch) && (singleLetterStrs[i] + starts[i] + ends[i] > 0)) { possible = false; } if (starts[i] > 1 || ends[i] > 1) { possible = false; } if (singleLetterStrs[i] > 0 && starts[i] == 0 && ends[i] == 0) { numGroups++; } else if (starts[i] == 1 && ends[i] == 0) { numGroups++; } } possible = possible && !hasCycles(next); System.out.print(\"Case #\" + caseNum + \": \"); if (!possible) { System.out.println(0); continue; } long ways = 1; for (int i = 0; i < 26; i++) { ways = (ways * factorial[singleLetterStrs[i]]) % BASE; } ways = (ways * factorial[numGroups]) % BASE; System.out.println(ways); } } private static boolean hasCycles(char[] next) { for (int i = 0; i < 26; i++) { if (next[i] == 0) { continue; } char start = (char) (\\'a\\' + i); int currIndex = i; while (next[currIndex] != 0 && next[currIndex] != start) { currIndex = next[currIndex] - \\'a\\'; } if (next[currIndex] == start) { return true; } } return false; } private static Set<Character> getInteriorChars(String str) { Set<Character> chars = new HashSet<Character>(); if (isSingleLetter(str)) { return chars; } int startIndex = 0; while (str.charAt(startIndex + 1) == str.charAt(0)) { startIndex++; } int endIndex = str.length() - 1; while (str.charAt(endIndex - 1) == str.charAt(str.length() - 1)) { endIndex--; } for (int i = startIndex + 1; i < endIndex; i++) { chars.add(str.charAt(i)); } return chars; } private static boolean isSingleLetter(String str) { char ch = str.charAt(0); for (int i = 1; i < str.length(); i++) { if (str.charAt(i) != ch) { return false; } } return true; } } '"}
{"code1": "#include <stdio.h> #include <stdlib.h> #include <math.h> #include <ctype.h> #include <string.h> int TC, T; int Cars; char Car[120][120]; char Visited[130]; int Stack[120]; int Used[120]; int i, x, y, L, Ans; char Last; int DFS(int Level){ if (Level==Cars){ int i, x; Last = Car[Stack[0]][0]; memset(Visited, 0, sizeof(Visited)); Visited[Last] = 1; for (i=0; i<Cars; i++){ L = strlen(Car[Stack[i]]); for (x=0; x<L; x++){ if (Car[Stack[i]][x]==Last) continue; if (Visited[Car[Stack[i]][x]]) return ; Visited[Car[Stack[i]][x]] = 1; Last = Car[Stack[i]][x]; } } Ans++; return ; } int i; for (i=0; i<Cars; i++) if (!Used[i]){ Used[i] = 1; Stack[Level] = i; DFS(Level+1); Used[i] = 0; } } int main(){ freopen(\"B-small-attempt0.in\", \"r\", stdin); freopen(\"B-small-attempt0.out\", \"w\", stdout); scanf(\"%d\", &TC); for (T=1; T<=TC; T++){ printf(\"Case #%d: \", T); scanf(\"%d\", &Cars); for (i=0; i<Cars; i++) scanf(\"%s\", Car[i]); Ans = 0; DFS(0); printf(\"%d\\ \", Ans); } return 0; } '", "code2": "#!/usr/bin/pypy import itertools,math,sys def simple_solve(N,S): S = sorted(S) cnt = 0 for perm in itertools.permutations(S): z = \"\".join(perm) chars = [False for _ in range(26)] last = \\'\\' for c in z: if last==c: continue last = c if chars[ord(c)-ord(\\'a\\')]: break chars[ord(c)-ord(\\'a\\')] = True else: cnt += 1 return cnt def true_solve(N,S): rz = {} for c in range(26): char = chr(c+ord(\\'a\\')) cnt_inside = cnt_left = cnt_right = cnt_full = 0 left_char = right_char = \"\" for z in S: h = False last = \"\" for x in z: if x==char and h and last != char: return 0 if x==char: h = True last = x if z[0] == z[-1] == char: cnt_full += 1 elif z[0] == char: cnt_left += 1 right_char = z[-1] elif z[-1] == char: cnt_right += 1 left_char = z[0] elif h: cnt_inside += 1 if cnt_inside > 1 or cnt_inside > 0 and cnt_left+cnt_right+cnt_full>0 or cnt_left>1 or cnt_right>1: return 0 if cnt_inside == 0 and cnt_left+cnt_right+cnt_full>0: rz[char] = ((left_char,right_char,math.factorial(cnt_full))) blocks = 0 bb = 1 while rz: for c,v in rz.items(): if v[0]==\"\": break else: return 0 del rz[c] bb *= v[2] while v[1] != \"\": if v[1] not in rz: return 0 v = rz.pop(v[1]) bb *= v[2] blocks += 1 return math.factorial(blocks)*bb%1000000007 def solve(): N = int(raw_input()) S = raw_input().strip().split() val1 = true_solve(N,S) #val2 = simple_solve(N,S) #if val1 != val2: # print \"Bad\" # print N,S # print val1,val2 # sys.exit(1) return val1 T = int(raw_input()) for t in range(1,T+1): print \"Case #%d:\"%t,solve() '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Linq; using System.Numerics; using System.Text; using System.Threading.Tasks; namespace GCJ2014R1CB { class Program { /// <summary> /// \\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe6\\x95\\xb0 /// </summary> static int ThreadCount = 1; /// <summary> /// \\xe9\\x80\\xb2\\xe6\\x8d\\x97\\xe3\\x82\\x92\\xe8\\xa1\\xa8\\xe7\\xa4\\xba\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 /// </summary> static bool Verbose = true; static int ProgressInterval = 1; class Solver { public List<string> SolveAll(int threadId, StreamReader sr) { // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ int TestCase = int.Parse(sr.ReadLine()); // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ List<string> outputs = new List<string>(); for (int testCase = 0; testCase < TestCase; testCase++) { // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ int N = int.Parse(sr.ReadLine()); string l = sr.ReadLine(); // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ #region if (testCase % ThreadCount != threadId) { // \\xe3\\x81\\x93\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xae\\xe6\\x8b\\x85\\xe5\\xbd\\x93\\xe3\\x81\\xa7\\xe3\\x81\\xaf\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe3\\x81\\xae\\xe3\\x81\\xa7\\xe8\\xa7\\xa3\\xe3\\x81\\x8b\\xe3\\x81\\xaa\\xe3\\x81\\x84 continue; } if (Verbose) { if (testCase % ProgressInterval == 0) { Console.Error.WriteLine(testCase + \" / \" + TestCase); } } #endregion // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ string output = Solve(testCase, l); // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ outputs.Add(output); } return outputs; } const long Mod = 1000000007; string Solve(int testCase, string l) { if (testCase == -1) { } List<string> ts = l.Split(\\' \\').ToList(); BigInteger ans = 1; for(char c = \\'a\\'; c <= \\'z\\'; c++) { int ct = 0; string ns = \"\"; for(int i = 0; i < ts.Count; i++) { if (ts[i].First() == c && ts[i].Last() == c) { ns += ts[i]; ct++; ans *= ct; ts.RemoveAt(i); i--; } } if (ct > 0) { ts.Add(ns); } } for(;;) { bool f = Update(ts, true); if (f == false) { break; } } for(;;) { bool f = Update(ts, false); if (f == false) { break; } } string all = string.Concat(ts); for(char c = \\'a\\'; c <= \\'z\\'; c++) { int first = all.IndexOf(c); if (first < 0) { continue; } int last = all.LastIndexOf(c); for(int i = first; i < last; i++) { if (all[i] != c) { return \"0\"; } } } for(int i = 1; i <= ts.Count; i++) { ans *= i; } ans %= Mod; return ans.ToString(); } static bool Update(List<string> ts, bool primary) { int N = ts.Count(); for(int i = 0; i < N; i++) { if (primary && ts[i].First() != ts[i].Last()) { continue; } for(int j = 0; j < N; j++) { if (i == j) { continue; } if (ts[i].Last() == ts[j].First()) { ts[i] += ts[j]; ts.RemoveAt(j); return true; } } } return false; } } static void Main(string[] args) { // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\x84\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\x9f\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\xab\\xe5\\xaf\\xbe\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe5\\x87\\xa6\\xe7\\x90\\x86\\xe3\\x82\\x92\\xe8\\xa1\\x8c\\xe3\\x81\\x86\\xe3\\x80\\x82 // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe3\\x82\\xab\\xe3\\x83\\xac\\xe3\\x83\\xb3\\xe3\\x83\\x88\\xe3\\x83\\x87\\xe3\\x82\\xa3\\xe3\\x83\\xac\\xe3\\x82\\xaf\\xe3\\x83\\x88\\xe3\\x83\\xaa\\xe3\\x81\\xae large \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81 // small \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81sample.in \\xe3\\x82\\x92\\xe9\\xa0\\x86\\xe3\\x81\\xab\\xe6\\xa4\\x9c\\xe7\\xb4\\xa2\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 // large \\xe3\\x82\\x84 small \\xe3\\x81\\x8c\\xe8\\xa4\\x87\\xe6\\x95\\xb0\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe5\\x90\\x8d\\xe5\\x89\\x8d\\xe3\\x81\\xa7\\xe3\\x82\\xbd\\xe3\\x83\\xbc\\xe3\\x83\\x88\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe4\\xb8\\x80\\xe7\\x95\\xaa\\xe6\\x9c\\x80\\xe5\\xbe\\x8c\\xe3\\x81\\xae\\xe3\\x82\\x92\\xe4\\xbd\\xbf\\xe3\\x81\\x86\\xe3\\x80\\x82 string inputName = null; if (args.Length > 0) { if (File.Exists(args[0]) == false) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } inputName = args[0]; } if (inputName == null) { List<string> larges = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"large\") && fi.Name.EndsWith(\".in\")) { larges.Add(fi.FullName); } } if (larges.Count > 0) { larges.Sort(); inputName = larges[larges.Count - 1]; } } if (inputName == null) { List<string> smalls = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"small\") && fi.Name.EndsWith(\".in\")) { smalls.Add(fi.FullName); } } if (smalls.Count > 0) { smalls.Sort(); inputName = smalls[smalls.Count - 1]; } } if (inputName == null) { foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.ToLower() == \"sample.in\") { inputName = fi.FullName; break; } } } if (inputName == null) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } // \\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe5\\x85\\x88\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x82\\x92\\xe6\\xb1\\xba\\xe5\\xae\\x9a\\xe3\\x81\\x97\\xe3\\x80\\x81\\xe5\\x90\\x8c\\xe5\\x90\\x8d\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x83\\xaa\\xe3\\x83\\x8d\\xe3\\x83\\xbc\\xe3\\x83\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 string outputName = inputName; if (outputName.EndsWith(\".in\")) { outputName = outputName.Substring(0, outputName.Length - 3); } outputName += \".out\"; if (File.Exists(outputName)) { int rev = 1; while (File.Exists(outputName + \".\" + rev)) { rev++; } File.Move(outputName, outputName + \".\" + rev); } // \\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82ThreadCount == 1 \\xe3\\x81\\xaa\\xe3\\x82\\x89\\xe3\\x80\\x81\\xe7\\x8f\\xbe\\xe5\\x9c\\xa8\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xa7\\xe3\\x80\\x81\\xe3\\x81\\x9d\\xe3\\x82\\x8c\\xe4\\xbb\\xa5\\xe5\\xa4\\x96\\xe3\\x81\\xaa\\xe3\\x82\\x89 Parallel \\xe3\\x81\\xa7\\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 List<string>[] outputs = new List<string>[ThreadCount]; if (ThreadCount == 1) { for (int i = 0; i < ThreadCount; i++) { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } } } else { Parallel.For(0, ThreadCount, i => { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } }); } // \\xe7\\xb5\\x90\\xe6\\x9e\\x9c\\xe3\\x82\\x92\\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82Case # \\xe3\\x81\\xaf\\xe3\\x81\\x93\\xe3\\x81\\x93\\xe3\\x81\\xa7\\xe4\\xbb\\x98\\xe5\\x8a\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 using (StreamWriter sw = new StreamWriter(outputName)) { for (int i = 0; ; i++) { if (outputs[i % ThreadCount].Count > i / ThreadCount) { sw.WriteLine(\"Case #\" + (i + 1) + \": \" + outputs[i % ThreadCount][i / ThreadCount]); } else { break; } } } } } } '", "code2": "#include<stdio.h> #include<stdlib.h> #include<string.h> #define MOD 1000000007LL int t,T,n,N; long long frac[128]; long long C; char s[128][128]; long long ans; char start[128];/*First Letter*/ char end[128];/*Last Letter*/ char blocked[256]; /*Internal characters*/ int first; int tmp; int c; int only_start[256]; int only_end[256]; int loops[256]; int done[256]; int num_frag; char tmp2; char tmp3; int main(){ scanf(\"%d\",&T); frac[0]=1; for(C=1;C<120;C++) frac[C]=(frac[C-1]*C)%MOD; for(t=1;t<=T;t++){ scanf(\"%d\",&N); for(n=1;n<=N;n++){scanf(\"%s\",&s[n][0]);} for(c=0;c<256;c++) { blocked[c]=0; only_start[c]=0; only_end[c]=0; loops[c]=0; } ans=1; for(n=1;n<=N;n++) { tmp=strlen(s[n]); first=1; start[n]=s[n][0]; end[n]=s[n][tmp-1]; for(c=1;c<tmp;c++) { if (s[n][c]!=s[n][c-1]) { if (blocked[s[n][c]]==1) ans=0; if (first==0) { blocked[s[n][c-1]]=1; } first=0; } } if ((start[n]==end[n])&&(first==0)) ans=0; } if (ans==1) { for(n=1;n<=N;n++) { if (blocked[start[n]]==1) ans=0; if (blocked[end[n]]==1) ans=0; } } if (ans==1) { for(n=1;n<=N;n++) { if (start[n]==end[n]) {loops[start[n]]++;} else { only_start[start[n]]++; only_end[end[n]]++; } } for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if (only_start[tmp2]>1) ans=0; if (only_end[tmp2]>1) ans=0; } } if (ans==1) { num_frag=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) num_frag++; if ((only_start[tmp2]==0)&&(only_end[tmp2]==0)&&(loops[tmp2]>0)) num_frag++; ans*=frac[loops[tmp2]]; ans%=MOD; } ans*=frac[num_frag]; ans%=MOD; } /*Detect cycles*/ if (ans!=0) { for(c=0;c<256;c++) done[c]=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) { tmp3=tmp2; do{ for(n=1;n<=N;n++) { if ((start[n]==tmp3)&&(start[n]!=end[n])) break; } done[n]=1; tmp3=end[n]; } while (only_start[tmp3]==1); } } for(n=1;n<=N;n++) { if ((done[n]==0)&&(start[n]!=end[n])) ans=0; } } printf(\"Case #%d: \",t); printf(\"%lld\\ \",ans); } return 0; } '"}
{"code1": "//#pragma comment(linker, \"/STACK:134217728\") #include <iostream> #include <sstream> #include <cstdio> #include <cstdlib> #include <cmath> #include <cctype> #include <cstring> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> #include <numeric> using namespace std; typedef long long Int; typedef pair<int,int> PII; typedef vector<int> VInt; #define FOR(i, a, b) for(i = (a); i < (b); ++i) #define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i) #define CLEAR(a, b) memset(a, b, sizeof(a)) #define SIZE(a) int((a).size()) #define ALL(a) (a).begin(),(a).end() #define PB push_back #define MP make_pair #define MOD 1000000007 string S[256]; int A[256]; int C[256]; int Next[256]; int Prev[256]; int B[256]; Int dfs(int a) { if (a == -1) return 1; B[a] = 1; Int res = 1; int i; FOR(i, 0, C[a]) res = res * (i + 1) % MOD; return res * dfs(Next[a]) % MOD; } Int f(int n) { CLEAR(A, 0); CLEAR(C, 0); CLEAR(Next, -1); CLEAR(Prev, -1); int i, j; FOR(i, 0, n) { char first = S[i].front(); char last = S[i].back(); FOR(j, 1, SIZE(S[i]) - 1) { char mid = S[i][j]; if (A[mid] == 0) ++A[mid]; else return 0; } if (first == last) { if (SIZE(S[i]) == 1) ++C[first]; else return 0; } else { if (Next[first] != -1) return 0; if (Prev[last] != -1) return 0; Next[first] = last; Prev[last] = first; } } FOR(i, 0, 256) if (A[i] != 0 && (C[i] != 0 || Next[i] != -1 || Prev[i] != -1)) return 0; Int res = 1; int cnt = 0; CLEAR(B, 0); FOR(i, 0, 256) if (B[i] == 0 && Prev[i] == -1) { if (C[i] != 0 || Next[i] != -1) ++cnt; res *= dfs(i); res %= MOD; } FOR(i, 0, cnt) res = res * (i + 1) % MOD; FOR(i, 0, 256) if (B[i] == 0) return 0; return res; } int SolveTest(int test) { int n; scanf(\"%d\", &n); int i, j; FOR(i, 0, n) { char buf[128]; scanf(\"%s\", buf); int len = strlen(buf); string s; int prev = 0; FOR(j, 1, len + 1) if (j == len || buf[j] != buf[prev]) { s.push_back(buf[prev]); prev = j; } S[i] = s; } printf(\"Case #%d: %d\\ \", test + 1, int(f(n))); return 0; } int main() { freopen(\"b.in\", \"r\", stdin); freopen(\"b.out\", \"w\", stdout); int T, t; char buf[1 << 7]; gets(buf); sscanf(buf, \"%d\", &T); FOR(t, 0, T) { fprintf(stderr, \"Solving %d/%d\\ \", t + 1, T); SolveTest(t); } return 0; }; '", "code2": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Linq; using System.Text; using System.IO; namespace ProblemA { class Program { static void Main(string[] args) { using (var sr = new StreamReader(@\"..\\\\..\\\\B-small-attempt0.in\")) { using (var sw = new StreamWriter(@\"..\\\\..\\\\B-small-attempt0.out\")) { var T = int.Parse(sr.ReadLine()); for (int t = 1; t <= T; t++) { sr.ReadLine(); var s = sr.ReadLine().Split(); var k = Enumerable.Range(0, s.Length).ToArray(); int res = 0; do { //for (int i = 0; i < k.Length; i++) //{ // Console.Write(k[i]); // Console.Write(\" \"); //} //Console.WriteLine(); //continue; var u = new bool[50]; int i; for (i = 0; i < k.Length; i++) { int j; for (j = 0; j < s[k[i]].Length; j++) { if (u[s[k[i]][j] - \\'a\\']) { if (j > 0) { if (s[k[i]][j - 1] != s[k[i]][j]) { break; } } else { if (s[k[i - 1]][s[k[i - 1]].Length - 1] != s[k[i]][j]) { break; } } } u[s[k[i]][j] - \\'a\\'] = true; } if (j < s[k[i]].Length) { break; } } if (i == k.Length) { res++; } } while (NextPermutation(k)); sw.WriteLine(\"Case #{0}: {1}\", t, res); } } } } private static bool NextPermutation(int[] numList) { /* Knuths 1. Find the largest index j such that a[j] < a[j + 1]. If no such index exists, the permutation is the last permutation. 2. Find the largest index l such that a[j] < a[l]. Since j + 1 is such an index, l is well defined and satisfies j < l. 3. Swap a[j] with a[l]. 4. Reverse the sequence from a[j + 1] up to and including the final element a[n]. */ var largestIndex = -1; for (var i = numList.Length - 2; i >= 0; i--) { if (numList[i] < numList[i + 1]) { largestIndex = i; break; } } if (largestIndex < 0) return false; var largestIndex2 = -1; for (var i = numList.Length - 1; i >= 0; i--) { if (numList[largestIndex] < numList[i]) { largestIndex2 = i; break; } } var tmp = numList[largestIndex]; numList[largestIndex] = numList[largestIndex2]; numList[largestIndex2] = tmp; for (int i = largestIndex + 1, j = numList.Length - 1; i < j; i++, j--) { tmp = numList[i]; numList[i] = numList[j]; numList[j] = tmp; } return true; } } } '"}
{"code1": "import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStream; import java.io.PrintStream; import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; import static java.lang.Integer.*; import static java.lang.Character.*; public class B { Scanner scan; public B(Scanner s) { this.scan = s; } String[]A; long brut(char last, boolean[]U,boolean[]L) { long r =0; boolean all=true; for(int i=0;i<A.length;i++){ if(U[i])continue; all=false; boolean[]nl = L.clone(); char lc = \\'#\\'; for(char c:A[i].toCharArray()){ if(nl[c]) { if(lc!=c && !(c==last && c==A[i].charAt(0)))return 0; } nl[c]=true; } U[i]=true; r += brut(A[i].charAt(A[i].length()-1),U, nl); U[i]=false; } if(all)return 1; return r%1000000007; } public String solve() { int n = scan.nextInt(); A = new String[n]; for(int i=0;i<n;i++){ A[i]= \"\";String s =scan.next(); for(int j=0;j<s.length();j++) { if(A[i].length()==0 || A[i].charAt(A[i].length()-1)!=s.charAt(j))A[i]+=s.charAt(j); } System.out.print(A[i] +\" \"); } // System.out.println(); /* long res = brut(\\'#\\', new boolean[n], new boolean[256]); return \"\"+res; */ boolean[]EQ = new boolean[n]; for(int sn=0;sn<n;sn++){ String s = A[sn]; int d=0; boolean[] v = new boolean[256]; for(int i=0;i<s.length();i++){ if(v[s.charAt(i)] && s.charAt(i-1)!=s.charAt(i))return \"0\"; if(!v[s.charAt(i)]) { d++; v[s.charAt(i)]=true; } if(i>0 && s.charAt(i)!=s.charAt(0) && i+1<s.length() && s.charAt(i) !=s.charAt(s.length()-1)){ for(int j=0;j<n;j++){ if(j==sn)continue; for(char c:A[j].toCharArray()) { if(c==s.charAt(i))return \"0\"; } } } } EQ[sn]=d==1; } for(int i=0;i<n;i++)for(int j=0;j<n;j++){ if(i==j)continue; if(EQ[i]||EQ[j])continue; if(A[i].charAt(0)==A[j].charAt(0))return \"0\"; if(A[i].charAt(A[i].length()-1)==A[j].charAt(A[j].length()-1))return \"0\"; } boolean[][]M = new boolean[n][n]; int[]inc = new int[n]; int[]out = new int[n]; int parts =0; for(int i=0;i<n;i++){ if(EQ[i])continue; parts++; for(int j=0;j<n;j++){ if(EQ[j]||i==j)continue; if(A[i].charAt(A[i].length()-1)==A[j].charAt(0)){ M[i][j]=true; inc[j]++; out[i]++; } } } for(int i=0;i<n;i++)if(inc[i]>1||out[i]>1)return \"0\"; int ch=0; boolean cover[]=new boolean[n]; ArrayList<String> seg = new ArrayList<>(); for(int i=0;i<n;i++){ if(EQ[i])continue; if(inc[i]==0 && out[i]==0){ seg.add(A[i].charAt(0)+\"\"+A[i].charAt(A[i].length()-1)); cover[i]=true; } if(inc[i]>0 || out[i]==0)continue; String s =\"\"+A[i].charAt(0); int p =i; cover[p]=true; while(out[p]>0){ for(int j=0;j<n;j++) if(M[p][j]){ p=j; cover[p]=true; } } s+=A[p].charAt(A[p].length()-1); seg.add(s); } for(int i=0;i<n;i++)if(!EQ[i]&&!cover[i])return \"0\"; long res = 1; int free =0; long mod = 1000000007; for(char c = \\'a\\';c<=\\'z\\';c++){ int count=0;boolean att = false; for(int i=0;i<n;i++){ if(EQ[i]){ if(A[i].charAt(0)==c)count++; } } if(count==0)continue; for(int i=0;i<A.length;i++){ String s = A[i]; if(EQ[i])continue; if(s.charAt(0)==c || s.charAt(s.length()-1)==c)att=true; } if(!att && count >0)free++; for(int i=1;i<=count;i++)res = (res*i)%mod; } for(int i=1;i<=seg.size()+free;i++)res = (res*i)%mod; return \"\"+res; } int intLine(){ return parseInt(scan.nextLine()); } public static void main(String[] args) throws Exception{ Locale.setDefault(Locale.US); String cn = B.class.getName(); String sampleName = cn+\"-sample.in\"; String smallName = cn+\"-small-attempt4.in\"; String largeName = cn+\"-large.in\"; String name = largeName; String outName = name.substring(0, name.indexOf(\\'.\\'))+\".out\"; InputStream in = new BufferedInputStream(new FileInputStream(name)); PrintStream out = new PrintStream(new File(outName)); //PrintStream out = System.out; Scanner scan = new Scanner(in); int N = parseInt(scan.nextLine()); for(int c=1;c<=N;c++) { String res = new B(scan).solve(); out.printf(\"Case #%d: %s\\ \",c, res); System.err.println(c + \" done\"); } System.err.println(\"All done\"); } } '", "code2": "//Orz Sevenkplus #include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<ctime> #include<cctype> #include<complex> #include<algorithm> #include<iostream> #include<vector> #include<queue> #include<set> #include<map> #include<bitset> #define un using namespace un std; #define pb push_back #define pf pop_front #define mp make_pair #define c0 first #define c1 second #define sqr(x)((x)*(x)) #define clr(x)memset(x,0,sizeof(x)) #define clr1(x)memset(x,-1,sizeof(x)) #define clr80(x)memset(x,0x80,sizeof(x)) #define clr7F(x)memset(x,0x7F,sizeof(x)) #define ll long long #ifdef __unix__ #define LLD \"%lld\" #else #define LLD \"%I64d\" #endif #define pii pair<int,int> #define pip pair<int,pii> #define vi vector<int> #define vpi vector<pii> #define pq priority_queue template<typename T>inline bool chkmin(T&a,T b){return a>b?a=b,1:0;} template<typename T>inline bool chkmax(T&a,T b){return a<b?a=b,1:0;} #define modadd(a,b,c)(((a)+(b))%(c)) #define modmul(a,b,c)((int)(((ll)(a)*(b))%(c))) #define P 1000000007 #define getint(x){\\\\ char __next__char__;bool __nega__int__=0;\\\\ while(!isdigit(__next__char__=getchar())&&__next__char__!=\\'-\\');\\\\ __next__char__==\\'-\\'?(x=0,__nega__int__=1):(x=__next__char__-48);\\\\ while(isdigit(__next__char__=getchar()))x=x*10+__next__char__-48;\\\\ if(__nega__int__)x=-x;\\\\ } #define getint2(x1,x2){getint(x1);getint(x2);} #define getint3(x1,x2,x3){getint(x1);getint(x2);getint(x3);} #define getint4(x1,x2,x3,x4){getint(x1);getint(x2);getint(x3);getint(x4);} #define getint5(x1,x2,x3,x4,x5){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);} #define getint6(x1,x2,x3,x4,x5,x6){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);getint(x6);} char strr[200][200]; int f[26],b[26],e[26],l[200],s[26]; bool v[26]; bool check(int i){ char*str=strr[i]; clr(v); for(int j=l[i]-1;j--;){ if(str[j]!=str[j+1]){ if(v[str[j+1]-\\'a\\'])return 0; v[str[j+1]-\\'a\\']=1; } } return !v[str[0]-\\'a\\']; } int F[26]; int fa(int x){ int r=F[x],y=r; while(r!=F[r])r=F[r]; while((F[x]=r)!=(x=y))y=F[y]; return r; } int run(){ int n,ans=1; getint(n); clr(f); clr(b); clr(e); clr(s); for(int i=26;i--;)F[i]=i; for(int i=-1;++i!=n;){ clr(v); scanf(\"%s\",strr[i]); l[i]=strlen(strr[i]); char*str=strr[i]; if(str[0]==str[l[i]-1]){ e[str[0]-\\'a\\']++; ans=(ll)ans*e[str[0]-\\'a\\']%P; }else{ int x=fa(str[0]-\\'a\\'); int y=fa(str[l[i]-1]-\\'a\\'); if(x==y)return 0; F[x]=y; if(f[str[0]-\\'a\\']++){ return 0; } if(b[str[l[i]-1]-\\'a\\']++){ return 0; } } for(int j=l[i];j--;)v[str[j]-\\'a\\']=1; for(int j=26;j--;)s[j]+=v[j]; } for(int i=-1;++i!=n;){ char*str=strr[i]; if(!check(i)){ return 0; } for(int j=l[i];j--;) if(str[j]!=str[l[i]-1]&&str[j]!=str[0]){ if(s[str[j]-\\'a\\']>1)return 0; } } int q=0; for(int i=26;i--;){ if((e[i]||b[i])&&F[i]==i)q++; } while(q){ ans=(ll)ans*q%P; q--; } return ans; } int main(){ int T; getint(T); for(int t=1;t<=T;t++){ printf(\"Case #%d: %d\\ \",t,run()); } return 0; } '"}
{"code1": "def withoutDuplication(s): res = [] prev = -1 for c in s: i = ord(c) - ord(\\'a\\') if i != prev: res.append(i) prev = i return res mod = 1000000007 def fact(n): if n <= 1: return 1 return n*fact(n-1)%mod def solve(strs): n = 26 inE, outE, midE, badE = [0]*n, [0]*n, [0]*n, [0]*n g = [-1]*n for s in strs: letters = withoutDuplication(s) if len(letters) == 1: midE[letters[0]] += 1 else: outE[letters[0]] += 1 inE[letters[-1]] += 1 g[letters[0]] = letters[-1] for c in letters[1:-1]: badE[c] += 1 # print inE[:4], outE[:4], midE[:4], badE[:4], g[:4] for i in xrange(n): if badE[i] > 0 and inE[i] + outE[i] + midE[i] + badE[i] > 1: return 0 if inE[i] > 1 or outE[i] > 1: return 0 seen, nc = [False]*n, 0 for i in xrange(n): if seen[i] or inE[i] != 0: continue if outE[i] + midE[i] > 0: nc += 1 t = i while t != -1: seen[t] = True t = g[t] if len(filter(None, seen)) < n: return 0 #print nc res = fact(nc) for i in xrange(26): res *= fact(midE[i]) return res%mod T = int(raw_input()) for z in xrange(T): n = int(raw_input()) s = raw_input().strip().split(\\' \\') print \"Case #%d: %s\" % (z+1, solve(s))'", "code2": "#include <cstdlib> #include <cctype> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <vector> #include <string> #include <iostream> #include <sstream> #include <map> #include <set> #include <queue> #include <functional> using namespace std; typedef long long int64; #define PB push_back #define MP make_pair #define debug(x) cout<<(#x)<<\": \"<<(x)<<endl #define REP(i,n) for(int i=0;i<(n);++i) #define FOR(i,l,h) for(int i=(l);i<=(h);++i) #define FORD(i,h,l) for(int i=(h);i>=(l);--i) #define MOD 1000000007 inline int ADD(int a, int b) { a+=b; if (a>=MOD) a-=MOD; return (int)a; } inline void ADDTO(int &a, int b) { a+=b; if (a>=MOD) a-=MOD; } inline void SUBTO(int &a, int b) { a-=b; if (a<0) a+=MOD; } inline int MUL(int a, int b) { return (int)((int64)a*b%MOD); } int loop[30], indeg[30], oudeg[30], e[30][30], vis[30]; int fact[110], ans; void addEdge(char a, char b) { int u = a - \\'a\\', v = b - \\'a\\'; ++oudeg[u]; ++indeg[v]; e[u][v] = 1; } void dfs(int u) { vis[u] = 1; ans = MUL(ans, fact[loop[u]]); if (oudeg[u] > 0) { REP(v, 26) if (e[u][v] == 1) dfs(v); } } int main() { int tN; cin >> tN; fact[0] = 1; FOR(i, 1, 100) fact[i] = MUL(i, fact[i-1]); FOR(cN, 1, tN) { memset(loop, 0, sizeof(loop)); memset(indeg, 0, sizeof(indeg)); memset(oudeg, 0, sizeof(oudeg)); memset(e, 0, sizeof(e)); memset(vis, 0, sizeof(vis)); int n; cin >> n; REP(i, n) { string s; cin >> s; bool same = 1; REP(i, s.size()) { if (s[i] != s[0]) same = 0; if (i && s[i] != s[i-1]) addEdge(s[i-1], s[i]); } if (same) ++loop[s[0] - \\'a\\']; } bool nosol = 0; REP(i, 26) if (indeg[i] > 1 || oudeg[i] > 1) nosol = 1; if (!nosol) { ans = 1; int ncc = 0; REP(i, 26) if (!vis[i] && indeg[i] == 0) { if (oudeg[i] > 0 || loop[i] > 0) ++ncc; dfs(i); } ans = MUL(ans, fact[ncc]); REP(i, 26) if (!vis[i]) nosol = 1; } printf(\"Case #%d: \", cN); if (nosol) puts(\"0\"); else printf(\"%d\\ \", ans); } } '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; namespace CodeJam { internal class TestCase { public string[] Cars; } internal class Pair { public char First { get; set; } public char Last { get; set; } } internal class Program { private const string testFileName = \"B-large\"; private const int Base = 1000000007; public static IEnumerable<TestCase> ParseCases(TextReader reader) { var testCaseCount = int.Parse(reader.ReadLine()); for (var i = 0; i < testCaseCount; i++) { var carCount = int.Parse(reader.ReadLine()); var cars = reader.ReadLine().Split(); yield return new TestCase { Cars = cars }; } } private static long Solve(TestCase testCase) { // 3 types of cars // single letters: aaa // two letters: aabb // multiple letters aabcddd // simplify consecutive letters var withoutRuns = testCase.Cars.Select(RemoveConsecutive).ToArray(); var singleLetters = withoutRuns.Where(c => c.Length == 1).Select(c => c[0]).ToArray(); var hiddenLetters = withoutRuns.Where(c => c.Length > 2).SelectMany(c => c.Substring(1, c.Length - 2)).Distinct().ToArray(); var pairs = withoutRuns.Where(c => c.Length > 1).Select(c => new Pair { First = c[0], Last = c[c.Length - 1] }).ToArray(); // eliminate case 3 now if (pairs.Any(p => hiddenLetters.Contains(p.First) || hiddenLetters.Contains(p.Last)) || singleLetters.Any(hiddenLetters.Contains)) return 0; // we know just have to find orderings for pairs and single letters. // check that all the pairs can be ordered successfully if (pairs.Select(p => p.First).Distinct().Count() != pairs.Count() || pairs.Select(p => p.Last).Distinct().Count() != pairs.Count()) return 0; //check the groups that have an order imposed on them by the pairs var sortedPairs = GetFixedChains(pairs); if (sortedPairs == null) return 0; var singleLetterCounts = singleLetters.GroupBy(c => c, (key, values) => Tuple.Create(key, values.Count())); var lettersInChains = sortedPairs.SelectMany(p => p).SelectMany(p => new[] { p.First, p.Last }).Distinct(); var independentSingleLetters = singleLetters.Except(lettersInChains).ToArray(); // single letters can be in any order relative to each other long combinations = 1; foreach (var pair in singleLetterCounts) { combinations *= Factorial(pair.Item2); combinations %= Base; } // chains can be in any order relative to each other, and to the independent letters var independentBlockCount = independentSingleLetters.Count() + sortedPairs.Length; combinations *= Factorial(independentBlockCount); combinations %= Base; return combinations; } private static long Factorial(int x) { long fact = 1; while (x > 1) { fact *= x; fact %= Base; x--; } return fact; } private static Pair[][] GetFixedChains(Pair[] pairs) { var remainingPairs = pairs.ToList(); var sorted = new List<Pair[]>(); while (remainingPairs.Count > 0) { var chain = new List<Pair>(); var current = remainingPairs[0]; remainingPairs.RemoveAt(0); chain.Add(current); int index; var first = current; while ((index = remainingPairs.FindIndex(p => p.Last == first.First)) >= 0) { first = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Insert(0, first); } var last = current; while ((index = remainingPairs.FindIndex(p => p.First == last.Last)) >= 0) { last = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Add(last); } if (last.Last == first.First) return null; sorted.Add(chain.ToArray()); } return sorted.ToArray(); } private static string RemoveConsecutive(string arg) { var builder = new StringBuilder(arg.Length); char current = \\'\\\\0\\'; foreach (var c in arg) { if (c != current) { builder.Append(c); current = c; } } return builder.ToString(); } private static void Main(string[] args) { TestCase[] cases; using (var reader = new StreamReader(testFileName + \".in\")) using (var writer = new StreamWriter(testFileName + \".out\")) { cases = ParseCases(reader).ToArray(); for (int caseIndex = 0; caseIndex < cases.Length; caseIndex++) { var testCase = cases[caseIndex]; var solution = Solve(testCase); writer.WriteLine(\"Case #{0}: {1}\", caseIndex + 1, solution); } } } } }'", "code2": "#include <stdio.h> #include <stdlib.h> #include <string.h> #define M 1000000007LL //char *train[10]; int N; int count; int embedded[26]; int oneletter[26]; int endswith[26]; int startswith[26]; int impossible=0; int used; int segment; char *destutter(char *s) { static char buf2[200]; char *d=buf2; char last=0; while (*s) { if (*s!=last) last=*d++ = *s; s++; } *d=0; return buf2; } void readtrains(void) { int i,len,j; static char buff[200]; char *b; impossible=0; scanf(\"%d\",&N); for (i=0;i<26;i++) { embedded[i]=0; oneletter[i]=0; endswith[i]=-1; startswith[i]=-1; } for (i=0;i<N;i++) { scanf(\"%s\",buff); b=destutter(buff); len=strlen(b); if (len==1) { oneletter[*b-\\'a\\']++; continue; } if (startswith[*b-\\'a\\']>=0) impossible++; if (endswith[b[len-1]-\\'a\\']>=0) impossible++; startswith[*b-\\'a\\']=b[len-1]-\\'a\\'; endswith[b[len-1]-\\'a\\']=*b-\\'a\\'; for (j=1;j<len-1;j++) embedded[b[j]-\\'a\\']++; } } int modtimes(int a, int b) { return (int)((1LL*a*b) % M); } int factorial(int n) { int f=1; int i; if (n<=1) return 1; for (i=2;i<=n;i++) f=modtimes(f,i); return f; } void countonlyi(int i) { segment++; //printf(\"countonly %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); } void countendi(int i) { segment++; //printf(\"countend %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! while (1) { if ((1<<i) & used) {impossible++;return;} used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); i=endswith[i]; if (i<0) break; } } void countstarti(int i) { int used2=1<<i; //printf(\" Cs %c\\ \",i+\\'a\\'); while (startswith[i]>=0) { i=startswith[i]; //printf(\" cs %c\\ \",i+\\'a\\'); if (used2 & (1<<i)) { //printf(\"imp\\ \"); impossible++;return; } used2|=1<<i; } countendi(i); } void counttrains(void) { int i; count=1; used=0; segment=0; for (i=0;i<26;i++) { if (impossible || embedded[i]>1 || embedded[i] && (startswith[i]>=0 || endswith[i]>=0)) { printf(\"0\\ \"); //impossible return; } } i=0; while (i<26 && !impossible) { if (startswith[i]>=0 && !((1<<i) & used)) countstarti(i); if (endswith[i]>=0 && !((1<<i) & used)) countendi(i); if (oneletter[i]>0 && !((1<<i) & used)) countonlyi(i); i++; } if (impossible) printf(\"0\\ \"); else printf(\"%d\\ \",count); } void dump(void) { int i; printf(\"\\ \"); for (i=0;i<26;i++) { if (startswith[i]<0 && endswith[i]<0 && embedded[i]==0 && oneletter[i]==0) continue; printf(\" %c : ->%c %c<- em=%d 1L=%d\\ \",i+\\'a\\',startswith[i]+\\'a\\',endswith[i]+\\'a\\',embedded[i],oneletter[i]); } } int main(int argc, char **argv) { int tc,i; scanf(\"%d\",&tc); for (i=1;i<=tc;i++) { printf(\"Case #%d: \",i); readtrains(); //dump(); counttrains(); } return 0; } '"}
{"code1": "// uses http://introcs.cs.princeton.edu/java/stdlib/StdIn.java public class Train { static final int MOD = 1_000_000_007; public static long calc(String[] cars) { long result = 1; int n = cars.length; for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) { //System.out.println(java.util.Arrays.toString(cars)); int solocount = 0; int start = -1; int mid = -1; int end = -1; int solo = -1; for (int i=0; i<n; i++) { if (cars[i] == null) { } else if (cars[i].matches(\"\"+ch+\\'+\\')) { solocount++; result *= solocount; result %= MOD; cars[i] = null; solo = i; } else if (cars[i].matches(ch+\"+[^\"+ch+\"]+\")) { if (start != -1) return 0; start = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+\")) { if (end != -1) return 0; end = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+[^\"+ch+\"]+\")) { if (mid != -1) return 0; mid = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\")) { } else return 0; } //System.out.println(ch+\" \"+solocount+\" \"+start+\" \"+solo+\" \"+end+\" \"+result); if (mid == -1 && solocount == 0 && start == -1 && end == -1) continue; if (mid != -1 && (solocount > 0 || start != -1 || end != -1)) return 0; if (mid != -1) continue; String repl = \"\"; if (end != -1) {repl += cars[end]; cars[end] = null;} if (solo != -1) repl += ch; if (start != -1) {repl += cars[start]; cars[start] = null;} if (start != -1) {cars[start] = repl;} else if (solo != -1) {cars[solo] = repl;} else cars[end] = repl; } int left = 0; for (String s : cars) if (s != null) { left ++; result *= left; result %= MOD; } return result; } public static void main(String[] args) { int q = StdIn.readInt(); for (int j=1; j<=q; j++) { int n = StdIn.readInt(); String[] cars = new String[n]; { for (int i=0; i<n; i++) cars[i] = StdIn.readString(); } System.out.printf(\"Case #%d: %d\\ \", j, calc(cars)); } } } '", "code2": "import static java.lang.Math.*; import java.io.*; import java.math.*; import java.util.*; public class ProblemBLarge { static class Car { String s; LinkedHashMap<Character, Long> numAddedSameCharCars = new LinkedHashMap<Character, Long>(); char getFirst() { return s.charAt(0); } char getLast() { return s.charAt(s.length() - 1); } void addAllSameChars(Car car) { for (Map.Entry<Character, Long> entry : car.numAddedSameCharCars.entrySet()) { Character key = entry.getKey(); Long value = numAddedSameCharCars.get(key); if (value == null) value = 0L; value += entry.getValue(); numAddedSameCharCars.put(key, value); } } @Override public String toString() { return \"\"+s+\" (\"+numAddedSameCharCars+\")\"; } } public class Case { LinkedHashSet<Car> cars = new LinkedHashSet<Car>(); LinkedHashSet<Car> carsToCheck = new LinkedHashSet<Car>(); public void solve(int caseIndex) { for (Car car : cars) { if (isSameCharCar(car)) { car.numAddedSameCharCars.put(car.s.charAt(0), 1L); } } // System.out.println(\"Cars: \"+cars); carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); // LinkedHashSet<Car> carsWithSameChar = new LinkedHashSet<Car>(); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); if (isSameCharCar(car)) { for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } } carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } BigInteger result; if (!isValid()) { result = BigInteger.valueOf(0); } else { long mod = 1000000007L; result = BigInteger.valueOf(1); for (long i = 1; i <= cars.size(); i++) { result = result.multiply(BigInteger.valueOf(i)); } for (Car car : cars) { for (Long sameChars : car.numAddedSameCharCars.values()) { long a = 1; for (long i = 1; i <= sameChars; i++) { a *= i; a %= mod; } result = result.multiply(BigInteger.valueOf(a)); } } result = result.mod(BigInteger.valueOf(mod)); } // long result; // if (!isValid()) { // result = 0; // } // else { // long mod = 1000000007L; // // result = 1; // for (long i = 1; i <= cars.size(); i++) { // result *= i; // result %= mod; // } // // for (Car car : cars) { // for (Long sameChars : car.numAddedSameCharCars.values()) { // long a = 1; // for (long i = 1; i <= sameChars; i++) { // a *= i; // a %= mod; // } // result *= a; // result %= mod; // } // } // } println(\"Case #\" + (caseIndex + 1) + \": \" + result); } void combineCars(Car car1, Car car2) { Car car = new Car(); car.s = car1.s + car2.s; car.addAllSameChars(car1); car.addAllSameChars(car2); // car.numAddedSameCharCars = car1.numAddedSameCharCars + car2.numAddedSameCharCars; cars.add(car); carsToCheck.add(car); cars.remove(car1); carsToCheck.remove(car1); cars.remove(car2); carsToCheck.remove(car2); // System.out.println(\"Cars: \"+cars); } boolean isSameCharCar(Car car) { String s = car.s; for (int k = 0; k < s.length(); k++) { if (s.charAt(k) != s.charAt(0)) { return false; } } return true; } boolean isValid() { LinkedHashSet<Character> processed = new LinkedHashSet<>(); Character last = null; for (Car car : cars) { String s = car.s; for (int k = 0; k < s.length(); k++) { char ch = s.charAt(k); // System.out.println(\"Current: \"+ch); if (last != null && last.charValue() == ch) { // System.out.println(\"Last: \"+last+\", processed: \"+processed); } else { if (processed.contains(ch)) return false; processed.add(ch); } last = ch; } } return true; } long factorial(long p) { long result = 1; for (long i = 2; i <= p; i++) result *= i; return result; } } public void run() throws Exception { BufferedReader r = new BufferedReader(new FileReader(\"input.txt\")); int numCases = new InputParser(r.readLine()).readInt(); for (int caseIndex = 0; caseIndex < numCases; caseIndex++) { Case c = new Case(); InputParser p = new InputParser(r.readLine()); int numCars = p.readInt(); p = new InputParser(r.readLine()); for (int i = 0; i < numCars; i++) { Car car = new Car(); car.s = p.readToken(); c.cars.add(car); } c.solve(caseIndex); } r.close(); } public static void main(String[] args) throws Exception { fileWriter = new PrintWriter(new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"output.txt\")))); new ProblemBLarge().run(); fileWriter.close(); } public static class InputParser { String text; int pos; public InputParser(String text) { this.text = text; } public void skipSpaces() { while (pos < text.length()) { if (text.charAt(pos) != \\' \\') break; pos++; } } public String readUntil(char expectedChar) { StringBuilder b = new StringBuilder(); while (pos < text.length()) { char ch = text.charAt(pos); if (ch == expectedChar) break; b.append(ch); pos++; } return b.toString(); } public String readToken() { skipSpaces(); return readUntil(\\' \\'); } public int readInt() { return Integer.parseInt(readToken()); } public long readLong() { return Long.parseLong(readToken()); } public double readDouble() { return Double.parseDouble(readToken()); } public char readChar() { char ch = text.charAt(pos); pos++; return ch; } public void readExpectedString(String s) { for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (readChar() != ch) throw new RuntimeException(\"Expected: \"+ch); } } } public static PrintWriter fileWriter; public static void print(String text) { fileWriter.print(text); System.out.print(text); } public static void println(String text) { fileWriter.println(text); System.out.println(text); } public static <Key, Value> void addToMultiMapArrayList(Key key, Value value, Map<Key, ArrayList<Value>> map) { ArrayList<Value> list = map.get(key); if (list == null) { list = new ArrayList<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> void addToMultiMapLinkedHashSet(Key key, Value value, Map<Key, LinkedHashSet<Value>> map) { LinkedHashSet<Value> list = map.get(key); if (list == null) { list = new LinkedHashSet<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> ArrayList<Value> getMultiMapValues(Map<Key, Collection<Value>> map) { ArrayList<Value> result = new ArrayList<Value>(); for (Collection<Value> list : map.values()) { result.addAll(list); } return result; } // binarySearch(, , 0.000000001, new Function<Double, Integer>() { // public Integer evaluate(Double key) { // return ; // } // }); public static double binarySearch(double low, double high, double precision, Function<Double, Integer> f) { if (high < low) throw new RuntimeException(\"High (\"+high+\") cannot be smaller than low (\"+low+\")\"); { int lowValue = f.evaluate(low); if (lowValue == 0) return low; if (lowValue > 0) throw new RuntimeException(\"Unsuitable low: \"+low); } { int highValue = f.evaluate(high); if (highValue == 0) return high; if (highValue < 0) throw new RuntimeException(\"Unsuitable high: \"+high); } while (true) { double mid = (low + high) * 0.5; if (abs(high - low) < precision) { return mid; } int c = f.evaluate(mid); if (c < 0) low = mid; else if (c > 0) high = mid; else return mid; } } public static <T> LinkedHashSet<T> intersection(Set<T> s1, Set<T> s2) { if (s2.size() < s1.size()) { Set<T> temp = s1; s1 = s2; s2 = temp; } LinkedHashSet<T> result = new LinkedHashSet<T>(); for (T o : s1) { if (s2.contains(o)) result.add(o); } return result; } public static interface Function<Key, Value> { public Value evaluate(Key key); } public static class Int2 { int x, y; public Int2(int x, int y) { this.x = x; this.y = y; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Int2 other = (Int2) obj; if (x != other.x) return false; if (y != other.y) return false; return true; } @Override public String toString() { return \"(\"+x+\",\"+y+\")\"; } } } '"}
{"code1": "#include <iostream> #include <fstream> #include <string> #include <algorithm> #include <cstdlib> #include <cstring> #include <set> #include <map> #include <vector> #include <stack> #include <queue> #include <deque> #include <iomanip> #include <cassert> typedef long long ll; typedef unsigned long long ull; using namespace std; bool is_aaa(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] != c) return false; } return true; } bool is_aax(const string& s, char c) { return s[0] == c; } bool is_yaa(const string& s, char c) { return s[(int)s.size() - 1] == c; } bool is_uav(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] == c) return true; } return false; } int fragment_count(const string& s, char c) { int result = 0; int n = (int)s.size(); int i = 0; while (i < n) { if (s[i] != c) i++; else { int j = i; while (j + 1 < n && s[j + 1] == c) j++; result++; i = j + 1; } } return result; } const int MAXN = 109; int N; string s[MAXN]; vector<string> pieces; const ll MOD = 1000000007; ll fact[MAXN]; ll solve(void) { pieces.clear(); for (int i = 0; i < N; i++) pieces.push_back(s[i]); ll result = 1; for (char c = \\'a\\'; c <= \\'z\\'; c++) { vector<string> aaa; vector<string> aax; vector<string> yaa; vector<string> uav; vector<string> other; for (int i = 0; i < pieces.size(); i++) { if (is_aaa(pieces[i], c)) aaa.push_back(pieces[i]); else if (is_aax(pieces[i], c)) aax.push_back(pieces[i]); else if (is_yaa(pieces[i], c)) yaa.push_back(pieces[i]); else if (is_uav(pieces[i], c)) uav.push_back(pieces[i]); else other.push_back(pieces[i]); } if (uav.size() != 0) { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0 && uav.size()==1 && fragment_count(uav[0], c)==1) { ; } else return 0LL; } else { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0) { ; // no constraints at all } else { if (yaa.size() <= 1 && aax.size() <= 1) { if (yaa.size() == 1) { if (fragment_count(yaa[0], c) > 1) return 0LL; } if (aax.size() == 1) { if (fragment_count(aax[0], c) > 1) return 0LL; } result *= fact[aaa.size()]; result %= MOD; pieces = other; string new_piece; if (yaa.size() != 0) new_piece += yaa[0]; for (int i = 0; i < aaa.size(); i++) new_piece += aaa[i]; if (aax.size() != 0) new_piece += aax[0]; pieces.push_back(new_piece); } else return 0LL; } } } result *= fact[pieces.size()]; result %= MOD; return result; } void solve_B(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; fact[0] = 1LL; for (int i = 1; i < MAXN; i++) fact[i] = (fact[i - 1] * i) % MOD; for (int tt = 1; tt <= T; tt++) { for (int i = 0; i < MAXN; i++) s[i] = \"\"; in >> N; for (int i = 0; i < N; i++) in >> s[i]; ll temp = solve(); out << \"Case #\" << tt << \": \"; out << temp; out << \\'\\ \\'; } in.close(); out.close(); } int main() { //solve_A(); solve_B(); //solve_C(); return 0; } void solve_(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; for (int tt = 1; tt <= T; tt++) { out << \"Case #\" << tt << \": \"; } in.close(); out.close(); }'", "code2": "import java.util.HashSet; import java.util.Scanner; import java.util.Set; public class B { static final long BASE = 1000000007; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int cases = sc.nextInt(); long[] factorial = new long[101]; factorial[0] = 1; for (int i = 1; i < 101; i++) { factorial[i] = (factorial[i - 1] * i) % BASE; } for (int caseNum = 1; caseNum <= cases; caseNum++) { int N = sc.nextInt(); String[] cars = new String[N]; Set<Character> interior = new HashSet<Character>(); int[] singleLetterStrs = new int[26]; int[] starts = new int[26]; int[] ends = new int[26]; char[] next = new char[26]; boolean possible = true; for (int i = 0; i < N; i++) { cars[i] = sc.next(); int firstChar = cars[i].charAt(0) - \\'a\\'; char lastChar = cars[i].charAt(cars[i].length() - 1); if (isSingleLetter(cars[i])) { int index = firstChar; singleLetterStrs[index]++; } else { for (Character ch : getInteriorChars(cars[i])) { if (interior.contains(ch)) { possible = false; break; } interior.add(ch); } starts[firstChar]++; ends[lastChar - \\'a\\']++; next[firstChar] = lastChar; } } int numGroups = 0; for (int i = 0; i < 26; i++) { if (!possible) { break; } char ch = (char) (\\'a\\' + i); if (interior.contains(ch) && (singleLetterStrs[i] + starts[i] + ends[i] > 0)) { possible = false; } if (starts[i] > 1 || ends[i] > 1) { possible = false; } if (singleLetterStrs[i] > 0 && starts[i] == 0 && ends[i] == 0) { numGroups++; } else if (starts[i] == 1 && ends[i] == 0) { numGroups++; } } possible = possible && !hasCycles(next); System.out.print(\"Case #\" + caseNum + \": \"); if (!possible) { System.out.println(0); continue; } long ways = 1; for (int i = 0; i < 26; i++) { ways = (ways * factorial[singleLetterStrs[i]]) % BASE; } ways = (ways * factorial[numGroups]) % BASE; System.out.println(ways); } } private static boolean hasCycles(char[] next) { for (int i = 0; i < 26; i++) { if (next[i] == 0) { continue; } char start = (char) (\\'a\\' + i); int currIndex = i; while (next[currIndex] != 0 && next[currIndex] != start) { currIndex = next[currIndex] - \\'a\\'; } if (next[currIndex] == start) { return true; } } return false; } private static Set<Character> getInteriorChars(String str) { Set<Character> chars = new HashSet<Character>(); if (isSingleLetter(str)) { return chars; } int startIndex = 0; while (str.charAt(startIndex + 1) == str.charAt(0)) { startIndex++; } int endIndex = str.length() - 1; while (str.charAt(endIndex - 1) == str.charAt(str.length() - 1)) { endIndex--; } for (int i = startIndex + 1; i < endIndex; i++) { chars.add(str.charAt(i)); } return chars; } private static boolean isSingleLetter(String str) { char ch = str.charAt(0); for (int i = 1; i < str.length(); i++) { if (str.charAt(i) != ch) { return false; } } return true; } } '"}
{"code1": "#include <stdio.h> #include <stdlib.h> #include <math.h> #include <ctype.h> #include <string.h> int TC, T; int Cars; char Car[120][120]; char Visited[130]; int Stack[120]; int Used[120]; int i, x, y, L, Ans; char Last; int DFS(int Level){ if (Level==Cars){ int i, x; Last = Car[Stack[0]][0]; memset(Visited, 0, sizeof(Visited)); Visited[Last] = 1; for (i=0; i<Cars; i++){ L = strlen(Car[Stack[i]]); for (x=0; x<L; x++){ if (Car[Stack[i]][x]==Last) continue; if (Visited[Car[Stack[i]][x]]) return ; Visited[Car[Stack[i]][x]] = 1; Last = Car[Stack[i]][x]; } } Ans++; return ; } int i; for (i=0; i<Cars; i++) if (!Used[i]){ Used[i] = 1; Stack[Level] = i; DFS(Level+1); Used[i] = 0; } } int main(){ freopen(\"B-small-attempt0.in\", \"r\", stdin); freopen(\"B-small-attempt0.out\", \"w\", stdout); scanf(\"%d\", &TC); for (T=1; T<=TC; T++){ printf(\"Case #%d: \", T); scanf(\"%d\", &Cars); for (i=0; i<Cars; i++) scanf(\"%s\", Car[i]); Ans = 0; DFS(0); printf(\"%d\\ \", Ans); } return 0; } '", "code2": "#!/usr/bin/pypy import itertools,math,sys def simple_solve(N,S): S = sorted(S) cnt = 0 for perm in itertools.permutations(S): z = \"\".join(perm) chars = [False for _ in range(26)] last = \\'\\' for c in z: if last==c: continue last = c if chars[ord(c)-ord(\\'a\\')]: break chars[ord(c)-ord(\\'a\\')] = True else: cnt += 1 return cnt def true_solve(N,S): rz = {} for c in range(26): char = chr(c+ord(\\'a\\')) cnt_inside = cnt_left = cnt_right = cnt_full = 0 left_char = right_char = \"\" for z in S: h = False last = \"\" for x in z: if x==char and h and last != char: return 0 if x==char: h = True last = x if z[0] == z[-1] == char: cnt_full += 1 elif z[0] == char: cnt_left += 1 right_char = z[-1] elif z[-1] == char: cnt_right += 1 left_char = z[0] elif h: cnt_inside += 1 if cnt_inside > 1 or cnt_inside > 0 and cnt_left+cnt_right+cnt_full>0 or cnt_left>1 or cnt_right>1: return 0 if cnt_inside == 0 and cnt_left+cnt_right+cnt_full>0: rz[char] = ((left_char,right_char,math.factorial(cnt_full))) blocks = 0 bb = 1 while rz: for c,v in rz.items(): if v[0]==\"\": break else: return 0 del rz[c] bb *= v[2] while v[1] != \"\": if v[1] not in rz: return 0 v = rz.pop(v[1]) bb *= v[2] blocks += 1 return math.factorial(blocks)*bb%1000000007 def solve(): N = int(raw_input()) S = raw_input().strip().split() val1 = true_solve(N,S) #val2 = simple_solve(N,S) #if val1 != val2: # print \"Bad\" # print N,S # print val1,val2 # sys.exit(1) return val1 T = int(raw_input()) for t in range(1,T+1): print \"Case #%d:\"%t,solve() '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Linq; using System.Numerics; using System.Text; using System.Threading.Tasks; namespace GCJ2014R1CB { class Program { /// <summary> /// \\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe6\\x95\\xb0 /// </summary> static int ThreadCount = 1; /// <summary> /// \\xe9\\x80\\xb2\\xe6\\x8d\\x97\\xe3\\x82\\x92\\xe8\\xa1\\xa8\\xe7\\xa4\\xba\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 /// </summary> static bool Verbose = true; static int ProgressInterval = 1; class Solver { public List<string> SolveAll(int threadId, StreamReader sr) { // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ int TestCase = int.Parse(sr.ReadLine()); // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ List<string> outputs = new List<string>(); for (int testCase = 0; testCase < TestCase; testCase++) { // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ int N = int.Parse(sr.ReadLine()); string l = sr.ReadLine(); // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ #region if (testCase % ThreadCount != threadId) { // \\xe3\\x81\\x93\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xae\\xe6\\x8b\\x85\\xe5\\xbd\\x93\\xe3\\x81\\xa7\\xe3\\x81\\xaf\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe3\\x81\\xae\\xe3\\x81\\xa7\\xe8\\xa7\\xa3\\xe3\\x81\\x8b\\xe3\\x81\\xaa\\xe3\\x81\\x84 continue; } if (Verbose) { if (testCase % ProgressInterval == 0) { Console.Error.WriteLine(testCase + \" / \" + TestCase); } } #endregion // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ string output = Solve(testCase, l); // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ outputs.Add(output); } return outputs; } const long Mod = 1000000007; string Solve(int testCase, string l) { if (testCase == -1) { } List<string> ts = l.Split(\\' \\').ToList(); BigInteger ans = 1; for(char c = \\'a\\'; c <= \\'z\\'; c++) { int ct = 0; string ns = \"\"; for(int i = 0; i < ts.Count; i++) { if (ts[i].First() == c && ts[i].Last() == c) { ns += ts[i]; ct++; ans *= ct; ts.RemoveAt(i); i--; } } if (ct > 0) { ts.Add(ns); } } for(;;) { bool f = Update(ts, true); if (f == false) { break; } } for(;;) { bool f = Update(ts, false); if (f == false) { break; } } string all = string.Concat(ts); for(char c = \\'a\\'; c <= \\'z\\'; c++) { int first = all.IndexOf(c); if (first < 0) { continue; } int last = all.LastIndexOf(c); for(int i = first; i < last; i++) { if (all[i] != c) { return \"0\"; } } } for(int i = 1; i <= ts.Count; i++) { ans *= i; } ans %= Mod; return ans.ToString(); } static bool Update(List<string> ts, bool primary) { int N = ts.Count(); for(int i = 0; i < N; i++) { if (primary && ts[i].First() != ts[i].Last()) { continue; } for(int j = 0; j < N; j++) { if (i == j) { continue; } if (ts[i].Last() == ts[j].First()) { ts[i] += ts[j]; ts.RemoveAt(j); return true; } } } return false; } } static void Main(string[] args) { // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\x84\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\x9f\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\xab\\xe5\\xaf\\xbe\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe5\\x87\\xa6\\xe7\\x90\\x86\\xe3\\x82\\x92\\xe8\\xa1\\x8c\\xe3\\x81\\x86\\xe3\\x80\\x82 // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe3\\x82\\xab\\xe3\\x83\\xac\\xe3\\x83\\xb3\\xe3\\x83\\x88\\xe3\\x83\\x87\\xe3\\x82\\xa3\\xe3\\x83\\xac\\xe3\\x82\\xaf\\xe3\\x83\\x88\\xe3\\x83\\xaa\\xe3\\x81\\xae large \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81 // small \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81sample.in \\xe3\\x82\\x92\\xe9\\xa0\\x86\\xe3\\x81\\xab\\xe6\\xa4\\x9c\\xe7\\xb4\\xa2\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 // large \\xe3\\x82\\x84 small \\xe3\\x81\\x8c\\xe8\\xa4\\x87\\xe6\\x95\\xb0\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe5\\x90\\x8d\\xe5\\x89\\x8d\\xe3\\x81\\xa7\\xe3\\x82\\xbd\\xe3\\x83\\xbc\\xe3\\x83\\x88\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe4\\xb8\\x80\\xe7\\x95\\xaa\\xe6\\x9c\\x80\\xe5\\xbe\\x8c\\xe3\\x81\\xae\\xe3\\x82\\x92\\xe4\\xbd\\xbf\\xe3\\x81\\x86\\xe3\\x80\\x82 string inputName = null; if (args.Length > 0) { if (File.Exists(args[0]) == false) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } inputName = args[0]; } if (inputName == null) { List<string> larges = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"large\") && fi.Name.EndsWith(\".in\")) { larges.Add(fi.FullName); } } if (larges.Count > 0) { larges.Sort(); inputName = larges[larges.Count - 1]; } } if (inputName == null) { List<string> smalls = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"small\") && fi.Name.EndsWith(\".in\")) { smalls.Add(fi.FullName); } } if (smalls.Count > 0) { smalls.Sort(); inputName = smalls[smalls.Count - 1]; } } if (inputName == null) { foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.ToLower() == \"sample.in\") { inputName = fi.FullName; break; } } } if (inputName == null) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } // \\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe5\\x85\\x88\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x82\\x92\\xe6\\xb1\\xba\\xe5\\xae\\x9a\\xe3\\x81\\x97\\xe3\\x80\\x81\\xe5\\x90\\x8c\\xe5\\x90\\x8d\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x83\\xaa\\xe3\\x83\\x8d\\xe3\\x83\\xbc\\xe3\\x83\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 string outputName = inputName; if (outputName.EndsWith(\".in\")) { outputName = outputName.Substring(0, outputName.Length - 3); } outputName += \".out\"; if (File.Exists(outputName)) { int rev = 1; while (File.Exists(outputName + \".\" + rev)) { rev++; } File.Move(outputName, outputName + \".\" + rev); } // \\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82ThreadCount == 1 \\xe3\\x81\\xaa\\xe3\\x82\\x89\\xe3\\x80\\x81\\xe7\\x8f\\xbe\\xe5\\x9c\\xa8\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xa7\\xe3\\x80\\x81\\xe3\\x81\\x9d\\xe3\\x82\\x8c\\xe4\\xbb\\xa5\\xe5\\xa4\\x96\\xe3\\x81\\xaa\\xe3\\x82\\x89 Parallel \\xe3\\x81\\xa7\\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 List<string>[] outputs = new List<string>[ThreadCount]; if (ThreadCount == 1) { for (int i = 0; i < ThreadCount; i++) { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } } } else { Parallel.For(0, ThreadCount, i => { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } }); } // \\xe7\\xb5\\x90\\xe6\\x9e\\x9c\\xe3\\x82\\x92\\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82Case # \\xe3\\x81\\xaf\\xe3\\x81\\x93\\xe3\\x81\\x93\\xe3\\x81\\xa7\\xe4\\xbb\\x98\\xe5\\x8a\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 using (StreamWriter sw = new StreamWriter(outputName)) { for (int i = 0; ; i++) { if (outputs[i % ThreadCount].Count > i / ThreadCount) { sw.WriteLine(\"Case #\" + (i + 1) + \": \" + outputs[i % ThreadCount][i / ThreadCount]); } else { break; } } } } } } '", "code2": "#include<stdio.h> #include<stdlib.h> #include<string.h> #define MOD 1000000007LL int t,T,n,N; long long frac[128]; long long C; char s[128][128]; long long ans; char start[128];/*First Letter*/ char end[128];/*Last Letter*/ char blocked[256]; /*Internal characters*/ int first; int tmp; int c; int only_start[256]; int only_end[256]; int loops[256]; int done[256]; int num_frag; char tmp2; char tmp3; int main(){ scanf(\"%d\",&T); frac[0]=1; for(C=1;C<120;C++) frac[C]=(frac[C-1]*C)%MOD; for(t=1;t<=T;t++){ scanf(\"%d\",&N); for(n=1;n<=N;n++){scanf(\"%s\",&s[n][0]);} for(c=0;c<256;c++) { blocked[c]=0; only_start[c]=0; only_end[c]=0; loops[c]=0; } ans=1; for(n=1;n<=N;n++) { tmp=strlen(s[n]); first=1; start[n]=s[n][0]; end[n]=s[n][tmp-1]; for(c=1;c<tmp;c++) { if (s[n][c]!=s[n][c-1]) { if (blocked[s[n][c]]==1) ans=0; if (first==0) { blocked[s[n][c-1]]=1; } first=0; } } if ((start[n]==end[n])&&(first==0)) ans=0; } if (ans==1) { for(n=1;n<=N;n++) { if (blocked[start[n]]==1) ans=0; if (blocked[end[n]]==1) ans=0; } } if (ans==1) { for(n=1;n<=N;n++) { if (start[n]==end[n]) {loops[start[n]]++;} else { only_start[start[n]]++; only_end[end[n]]++; } } for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if (only_start[tmp2]>1) ans=0; if (only_end[tmp2]>1) ans=0; } } if (ans==1) { num_frag=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) num_frag++; if ((only_start[tmp2]==0)&&(only_end[tmp2]==0)&&(loops[tmp2]>0)) num_frag++; ans*=frac[loops[tmp2]]; ans%=MOD; } ans*=frac[num_frag]; ans%=MOD; } /*Detect cycles*/ if (ans!=0) { for(c=0;c<256;c++) done[c]=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) { tmp3=tmp2; do{ for(n=1;n<=N;n++) { if ((start[n]==tmp3)&&(start[n]!=end[n])) break; } done[n]=1; tmp3=end[n]; } while (only_start[tmp3]==1); } } for(n=1;n<=N;n++) { if ((done[n]==0)&&(start[n]!=end[n])) ans=0; } } printf(\"Case #%d: \",t); printf(\"%lld\\ \",ans); } return 0; } '"}
{"code1": "//#pragma comment(linker, \"/STACK:134217728\") #include <iostream> #include <sstream> #include <cstdio> #include <cstdlib> #include <cmath> #include <cctype> #include <cstring> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> #include <numeric> using namespace std; typedef long long Int; typedef pair<int,int> PII; typedef vector<int> VInt; #define FOR(i, a, b) for(i = (a); i < (b); ++i) #define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i) #define CLEAR(a, b) memset(a, b, sizeof(a)) #define SIZE(a) int((a).size()) #define ALL(a) (a).begin(),(a).end() #define PB push_back #define MP make_pair #define MOD 1000000007 string S[256]; int A[256]; int C[256]; int Next[256]; int Prev[256]; int B[256]; Int dfs(int a) { if (a == -1) return 1; B[a] = 1; Int res = 1; int i; FOR(i, 0, C[a]) res = res * (i + 1) % MOD; return res * dfs(Next[a]) % MOD; } Int f(int n) { CLEAR(A, 0); CLEAR(C, 0); CLEAR(Next, -1); CLEAR(Prev, -1); int i, j; FOR(i, 0, n) { char first = S[i].front(); char last = S[i].back(); FOR(j, 1, SIZE(S[i]) - 1) { char mid = S[i][j]; if (A[mid] == 0) ++A[mid]; else return 0; } if (first == last) { if (SIZE(S[i]) == 1) ++C[first]; else return 0; } else { if (Next[first] != -1) return 0; if (Prev[last] != -1) return 0; Next[first] = last; Prev[last] = first; } } FOR(i, 0, 256) if (A[i] != 0 && (C[i] != 0 || Next[i] != -1 || Prev[i] != -1)) return 0; Int res = 1; int cnt = 0; CLEAR(B, 0); FOR(i, 0, 256) if (B[i] == 0 && Prev[i] == -1) { if (C[i] != 0 || Next[i] != -1) ++cnt; res *= dfs(i); res %= MOD; } FOR(i, 0, cnt) res = res * (i + 1) % MOD; FOR(i, 0, 256) if (B[i] == 0) return 0; return res; } int SolveTest(int test) { int n; scanf(\"%d\", &n); int i, j; FOR(i, 0, n) { char buf[128]; scanf(\"%s\", buf); int len = strlen(buf); string s; int prev = 0; FOR(j, 1, len + 1) if (j == len || buf[j] != buf[prev]) { s.push_back(buf[prev]); prev = j; } S[i] = s; } printf(\"Case #%d: %d\\ \", test + 1, int(f(n))); return 0; } int main() { freopen(\"b.in\", \"r\", stdin); freopen(\"b.out\", \"w\", stdout); int T, t; char buf[1 << 7]; gets(buf); sscanf(buf, \"%d\", &T); FOR(t, 0, T) { fprintf(stderr, \"Solving %d/%d\\ \", t + 1, T); SolveTest(t); } return 0; }; '", "code2": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Linq; using System.Text; using System.IO; namespace ProblemA { class Program { static void Main(string[] args) { using (var sr = new StreamReader(@\"..\\\\..\\\\B-small-attempt0.in\")) { using (var sw = new StreamWriter(@\"..\\\\..\\\\B-small-attempt0.out\")) { var T = int.Parse(sr.ReadLine()); for (int t = 1; t <= T; t++) { sr.ReadLine(); var s = sr.ReadLine().Split(); var k = Enumerable.Range(0, s.Length).ToArray(); int res = 0; do { //for (int i = 0; i < k.Length; i++) //{ // Console.Write(k[i]); // Console.Write(\" \"); //} //Console.WriteLine(); //continue; var u = new bool[50]; int i; for (i = 0; i < k.Length; i++) { int j; for (j = 0; j < s[k[i]].Length; j++) { if (u[s[k[i]][j] - \\'a\\']) { if (j > 0) { if (s[k[i]][j - 1] != s[k[i]][j]) { break; } } else { if (s[k[i - 1]][s[k[i - 1]].Length - 1] != s[k[i]][j]) { break; } } } u[s[k[i]][j] - \\'a\\'] = true; } if (j < s[k[i]].Length) { break; } } if (i == k.Length) { res++; } } while (NextPermutation(k)); sw.WriteLine(\"Case #{0}: {1}\", t, res); } } } } private static bool NextPermutation(int[] numList) { /* Knuths 1. Find the largest index j such that a[j] < a[j + 1]. If no such index exists, the permutation is the last permutation. 2. Find the largest index l such that a[j] < a[l]. Since j + 1 is such an index, l is well defined and satisfies j < l. 3. Swap a[j] with a[l]. 4. Reverse the sequence from a[j + 1] up to and including the final element a[n]. */ var largestIndex = -1; for (var i = numList.Length - 2; i >= 0; i--) { if (numList[i] < numList[i + 1]) { largestIndex = i; break; } } if (largestIndex < 0) return false; var largestIndex2 = -1; for (var i = numList.Length - 1; i >= 0; i--) { if (numList[largestIndex] < numList[i]) { largestIndex2 = i; break; } } var tmp = numList[largestIndex]; numList[largestIndex] = numList[largestIndex2]; numList[largestIndex2] = tmp; for (int i = largestIndex + 1, j = numList.Length - 1; i < j; i++, j--) { tmp = numList[i]; numList[i] = numList[j]; numList[j] = tmp; } return true; } } } '"}
{"code1": "import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStream; import java.io.PrintStream; import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; import static java.lang.Integer.*; import static java.lang.Character.*; public class B { Scanner scan; public B(Scanner s) { this.scan = s; } String[]A; long brut(char last, boolean[]U,boolean[]L) { long r =0; boolean all=true; for(int i=0;i<A.length;i++){ if(U[i])continue; all=false; boolean[]nl = L.clone(); char lc = \\'#\\'; for(char c:A[i].toCharArray()){ if(nl[c]) { if(lc!=c && !(c==last && c==A[i].charAt(0)))return 0; } nl[c]=true; } U[i]=true; r += brut(A[i].charAt(A[i].length()-1),U, nl); U[i]=false; } if(all)return 1; return r%1000000007; } public String solve() { int n = scan.nextInt(); A = new String[n]; for(int i=0;i<n;i++){ A[i]= \"\";String s =scan.next(); for(int j=0;j<s.length();j++) { if(A[i].length()==0 || A[i].charAt(A[i].length()-1)!=s.charAt(j))A[i]+=s.charAt(j); } System.out.print(A[i] +\" \"); } // System.out.println(); /* long res = brut(\\'#\\', new boolean[n], new boolean[256]); return \"\"+res; */ boolean[]EQ = new boolean[n]; for(int sn=0;sn<n;sn++){ String s = A[sn]; int d=0; boolean[] v = new boolean[256]; for(int i=0;i<s.length();i++){ if(v[s.charAt(i)] && s.charAt(i-1)!=s.charAt(i))return \"0\"; if(!v[s.charAt(i)]) { d++; v[s.charAt(i)]=true; } if(i>0 && s.charAt(i)!=s.charAt(0) && i+1<s.length() && s.charAt(i) !=s.charAt(s.length()-1)){ for(int j=0;j<n;j++){ if(j==sn)continue; for(char c:A[j].toCharArray()) { if(c==s.charAt(i))return \"0\"; } } } } EQ[sn]=d==1; } for(int i=0;i<n;i++)for(int j=0;j<n;j++){ if(i==j)continue; if(EQ[i]||EQ[j])continue; if(A[i].charAt(0)==A[j].charAt(0))return \"0\"; if(A[i].charAt(A[i].length()-1)==A[j].charAt(A[j].length()-1))return \"0\"; } boolean[][]M = new boolean[n][n]; int[]inc = new int[n]; int[]out = new int[n]; int parts =0; for(int i=0;i<n;i++){ if(EQ[i])continue; parts++; for(int j=0;j<n;j++){ if(EQ[j]||i==j)continue; if(A[i].charAt(A[i].length()-1)==A[j].charAt(0)){ M[i][j]=true; inc[j]++; out[i]++; } } } for(int i=0;i<n;i++)if(inc[i]>1||out[i]>1)return \"0\"; int ch=0; boolean cover[]=new boolean[n]; ArrayList<String> seg = new ArrayList<>(); for(int i=0;i<n;i++){ if(EQ[i])continue; if(inc[i]==0 && out[i]==0){ seg.add(A[i].charAt(0)+\"\"+A[i].charAt(A[i].length()-1)); cover[i]=true; } if(inc[i]>0 || out[i]==0)continue; String s =\"\"+A[i].charAt(0); int p =i; cover[p]=true; while(out[p]>0){ for(int j=0;j<n;j++) if(M[p][j]){ p=j; cover[p]=true; } } s+=A[p].charAt(A[p].length()-1); seg.add(s); } for(int i=0;i<n;i++)if(!EQ[i]&&!cover[i])return \"0\"; long res = 1; int free =0; long mod = 1000000007; for(char c = \\'a\\';c<=\\'z\\';c++){ int count=0;boolean att = false; for(int i=0;i<n;i++){ if(EQ[i]){ if(A[i].charAt(0)==c)count++; } } if(count==0)continue; for(int i=0;i<A.length;i++){ String s = A[i]; if(EQ[i])continue; if(s.charAt(0)==c || s.charAt(s.length()-1)==c)att=true; } if(!att && count >0)free++; for(int i=1;i<=count;i++)res = (res*i)%mod; } for(int i=1;i<=seg.size()+free;i++)res = (res*i)%mod; return \"\"+res; } int intLine(){ return parseInt(scan.nextLine()); } public static void main(String[] args) throws Exception{ Locale.setDefault(Locale.US); String cn = B.class.getName(); String sampleName = cn+\"-sample.in\"; String smallName = cn+\"-small-attempt4.in\"; String largeName = cn+\"-large.in\"; String name = largeName; String outName = name.substring(0, name.indexOf(\\'.\\'))+\".out\"; InputStream in = new BufferedInputStream(new FileInputStream(name)); PrintStream out = new PrintStream(new File(outName)); //PrintStream out = System.out; Scanner scan = new Scanner(in); int N = parseInt(scan.nextLine()); for(int c=1;c<=N;c++) { String res = new B(scan).solve(); out.printf(\"Case #%d: %s\\ \",c, res); System.err.println(c + \" done\"); } System.err.println(\"All done\"); } } '", "code2": "//Orz Sevenkplus #include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<ctime> #include<cctype> #include<complex> #include<algorithm> #include<iostream> #include<vector> #include<queue> #include<set> #include<map> #include<bitset> #define un using namespace un std; #define pb push_back #define pf pop_front #define mp make_pair #define c0 first #define c1 second #define sqr(x)((x)*(x)) #define clr(x)memset(x,0,sizeof(x)) #define clr1(x)memset(x,-1,sizeof(x)) #define clr80(x)memset(x,0x80,sizeof(x)) #define clr7F(x)memset(x,0x7F,sizeof(x)) #define ll long long #ifdef __unix__ #define LLD \"%lld\" #else #define LLD \"%I64d\" #endif #define pii pair<int,int> #define pip pair<int,pii> #define vi vector<int> #define vpi vector<pii> #define pq priority_queue template<typename T>inline bool chkmin(T&a,T b){return a>b?a=b,1:0;} template<typename T>inline bool chkmax(T&a,T b){return a<b?a=b,1:0;} #define modadd(a,b,c)(((a)+(b))%(c)) #define modmul(a,b,c)((int)(((ll)(a)*(b))%(c))) #define P 1000000007 #define getint(x){\\\\ char __next__char__;bool __nega__int__=0;\\\\ while(!isdigit(__next__char__=getchar())&&__next__char__!=\\'-\\');\\\\ __next__char__==\\'-\\'?(x=0,__nega__int__=1):(x=__next__char__-48);\\\\ while(isdigit(__next__char__=getchar()))x=x*10+__next__char__-48;\\\\ if(__nega__int__)x=-x;\\\\ } #define getint2(x1,x2){getint(x1);getint(x2);} #define getint3(x1,x2,x3){getint(x1);getint(x2);getint(x3);} #define getint4(x1,x2,x3,x4){getint(x1);getint(x2);getint(x3);getint(x4);} #define getint5(x1,x2,x3,x4,x5){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);} #define getint6(x1,x2,x3,x4,x5,x6){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);getint(x6);} char strr[200][200]; int f[26],b[26],e[26],l[200],s[26]; bool v[26]; bool check(int i){ char*str=strr[i]; clr(v); for(int j=l[i]-1;j--;){ if(str[j]!=str[j+1]){ if(v[str[j+1]-\\'a\\'])return 0; v[str[j+1]-\\'a\\']=1; } } return !v[str[0]-\\'a\\']; } int F[26]; int fa(int x){ int r=F[x],y=r; while(r!=F[r])r=F[r]; while((F[x]=r)!=(x=y))y=F[y]; return r; } int run(){ int n,ans=1; getint(n); clr(f); clr(b); clr(e); clr(s); for(int i=26;i--;)F[i]=i; for(int i=-1;++i!=n;){ clr(v); scanf(\"%s\",strr[i]); l[i]=strlen(strr[i]); char*str=strr[i]; if(str[0]==str[l[i]-1]){ e[str[0]-\\'a\\']++; ans=(ll)ans*e[str[0]-\\'a\\']%P; }else{ int x=fa(str[0]-\\'a\\'); int y=fa(str[l[i]-1]-\\'a\\'); if(x==y)return 0; F[x]=y; if(f[str[0]-\\'a\\']++){ return 0; } if(b[str[l[i]-1]-\\'a\\']++){ return 0; } } for(int j=l[i];j--;)v[str[j]-\\'a\\']=1; for(int j=26;j--;)s[j]+=v[j]; } for(int i=-1;++i!=n;){ char*str=strr[i]; if(!check(i)){ return 0; } for(int j=l[i];j--;) if(str[j]!=str[l[i]-1]&&str[j]!=str[0]){ if(s[str[j]-\\'a\\']>1)return 0; } } int q=0; for(int i=26;i--;){ if((e[i]||b[i])&&F[i]==i)q++; } while(q){ ans=(ll)ans*q%P; q--; } return ans; } int main(){ int T; getint(T); for(int t=1;t<=T;t++){ printf(\"Case #%d: %d\\ \",t,run()); } return 0; } '"}
{"code1": "def withoutDuplication(s): res = [] prev = -1 for c in s: i = ord(c) - ord(\\'a\\') if i != prev: res.append(i) prev = i return res mod = 1000000007 def fact(n): if n <= 1: return 1 return n*fact(n-1)%mod def solve(strs): n = 26 inE, outE, midE, badE = [0]*n, [0]*n, [0]*n, [0]*n g = [-1]*n for s in strs: letters = withoutDuplication(s) if len(letters) == 1: midE[letters[0]] += 1 else: outE[letters[0]] += 1 inE[letters[-1]] += 1 g[letters[0]] = letters[-1] for c in letters[1:-1]: badE[c] += 1 # print inE[:4], outE[:4], midE[:4], badE[:4], g[:4] for i in xrange(n): if badE[i] > 0 and inE[i] + outE[i] + midE[i] + badE[i] > 1: return 0 if inE[i] > 1 or outE[i] > 1: return 0 seen, nc = [False]*n, 0 for i in xrange(n): if seen[i] or inE[i] != 0: continue if outE[i] + midE[i] > 0: nc += 1 t = i while t != -1: seen[t] = True t = g[t] if len(filter(None, seen)) < n: return 0 #print nc res = fact(nc) for i in xrange(26): res *= fact(midE[i]) return res%mod T = int(raw_input()) for z in xrange(T): n = int(raw_input()) s = raw_input().strip().split(\\' \\') print \"Case #%d: %s\" % (z+1, solve(s))'", "code2": "#include <cstdlib> #include <cctype> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <vector> #include <string> #include <iostream> #include <sstream> #include <map> #include <set> #include <queue> #include <functional> using namespace std; typedef long long int64; #define PB push_back #define MP make_pair #define debug(x) cout<<(#x)<<\": \"<<(x)<<endl #define REP(i,n) for(int i=0;i<(n);++i) #define FOR(i,l,h) for(int i=(l);i<=(h);++i) #define FORD(i,h,l) for(int i=(h);i>=(l);--i) #define MOD 1000000007 inline int ADD(int a, int b) { a+=b; if (a>=MOD) a-=MOD; return (int)a; } inline void ADDTO(int &a, int b) { a+=b; if (a>=MOD) a-=MOD; } inline void SUBTO(int &a, int b) { a-=b; if (a<0) a+=MOD; } inline int MUL(int a, int b) { return (int)((int64)a*b%MOD); } int loop[30], indeg[30], oudeg[30], e[30][30], vis[30]; int fact[110], ans; void addEdge(char a, char b) { int u = a - \\'a\\', v = b - \\'a\\'; ++oudeg[u]; ++indeg[v]; e[u][v] = 1; } void dfs(int u) { vis[u] = 1; ans = MUL(ans, fact[loop[u]]); if (oudeg[u] > 0) { REP(v, 26) if (e[u][v] == 1) dfs(v); } } int main() { int tN; cin >> tN; fact[0] = 1; FOR(i, 1, 100) fact[i] = MUL(i, fact[i-1]); FOR(cN, 1, tN) { memset(loop, 0, sizeof(loop)); memset(indeg, 0, sizeof(indeg)); memset(oudeg, 0, sizeof(oudeg)); memset(e, 0, sizeof(e)); memset(vis, 0, sizeof(vis)); int n; cin >> n; REP(i, n) { string s; cin >> s; bool same = 1; REP(i, s.size()) { if (s[i] != s[0]) same = 0; if (i && s[i] != s[i-1]) addEdge(s[i-1], s[i]); } if (same) ++loop[s[0] - \\'a\\']; } bool nosol = 0; REP(i, 26) if (indeg[i] > 1 || oudeg[i] > 1) nosol = 1; if (!nosol) { ans = 1; int ncc = 0; REP(i, 26) if (!vis[i] && indeg[i] == 0) { if (oudeg[i] > 0 || loop[i] > 0) ++ncc; dfs(i); } ans = MUL(ans, fact[ncc]); REP(i, 26) if (!vis[i]) nosol = 1; } printf(\"Case #%d: \", cN); if (nosol) puts(\"0\"); else printf(\"%d\\ \", ans); } } '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; namespace CodeJam { internal class TestCase { public string[] Cars; } internal class Pair { public char First { get; set; } public char Last { get; set; } } internal class Program { private const string testFileName = \"B-large\"; private const int Base = 1000000007; public static IEnumerable<TestCase> ParseCases(TextReader reader) { var testCaseCount = int.Parse(reader.ReadLine()); for (var i = 0; i < testCaseCount; i++) { var carCount = int.Parse(reader.ReadLine()); var cars = reader.ReadLine().Split(); yield return new TestCase { Cars = cars }; } } private static long Solve(TestCase testCase) { // 3 types of cars // single letters: aaa // two letters: aabb // multiple letters aabcddd // simplify consecutive letters var withoutRuns = testCase.Cars.Select(RemoveConsecutive).ToArray(); var singleLetters = withoutRuns.Where(c => c.Length == 1).Select(c => c[0]).ToArray(); var hiddenLetters = withoutRuns.Where(c => c.Length > 2).SelectMany(c => c.Substring(1, c.Length - 2)).Distinct().ToArray(); var pairs = withoutRuns.Where(c => c.Length > 1).Select(c => new Pair { First = c[0], Last = c[c.Length - 1] }).ToArray(); // eliminate case 3 now if (pairs.Any(p => hiddenLetters.Contains(p.First) || hiddenLetters.Contains(p.Last)) || singleLetters.Any(hiddenLetters.Contains)) return 0; // we know just have to find orderings for pairs and single letters. // check that all the pairs can be ordered successfully if (pairs.Select(p => p.First).Distinct().Count() != pairs.Count() || pairs.Select(p => p.Last).Distinct().Count() != pairs.Count()) return 0; //check the groups that have an order imposed on them by the pairs var sortedPairs = GetFixedChains(pairs); if (sortedPairs == null) return 0; var singleLetterCounts = singleLetters.GroupBy(c => c, (key, values) => Tuple.Create(key, values.Count())); var lettersInChains = sortedPairs.SelectMany(p => p).SelectMany(p => new[] { p.First, p.Last }).Distinct(); var independentSingleLetters = singleLetters.Except(lettersInChains).ToArray(); // single letters can be in any order relative to each other long combinations = 1; foreach (var pair in singleLetterCounts) { combinations *= Factorial(pair.Item2); combinations %= Base; } // chains can be in any order relative to each other, and to the independent letters var independentBlockCount = independentSingleLetters.Count() + sortedPairs.Length; combinations *= Factorial(independentBlockCount); combinations %= Base; return combinations; } private static long Factorial(int x) { long fact = 1; while (x > 1) { fact *= x; fact %= Base; x--; } return fact; } private static Pair[][] GetFixedChains(Pair[] pairs) { var remainingPairs = pairs.ToList(); var sorted = new List<Pair[]>(); while (remainingPairs.Count > 0) { var chain = new List<Pair>(); var current = remainingPairs[0]; remainingPairs.RemoveAt(0); chain.Add(current); int index; var first = current; while ((index = remainingPairs.FindIndex(p => p.Last == first.First)) >= 0) { first = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Insert(0, first); } var last = current; while ((index = remainingPairs.FindIndex(p => p.First == last.Last)) >= 0) { last = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Add(last); } if (last.Last == first.First) return null; sorted.Add(chain.ToArray()); } return sorted.ToArray(); } private static string RemoveConsecutive(string arg) { var builder = new StringBuilder(arg.Length); char current = \\'\\\\0\\'; foreach (var c in arg) { if (c != current) { builder.Append(c); current = c; } } return builder.ToString(); } private static void Main(string[] args) { TestCase[] cases; using (var reader = new StreamReader(testFileName + \".in\")) using (var writer = new StreamWriter(testFileName + \".out\")) { cases = ParseCases(reader).ToArray(); for (int caseIndex = 0; caseIndex < cases.Length; caseIndex++) { var testCase = cases[caseIndex]; var solution = Solve(testCase); writer.WriteLine(\"Case #{0}: {1}\", caseIndex + 1, solution); } } } } }'", "code2": "#include <stdio.h> #include <stdlib.h> #include <string.h> #define M 1000000007LL //char *train[10]; int N; int count; int embedded[26]; int oneletter[26]; int endswith[26]; int startswith[26]; int impossible=0; int used; int segment; char *destutter(char *s) { static char buf2[200]; char *d=buf2; char last=0; while (*s) { if (*s!=last) last=*d++ = *s; s++; } *d=0; return buf2; } void readtrains(void) { int i,len,j; static char buff[200]; char *b; impossible=0; scanf(\"%d\",&N); for (i=0;i<26;i++) { embedded[i]=0; oneletter[i]=0; endswith[i]=-1; startswith[i]=-1; } for (i=0;i<N;i++) { scanf(\"%s\",buff); b=destutter(buff); len=strlen(b); if (len==1) { oneletter[*b-\\'a\\']++; continue; } if (startswith[*b-\\'a\\']>=0) impossible++; if (endswith[b[len-1]-\\'a\\']>=0) impossible++; startswith[*b-\\'a\\']=b[len-1]-\\'a\\'; endswith[b[len-1]-\\'a\\']=*b-\\'a\\'; for (j=1;j<len-1;j++) embedded[b[j]-\\'a\\']++; } } int modtimes(int a, int b) { return (int)((1LL*a*b) % M); } int factorial(int n) { int f=1; int i; if (n<=1) return 1; for (i=2;i<=n;i++) f=modtimes(f,i); return f; } void countonlyi(int i) { segment++; //printf(\"countonly %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); } void countendi(int i) { segment++; //printf(\"countend %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! while (1) { if ((1<<i) & used) {impossible++;return;} used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); i=endswith[i]; if (i<0) break; } } void countstarti(int i) { int used2=1<<i; //printf(\" Cs %c\\ \",i+\\'a\\'); while (startswith[i]>=0) { i=startswith[i]; //printf(\" cs %c\\ \",i+\\'a\\'); if (used2 & (1<<i)) { //printf(\"imp\\ \"); impossible++;return; } used2|=1<<i; } countendi(i); } void counttrains(void) { int i; count=1; used=0; segment=0; for (i=0;i<26;i++) { if (impossible || embedded[i]>1 || embedded[i] && (startswith[i]>=0 || endswith[i]>=0)) { printf(\"0\\ \"); //impossible return; } } i=0; while (i<26 && !impossible) { if (startswith[i]>=0 && !((1<<i) & used)) countstarti(i); if (endswith[i]>=0 && !((1<<i) & used)) countendi(i); if (oneletter[i]>0 && !((1<<i) & used)) countonlyi(i); i++; } if (impossible) printf(\"0\\ \"); else printf(\"%d\\ \",count); } void dump(void) { int i; printf(\"\\ \"); for (i=0;i<26;i++) { if (startswith[i]<0 && endswith[i]<0 && embedded[i]==0 && oneletter[i]==0) continue; printf(\" %c : ->%c %c<- em=%d 1L=%d\\ \",i+\\'a\\',startswith[i]+\\'a\\',endswith[i]+\\'a\\',embedded[i],oneletter[i]); } } int main(int argc, char **argv) { int tc,i; scanf(\"%d\",&tc); for (i=1;i<=tc;i++) { printf(\"Case #%d: \",i); readtrains(); //dump(); counttrains(); } return 0; } '"}
{"code1": "// uses http://introcs.cs.princeton.edu/java/stdlib/StdIn.java public class Train { static final int MOD = 1_000_000_007; public static long calc(String[] cars) { long result = 1; int n = cars.length; for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) { //System.out.println(java.util.Arrays.toString(cars)); int solocount = 0; int start = -1; int mid = -1; int end = -1; int solo = -1; for (int i=0; i<n; i++) { if (cars[i] == null) { } else if (cars[i].matches(\"\"+ch+\\'+\\')) { solocount++; result *= solocount; result %= MOD; cars[i] = null; solo = i; } else if (cars[i].matches(ch+\"+[^\"+ch+\"]+\")) { if (start != -1) return 0; start = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+\")) { if (end != -1) return 0; end = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+[^\"+ch+\"]+\")) { if (mid != -1) return 0; mid = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\")) { } else return 0; } //System.out.println(ch+\" \"+solocount+\" \"+start+\" \"+solo+\" \"+end+\" \"+result); if (mid == -1 && solocount == 0 && start == -1 && end == -1) continue; if (mid != -1 && (solocount > 0 || start != -1 || end != -1)) return 0; if (mid != -1) continue; String repl = \"\"; if (end != -1) {repl += cars[end]; cars[end] = null;} if (solo != -1) repl += ch; if (start != -1) {repl += cars[start]; cars[start] = null;} if (start != -1) {cars[start] = repl;} else if (solo != -1) {cars[solo] = repl;} else cars[end] = repl; } int left = 0; for (String s : cars) if (s != null) { left ++; result *= left; result %= MOD; } return result; } public static void main(String[] args) { int q = StdIn.readInt(); for (int j=1; j<=q; j++) { int n = StdIn.readInt(); String[] cars = new String[n]; { for (int i=0; i<n; i++) cars[i] = StdIn.readString(); } System.out.printf(\"Case #%d: %d\\ \", j, calc(cars)); } } } '", "code2": "import static java.lang.Math.*; import java.io.*; import java.math.*; import java.util.*; public class ProblemBLarge { static class Car { String s; LinkedHashMap<Character, Long> numAddedSameCharCars = new LinkedHashMap<Character, Long>(); char getFirst() { return s.charAt(0); } char getLast() { return s.charAt(s.length() - 1); } void addAllSameChars(Car car) { for (Map.Entry<Character, Long> entry : car.numAddedSameCharCars.entrySet()) { Character key = entry.getKey(); Long value = numAddedSameCharCars.get(key); if (value == null) value = 0L; value += entry.getValue(); numAddedSameCharCars.put(key, value); } } @Override public String toString() { return \"\"+s+\" (\"+numAddedSameCharCars+\")\"; } } public class Case { LinkedHashSet<Car> cars = new LinkedHashSet<Car>(); LinkedHashSet<Car> carsToCheck = new LinkedHashSet<Car>(); public void solve(int caseIndex) { for (Car car : cars) { if (isSameCharCar(car)) { car.numAddedSameCharCars.put(car.s.charAt(0), 1L); } } // System.out.println(\"Cars: \"+cars); carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); // LinkedHashSet<Car> carsWithSameChar = new LinkedHashSet<Car>(); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); if (isSameCharCar(car)) { for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } } carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } BigInteger result; if (!isValid()) { result = BigInteger.valueOf(0); } else { long mod = 1000000007L; result = BigInteger.valueOf(1); for (long i = 1; i <= cars.size(); i++) { result = result.multiply(BigInteger.valueOf(i)); } for (Car car : cars) { for (Long sameChars : car.numAddedSameCharCars.values()) { long a = 1; for (long i = 1; i <= sameChars; i++) { a *= i; a %= mod; } result = result.multiply(BigInteger.valueOf(a)); } } result = result.mod(BigInteger.valueOf(mod)); } // long result; // if (!isValid()) { // result = 0; // } // else { // long mod = 1000000007L; // // result = 1; // for (long i = 1; i <= cars.size(); i++) { // result *= i; // result %= mod; // } // // for (Car car : cars) { // for (Long sameChars : car.numAddedSameCharCars.values()) { // long a = 1; // for (long i = 1; i <= sameChars; i++) { // a *= i; // a %= mod; // } // result *= a; // result %= mod; // } // } // } println(\"Case #\" + (caseIndex + 1) + \": \" + result); } void combineCars(Car car1, Car car2) { Car car = new Car(); car.s = car1.s + car2.s; car.addAllSameChars(car1); car.addAllSameChars(car2); // car.numAddedSameCharCars = car1.numAddedSameCharCars + car2.numAddedSameCharCars; cars.add(car); carsToCheck.add(car); cars.remove(car1); carsToCheck.remove(car1); cars.remove(car2); carsToCheck.remove(car2); // System.out.println(\"Cars: \"+cars); } boolean isSameCharCar(Car car) { String s = car.s; for (int k = 0; k < s.length(); k++) { if (s.charAt(k) != s.charAt(0)) { return false; } } return true; } boolean isValid() { LinkedHashSet<Character> processed = new LinkedHashSet<>(); Character last = null; for (Car car : cars) { String s = car.s; for (int k = 0; k < s.length(); k++) { char ch = s.charAt(k); // System.out.println(\"Current: \"+ch); if (last != null && last.charValue() == ch) { // System.out.println(\"Last: \"+last+\", processed: \"+processed); } else { if (processed.contains(ch)) return false; processed.add(ch); } last = ch; } } return true; } long factorial(long p) { long result = 1; for (long i = 2; i <= p; i++) result *= i; return result; } } public void run() throws Exception { BufferedReader r = new BufferedReader(new FileReader(\"input.txt\")); int numCases = new InputParser(r.readLine()).readInt(); for (int caseIndex = 0; caseIndex < numCases; caseIndex++) { Case c = new Case(); InputParser p = new InputParser(r.readLine()); int numCars = p.readInt(); p = new InputParser(r.readLine()); for (int i = 0; i < numCars; i++) { Car car = new Car(); car.s = p.readToken(); c.cars.add(car); } c.solve(caseIndex); } r.close(); } public static void main(String[] args) throws Exception { fileWriter = new PrintWriter(new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"output.txt\")))); new ProblemBLarge().run(); fileWriter.close(); } public static class InputParser { String text; int pos; public InputParser(String text) { this.text = text; } public void skipSpaces() { while (pos < text.length()) { if (text.charAt(pos) != \\' \\') break; pos++; } } public String readUntil(char expectedChar) { StringBuilder b = new StringBuilder(); while (pos < text.length()) { char ch = text.charAt(pos); if (ch == expectedChar) break; b.append(ch); pos++; } return b.toString(); } public String readToken() { skipSpaces(); return readUntil(\\' \\'); } public int readInt() { return Integer.parseInt(readToken()); } public long readLong() { return Long.parseLong(readToken()); } public double readDouble() { return Double.parseDouble(readToken()); } public char readChar() { char ch = text.charAt(pos); pos++; return ch; } public void readExpectedString(String s) { for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (readChar() != ch) throw new RuntimeException(\"Expected: \"+ch); } } } public static PrintWriter fileWriter; public static void print(String text) { fileWriter.print(text); System.out.print(text); } public static void println(String text) { fileWriter.println(text); System.out.println(text); } public static <Key, Value> void addToMultiMapArrayList(Key key, Value value, Map<Key, ArrayList<Value>> map) { ArrayList<Value> list = map.get(key); if (list == null) { list = new ArrayList<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> void addToMultiMapLinkedHashSet(Key key, Value value, Map<Key, LinkedHashSet<Value>> map) { LinkedHashSet<Value> list = map.get(key); if (list == null) { list = new LinkedHashSet<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> ArrayList<Value> getMultiMapValues(Map<Key, Collection<Value>> map) { ArrayList<Value> result = new ArrayList<Value>(); for (Collection<Value> list : map.values()) { result.addAll(list); } return result; } // binarySearch(, , 0.000000001, new Function<Double, Integer>() { // public Integer evaluate(Double key) { // return ; // } // }); public static double binarySearch(double low, double high, double precision, Function<Double, Integer> f) { if (high < low) throw new RuntimeException(\"High (\"+high+\") cannot be smaller than low (\"+low+\")\"); { int lowValue = f.evaluate(low); if (lowValue == 0) return low; if (lowValue > 0) throw new RuntimeException(\"Unsuitable low: \"+low); } { int highValue = f.evaluate(high); if (highValue == 0) return high; if (highValue < 0) throw new RuntimeException(\"Unsuitable high: \"+high); } while (true) { double mid = (low + high) * 0.5; if (abs(high - low) < precision) { return mid; } int c = f.evaluate(mid); if (c < 0) low = mid; else if (c > 0) high = mid; else return mid; } } public static <T> LinkedHashSet<T> intersection(Set<T> s1, Set<T> s2) { if (s2.size() < s1.size()) { Set<T> temp = s1; s1 = s2; s2 = temp; } LinkedHashSet<T> result = new LinkedHashSet<T>(); for (T o : s1) { if (s2.contains(o)) result.add(o); } return result; } public static interface Function<Key, Value> { public Value evaluate(Key key); } public static class Int2 { int x, y; public Int2(int x, int y) { this.x = x; this.y = y; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Int2 other = (Int2) obj; if (x != other.x) return false; if (y != other.y) return false; return true; } @Override public String toString() { return \"(\"+x+\",\"+y+\")\"; } } } '"}
{"code1": "#include <iostream> #include <fstream> #include <string> #include <algorithm> #include <cstdlib> #include <cstring> #include <set> #include <map> #include <vector> #include <stack> #include <queue> #include <deque> #include <iomanip> #include <cassert> typedef long long ll; typedef unsigned long long ull; using namespace std; bool is_aaa(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] != c) return false; } return true; } bool is_aax(const string& s, char c) { return s[0] == c; } bool is_yaa(const string& s, char c) { return s[(int)s.size() - 1] == c; } bool is_uav(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] == c) return true; } return false; } int fragment_count(const string& s, char c) { int result = 0; int n = (int)s.size(); int i = 0; while (i < n) { if (s[i] != c) i++; else { int j = i; while (j + 1 < n && s[j + 1] == c) j++; result++; i = j + 1; } } return result; } const int MAXN = 109; int N; string s[MAXN]; vector<string> pieces; const ll MOD = 1000000007; ll fact[MAXN]; ll solve(void) { pieces.clear(); for (int i = 0; i < N; i++) pieces.push_back(s[i]); ll result = 1; for (char c = \\'a\\'; c <= \\'z\\'; c++) { vector<string> aaa; vector<string> aax; vector<string> yaa; vector<string> uav; vector<string> other; for (int i = 0; i < pieces.size(); i++) { if (is_aaa(pieces[i], c)) aaa.push_back(pieces[i]); else if (is_aax(pieces[i], c)) aax.push_back(pieces[i]); else if (is_yaa(pieces[i], c)) yaa.push_back(pieces[i]); else if (is_uav(pieces[i], c)) uav.push_back(pieces[i]); else other.push_back(pieces[i]); } if (uav.size() != 0) { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0 && uav.size()==1 && fragment_count(uav[0], c)==1) { ; } else return 0LL; } else { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0) { ; // no constraints at all } else { if (yaa.size() <= 1 && aax.size() <= 1) { if (yaa.size() == 1) { if (fragment_count(yaa[0], c) > 1) return 0LL; } if (aax.size() == 1) { if (fragment_count(aax[0], c) > 1) return 0LL; } result *= fact[aaa.size()]; result %= MOD; pieces = other; string new_piece; if (yaa.size() != 0) new_piece += yaa[0]; for (int i = 0; i < aaa.size(); i++) new_piece += aaa[i]; if (aax.size() != 0) new_piece += aax[0]; pieces.push_back(new_piece); } else return 0LL; } } } result *= fact[pieces.size()]; result %= MOD; return result; } void solve_B(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; fact[0] = 1LL; for (int i = 1; i < MAXN; i++) fact[i] = (fact[i - 1] * i) % MOD; for (int tt = 1; tt <= T; tt++) { for (int i = 0; i < MAXN; i++) s[i] = \"\"; in >> N; for (int i = 0; i < N; i++) in >> s[i]; ll temp = solve(); out << \"Case #\" << tt << \": \"; out << temp; out << \\'\\ \\'; } in.close(); out.close(); } int main() { //solve_A(); solve_B(); //solve_C(); return 0; } void solve_(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; for (int tt = 1; tt <= T; tt++) { out << \"Case #\" << tt << \": \"; } in.close(); out.close(); }'", "code2": "import java.util.HashSet; import java.util.Scanner; import java.util.Set; public class B { static final long BASE = 1000000007; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int cases = sc.nextInt(); long[] factorial = new long[101]; factorial[0] = 1; for (int i = 1; i < 101; i++) { factorial[i] = (factorial[i - 1] * i) % BASE; } for (int caseNum = 1; caseNum <= cases; caseNum++) { int N = sc.nextInt(); String[] cars = new String[N]; Set<Character> interior = new HashSet<Character>(); int[] singleLetterStrs = new int[26]; int[] starts = new int[26]; int[] ends = new int[26]; char[] next = new char[26]; boolean possible = true; for (int i = 0; i < N; i++) { cars[i] = sc.next(); int firstChar = cars[i].charAt(0) - \\'a\\'; char lastChar = cars[i].charAt(cars[i].length() - 1); if (isSingleLetter(cars[i])) { int index = firstChar; singleLetterStrs[index]++; } else { for (Character ch : getInteriorChars(cars[i])) { if (interior.contains(ch)) { possible = false; break; } interior.add(ch); } starts[firstChar]++; ends[lastChar - \\'a\\']++; next[firstChar] = lastChar; } } int numGroups = 0; for (int i = 0; i < 26; i++) { if (!possible) { break; } char ch = (char) (\\'a\\' + i); if (interior.contains(ch) && (singleLetterStrs[i] + starts[i] + ends[i] > 0)) { possible = false; } if (starts[i] > 1 || ends[i] > 1) { possible = false; } if (singleLetterStrs[i] > 0 && starts[i] == 0 && ends[i] == 0) { numGroups++; } else if (starts[i] == 1 && ends[i] == 0) { numGroups++; } } possible = possible && !hasCycles(next); System.out.print(\"Case #\" + caseNum + \": \"); if (!possible) { System.out.println(0); continue; } long ways = 1; for (int i = 0; i < 26; i++) { ways = (ways * factorial[singleLetterStrs[i]]) % BASE; } ways = (ways * factorial[numGroups]) % BASE; System.out.println(ways); } } private static boolean hasCycles(char[] next) { for (int i = 0; i < 26; i++) { if (next[i] == 0) { continue; } char start = (char) (\\'a\\' + i); int currIndex = i; while (next[currIndex] != 0 && next[currIndex] != start) { currIndex = next[currIndex] - \\'a\\'; } if (next[currIndex] == start) { return true; } } return false; } private static Set<Character> getInteriorChars(String str) { Set<Character> chars = new HashSet<Character>(); if (isSingleLetter(str)) { return chars; } int startIndex = 0; while (str.charAt(startIndex + 1) == str.charAt(0)) { startIndex++; } int endIndex = str.length() - 1; while (str.charAt(endIndex - 1) == str.charAt(str.length() - 1)) { endIndex--; } for (int i = startIndex + 1; i < endIndex; i++) { chars.add(str.charAt(i)); } return chars; } private static boolean isSingleLetter(String str) { char ch = str.charAt(0); for (int i = 1; i < str.length(); i++) { if (str.charAt(i) != ch) { return false; } } return true; } } '"}
{"code1": "#include <stdio.h> #include <stdlib.h> #include <math.h> #include <ctype.h> #include <string.h> int TC, T; int Cars; char Car[120][120]; char Visited[130]; int Stack[120]; int Used[120]; int i, x, y, L, Ans; char Last; int DFS(int Level){ if (Level==Cars){ int i, x; Last = Car[Stack[0]][0]; memset(Visited, 0, sizeof(Visited)); Visited[Last] = 1; for (i=0; i<Cars; i++){ L = strlen(Car[Stack[i]]); for (x=0; x<L; x++){ if (Car[Stack[i]][x]==Last) continue; if (Visited[Car[Stack[i]][x]]) return ; Visited[Car[Stack[i]][x]] = 1; Last = Car[Stack[i]][x]; } } Ans++; return ; } int i; for (i=0; i<Cars; i++) if (!Used[i]){ Used[i] = 1; Stack[Level] = i; DFS(Level+1); Used[i] = 0; } } int main(){ freopen(\"B-small-attempt0.in\", \"r\", stdin); freopen(\"B-small-attempt0.out\", \"w\", stdout); scanf(\"%d\", &TC); for (T=1; T<=TC; T++){ printf(\"Case #%d: \", T); scanf(\"%d\", &Cars); for (i=0; i<Cars; i++) scanf(\"%s\", Car[i]); Ans = 0; DFS(0); printf(\"%d\\ \", Ans); } return 0; } '", "code2": "#!/usr/bin/pypy import itertools,math,sys def simple_solve(N,S): S = sorted(S) cnt = 0 for perm in itertools.permutations(S): z = \"\".join(perm) chars = [False for _ in range(26)] last = \\'\\' for c in z: if last==c: continue last = c if chars[ord(c)-ord(\\'a\\')]: break chars[ord(c)-ord(\\'a\\')] = True else: cnt += 1 return cnt def true_solve(N,S): rz = {} for c in range(26): char = chr(c+ord(\\'a\\')) cnt_inside = cnt_left = cnt_right = cnt_full = 0 left_char = right_char = \"\" for z in S: h = False last = \"\" for x in z: if x==char and h and last != char: return 0 if x==char: h = True last = x if z[0] == z[-1] == char: cnt_full += 1 elif z[0] == char: cnt_left += 1 right_char = z[-1] elif z[-1] == char: cnt_right += 1 left_char = z[0] elif h: cnt_inside += 1 if cnt_inside > 1 or cnt_inside > 0 and cnt_left+cnt_right+cnt_full>0 or cnt_left>1 or cnt_right>1: return 0 if cnt_inside == 0 and cnt_left+cnt_right+cnt_full>0: rz[char] = ((left_char,right_char,math.factorial(cnt_full))) blocks = 0 bb = 1 while rz: for c,v in rz.items(): if v[0]==\"\": break else: return 0 del rz[c] bb *= v[2] while v[1] != \"\": if v[1] not in rz: return 0 v = rz.pop(v[1]) bb *= v[2] blocks += 1 return math.factorial(blocks)*bb%1000000007 def solve(): N = int(raw_input()) S = raw_input().strip().split() val1 = true_solve(N,S) #val2 = simple_solve(N,S) #if val1 != val2: # print \"Bad\" # print N,S # print val1,val2 # sys.exit(1) return val1 T = int(raw_input()) for t in range(1,T+1): print \"Case #%d:\"%t,solve() '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Linq; using System.Numerics; using System.Text; using System.Threading.Tasks; namespace GCJ2014R1CB { class Program { /// <summary> /// \\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe6\\x95\\xb0 /// </summary> static int ThreadCount = 1; /// <summary> /// \\xe9\\x80\\xb2\\xe6\\x8d\\x97\\xe3\\x82\\x92\\xe8\\xa1\\xa8\\xe7\\xa4\\xba\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 /// </summary> static bool Verbose = true; static int ProgressInterval = 1; class Solver { public List<string> SolveAll(int threadId, StreamReader sr) { // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ int TestCase = int.Parse(sr.ReadLine()); // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ List<string> outputs = new List<string>(); for (int testCase = 0; testCase < TestCase; testCase++) { // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ int N = int.Parse(sr.ReadLine()); string l = sr.ReadLine(); // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ #region if (testCase % ThreadCount != threadId) { // \\xe3\\x81\\x93\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xae\\xe6\\x8b\\x85\\xe5\\xbd\\x93\\xe3\\x81\\xa7\\xe3\\x81\\xaf\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe3\\x81\\xae\\xe3\\x81\\xa7\\xe8\\xa7\\xa3\\xe3\\x81\\x8b\\xe3\\x81\\xaa\\xe3\\x81\\x84 continue; } if (Verbose) { if (testCase % ProgressInterval == 0) { Console.Error.WriteLine(testCase + \" / \" + TestCase); } } #endregion // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ string output = Solve(testCase, l); // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ outputs.Add(output); } return outputs; } const long Mod = 1000000007; string Solve(int testCase, string l) { if (testCase == -1) { } List<string> ts = l.Split(\\' \\').ToList(); BigInteger ans = 1; for(char c = \\'a\\'; c <= \\'z\\'; c++) { int ct = 0; string ns = \"\"; for(int i = 0; i < ts.Count; i++) { if (ts[i].First() == c && ts[i].Last() == c) { ns += ts[i]; ct++; ans *= ct; ts.RemoveAt(i); i--; } } if (ct > 0) { ts.Add(ns); } } for(;;) { bool f = Update(ts, true); if (f == false) { break; } } for(;;) { bool f = Update(ts, false); if (f == false) { break; } } string all = string.Concat(ts); for(char c = \\'a\\'; c <= \\'z\\'; c++) { int first = all.IndexOf(c); if (first < 0) { continue; } int last = all.LastIndexOf(c); for(int i = first; i < last; i++) { if (all[i] != c) { return \"0\"; } } } for(int i = 1; i <= ts.Count; i++) { ans *= i; } ans %= Mod; return ans.ToString(); } static bool Update(List<string> ts, bool primary) { int N = ts.Count(); for(int i = 0; i < N; i++) { if (primary && ts[i].First() != ts[i].Last()) { continue; } for(int j = 0; j < N; j++) { if (i == j) { continue; } if (ts[i].Last() == ts[j].First()) { ts[i] += ts[j]; ts.RemoveAt(j); return true; } } } return false; } } static void Main(string[] args) { // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\x84\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\x9f\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\xab\\xe5\\xaf\\xbe\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe5\\x87\\xa6\\xe7\\x90\\x86\\xe3\\x82\\x92\\xe8\\xa1\\x8c\\xe3\\x81\\x86\\xe3\\x80\\x82 // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe3\\x82\\xab\\xe3\\x83\\xac\\xe3\\x83\\xb3\\xe3\\x83\\x88\\xe3\\x83\\x87\\xe3\\x82\\xa3\\xe3\\x83\\xac\\xe3\\x82\\xaf\\xe3\\x83\\x88\\xe3\\x83\\xaa\\xe3\\x81\\xae large \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81 // small \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81sample.in \\xe3\\x82\\x92\\xe9\\xa0\\x86\\xe3\\x81\\xab\\xe6\\xa4\\x9c\\xe7\\xb4\\xa2\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 // large \\xe3\\x82\\x84 small \\xe3\\x81\\x8c\\xe8\\xa4\\x87\\xe6\\x95\\xb0\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe5\\x90\\x8d\\xe5\\x89\\x8d\\xe3\\x81\\xa7\\xe3\\x82\\xbd\\xe3\\x83\\xbc\\xe3\\x83\\x88\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe4\\xb8\\x80\\xe7\\x95\\xaa\\xe6\\x9c\\x80\\xe5\\xbe\\x8c\\xe3\\x81\\xae\\xe3\\x82\\x92\\xe4\\xbd\\xbf\\xe3\\x81\\x86\\xe3\\x80\\x82 string inputName = null; if (args.Length > 0) { if (File.Exists(args[0]) == false) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } inputName = args[0]; } if (inputName == null) { List<string> larges = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"large\") && fi.Name.EndsWith(\".in\")) { larges.Add(fi.FullName); } } if (larges.Count > 0) { larges.Sort(); inputName = larges[larges.Count - 1]; } } if (inputName == null) { List<string> smalls = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"small\") && fi.Name.EndsWith(\".in\")) { smalls.Add(fi.FullName); } } if (smalls.Count > 0) { smalls.Sort(); inputName = smalls[smalls.Count - 1]; } } if (inputName == null) { foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.ToLower() == \"sample.in\") { inputName = fi.FullName; break; } } } if (inputName == null) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } // \\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe5\\x85\\x88\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x82\\x92\\xe6\\xb1\\xba\\xe5\\xae\\x9a\\xe3\\x81\\x97\\xe3\\x80\\x81\\xe5\\x90\\x8c\\xe5\\x90\\x8d\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x83\\xaa\\xe3\\x83\\x8d\\xe3\\x83\\xbc\\xe3\\x83\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 string outputName = inputName; if (outputName.EndsWith(\".in\")) { outputName = outputName.Substring(0, outputName.Length - 3); } outputName += \".out\"; if (File.Exists(outputName)) { int rev = 1; while (File.Exists(outputName + \".\" + rev)) { rev++; } File.Move(outputName, outputName + \".\" + rev); } // \\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82ThreadCount == 1 \\xe3\\x81\\xaa\\xe3\\x82\\x89\\xe3\\x80\\x81\\xe7\\x8f\\xbe\\xe5\\x9c\\xa8\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xa7\\xe3\\x80\\x81\\xe3\\x81\\x9d\\xe3\\x82\\x8c\\xe4\\xbb\\xa5\\xe5\\xa4\\x96\\xe3\\x81\\xaa\\xe3\\x82\\x89 Parallel \\xe3\\x81\\xa7\\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 List<string>[] outputs = new List<string>[ThreadCount]; if (ThreadCount == 1) { for (int i = 0; i < ThreadCount; i++) { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } } } else { Parallel.For(0, ThreadCount, i => { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } }); } // \\xe7\\xb5\\x90\\xe6\\x9e\\x9c\\xe3\\x82\\x92\\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82Case # \\xe3\\x81\\xaf\\xe3\\x81\\x93\\xe3\\x81\\x93\\xe3\\x81\\xa7\\xe4\\xbb\\x98\\xe5\\x8a\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 using (StreamWriter sw = new StreamWriter(outputName)) { for (int i = 0; ; i++) { if (outputs[i % ThreadCount].Count > i / ThreadCount) { sw.WriteLine(\"Case #\" + (i + 1) + \": \" + outputs[i % ThreadCount][i / ThreadCount]); } else { break; } } } } } } '", "code2": "#include<stdio.h> #include<stdlib.h> #include<string.h> #define MOD 1000000007LL int t,T,n,N; long long frac[128]; long long C; char s[128][128]; long long ans; char start[128];/*First Letter*/ char end[128];/*Last Letter*/ char blocked[256]; /*Internal characters*/ int first; int tmp; int c; int only_start[256]; int only_end[256]; int loops[256]; int done[256]; int num_frag; char tmp2; char tmp3; int main(){ scanf(\"%d\",&T); frac[0]=1; for(C=1;C<120;C++) frac[C]=(frac[C-1]*C)%MOD; for(t=1;t<=T;t++){ scanf(\"%d\",&N); for(n=1;n<=N;n++){scanf(\"%s\",&s[n][0]);} for(c=0;c<256;c++) { blocked[c]=0; only_start[c]=0; only_end[c]=0; loops[c]=0; } ans=1; for(n=1;n<=N;n++) { tmp=strlen(s[n]); first=1; start[n]=s[n][0]; end[n]=s[n][tmp-1]; for(c=1;c<tmp;c++) { if (s[n][c]!=s[n][c-1]) { if (blocked[s[n][c]]==1) ans=0; if (first==0) { blocked[s[n][c-1]]=1; } first=0; } } if ((start[n]==end[n])&&(first==0)) ans=0; } if (ans==1) { for(n=1;n<=N;n++) { if (blocked[start[n]]==1) ans=0; if (blocked[end[n]]==1) ans=0; } } if (ans==1) { for(n=1;n<=N;n++) { if (start[n]==end[n]) {loops[start[n]]++;} else { only_start[start[n]]++; only_end[end[n]]++; } } for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if (only_start[tmp2]>1) ans=0; if (only_end[tmp2]>1) ans=0; } } if (ans==1) { num_frag=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) num_frag++; if ((only_start[tmp2]==0)&&(only_end[tmp2]==0)&&(loops[tmp2]>0)) num_frag++; ans*=frac[loops[tmp2]]; ans%=MOD; } ans*=frac[num_frag]; ans%=MOD; } /*Detect cycles*/ if (ans!=0) { for(c=0;c<256;c++) done[c]=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) { tmp3=tmp2; do{ for(n=1;n<=N;n++) { if ((start[n]==tmp3)&&(start[n]!=end[n])) break; } done[n]=1; tmp3=end[n]; } while (only_start[tmp3]==1); } } for(n=1;n<=N;n++) { if ((done[n]==0)&&(start[n]!=end[n])) ans=0; } } printf(\"Case #%d: \",t); printf(\"%lld\\ \",ans); } return 0; } '"}
{"code1": "//#pragma comment(linker, \"/STACK:134217728\") #include <iostream> #include <sstream> #include <cstdio> #include <cstdlib> #include <cmath> #include <cctype> #include <cstring> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> #include <numeric> using namespace std; typedef long long Int; typedef pair<int,int> PII; typedef vector<int> VInt; #define FOR(i, a, b) for(i = (a); i < (b); ++i) #define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i) #define CLEAR(a, b) memset(a, b, sizeof(a)) #define SIZE(a) int((a).size()) #define ALL(a) (a).begin(),(a).end() #define PB push_back #define MP make_pair #define MOD 1000000007 string S[256]; int A[256]; int C[256]; int Next[256]; int Prev[256]; int B[256]; Int dfs(int a) { if (a == -1) return 1; B[a] = 1; Int res = 1; int i; FOR(i, 0, C[a]) res = res * (i + 1) % MOD; return res * dfs(Next[a]) % MOD; } Int f(int n) { CLEAR(A, 0); CLEAR(C, 0); CLEAR(Next, -1); CLEAR(Prev, -1); int i, j; FOR(i, 0, n) { char first = S[i].front(); char last = S[i].back(); FOR(j, 1, SIZE(S[i]) - 1) { char mid = S[i][j]; if (A[mid] == 0) ++A[mid]; else return 0; } if (first == last) { if (SIZE(S[i]) == 1) ++C[first]; else return 0; } else { if (Next[first] != -1) return 0; if (Prev[last] != -1) return 0; Next[first] = last; Prev[last] = first; } } FOR(i, 0, 256) if (A[i] != 0 && (C[i] != 0 || Next[i] != -1 || Prev[i] != -1)) return 0; Int res = 1; int cnt = 0; CLEAR(B, 0); FOR(i, 0, 256) if (B[i] == 0 && Prev[i] == -1) { if (C[i] != 0 || Next[i] != -1) ++cnt; res *= dfs(i); res %= MOD; } FOR(i, 0, cnt) res = res * (i + 1) % MOD; FOR(i, 0, 256) if (B[i] == 0) return 0; return res; } int SolveTest(int test) { int n; scanf(\"%d\", &n); int i, j; FOR(i, 0, n) { char buf[128]; scanf(\"%s\", buf); int len = strlen(buf); string s; int prev = 0; FOR(j, 1, len + 1) if (j == len || buf[j] != buf[prev]) { s.push_back(buf[prev]); prev = j; } S[i] = s; } printf(\"Case #%d: %d\\ \", test + 1, int(f(n))); return 0; } int main() { freopen(\"b.in\", \"r\", stdin); freopen(\"b.out\", \"w\", stdout); int T, t; char buf[1 << 7]; gets(buf); sscanf(buf, \"%d\", &T); FOR(t, 0, T) { fprintf(stderr, \"Solving %d/%d\\ \", t + 1, T); SolveTest(t); } return 0; }; '", "code2": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Linq; using System.Text; using System.IO; namespace ProblemA { class Program { static void Main(string[] args) { using (var sr = new StreamReader(@\"..\\\\..\\\\B-small-attempt0.in\")) { using (var sw = new StreamWriter(@\"..\\\\..\\\\B-small-attempt0.out\")) { var T = int.Parse(sr.ReadLine()); for (int t = 1; t <= T; t++) { sr.ReadLine(); var s = sr.ReadLine().Split(); var k = Enumerable.Range(0, s.Length).ToArray(); int res = 0; do { //for (int i = 0; i < k.Length; i++) //{ // Console.Write(k[i]); // Console.Write(\" \"); //} //Console.WriteLine(); //continue; var u = new bool[50]; int i; for (i = 0; i < k.Length; i++) { int j; for (j = 0; j < s[k[i]].Length; j++) { if (u[s[k[i]][j] - \\'a\\']) { if (j > 0) { if (s[k[i]][j - 1] != s[k[i]][j]) { break; } } else { if (s[k[i - 1]][s[k[i - 1]].Length - 1] != s[k[i]][j]) { break; } } } u[s[k[i]][j] - \\'a\\'] = true; } if (j < s[k[i]].Length) { break; } } if (i == k.Length) { res++; } } while (NextPermutation(k)); sw.WriteLine(\"Case #{0}: {1}\", t, res); } } } } private static bool NextPermutation(int[] numList) { /* Knuths 1. Find the largest index j such that a[j] < a[j + 1]. If no such index exists, the permutation is the last permutation. 2. Find the largest index l such that a[j] < a[l]. Since j + 1 is such an index, l is well defined and satisfies j < l. 3. Swap a[j] with a[l]. 4. Reverse the sequence from a[j + 1] up to and including the final element a[n]. */ var largestIndex = -1; for (var i = numList.Length - 2; i >= 0; i--) { if (numList[i] < numList[i + 1]) { largestIndex = i; break; } } if (largestIndex < 0) return false; var largestIndex2 = -1; for (var i = numList.Length - 1; i >= 0; i--) { if (numList[largestIndex] < numList[i]) { largestIndex2 = i; break; } } var tmp = numList[largestIndex]; numList[largestIndex] = numList[largestIndex2]; numList[largestIndex2] = tmp; for (int i = largestIndex + 1, j = numList.Length - 1; i < j; i++, j--) { tmp = numList[i]; numList[i] = numList[j]; numList[j] = tmp; } return true; } } } '"}
{"code1": "import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStream; import java.io.PrintStream; import java.util.*; import static java.lang.Math.*; import static java.util.Arrays.*; import static java.lang.Integer.*; import static java.lang.Character.*; public class B { Scanner scan; public B(Scanner s) { this.scan = s; } String[]A; long brut(char last, boolean[]U,boolean[]L) { long r =0; boolean all=true; for(int i=0;i<A.length;i++){ if(U[i])continue; all=false; boolean[]nl = L.clone(); char lc = \\'#\\'; for(char c:A[i].toCharArray()){ if(nl[c]) { if(lc!=c && !(c==last && c==A[i].charAt(0)))return 0; } nl[c]=true; } U[i]=true; r += brut(A[i].charAt(A[i].length()-1),U, nl); U[i]=false; } if(all)return 1; return r%1000000007; } public String solve() { int n = scan.nextInt(); A = new String[n]; for(int i=0;i<n;i++){ A[i]= \"\";String s =scan.next(); for(int j=0;j<s.length();j++) { if(A[i].length()==0 || A[i].charAt(A[i].length()-1)!=s.charAt(j))A[i]+=s.charAt(j); } System.out.print(A[i] +\" \"); } // System.out.println(); /* long res = brut(\\'#\\', new boolean[n], new boolean[256]); return \"\"+res; */ boolean[]EQ = new boolean[n]; for(int sn=0;sn<n;sn++){ String s = A[sn]; int d=0; boolean[] v = new boolean[256]; for(int i=0;i<s.length();i++){ if(v[s.charAt(i)] && s.charAt(i-1)!=s.charAt(i))return \"0\"; if(!v[s.charAt(i)]) { d++; v[s.charAt(i)]=true; } if(i>0 && s.charAt(i)!=s.charAt(0) && i+1<s.length() && s.charAt(i) !=s.charAt(s.length()-1)){ for(int j=0;j<n;j++){ if(j==sn)continue; for(char c:A[j].toCharArray()) { if(c==s.charAt(i))return \"0\"; } } } } EQ[sn]=d==1; } for(int i=0;i<n;i++)for(int j=0;j<n;j++){ if(i==j)continue; if(EQ[i]||EQ[j])continue; if(A[i].charAt(0)==A[j].charAt(0))return \"0\"; if(A[i].charAt(A[i].length()-1)==A[j].charAt(A[j].length()-1))return \"0\"; } boolean[][]M = new boolean[n][n]; int[]inc = new int[n]; int[]out = new int[n]; int parts =0; for(int i=0;i<n;i++){ if(EQ[i])continue; parts++; for(int j=0;j<n;j++){ if(EQ[j]||i==j)continue; if(A[i].charAt(A[i].length()-1)==A[j].charAt(0)){ M[i][j]=true; inc[j]++; out[i]++; } } } for(int i=0;i<n;i++)if(inc[i]>1||out[i]>1)return \"0\"; int ch=0; boolean cover[]=new boolean[n]; ArrayList<String> seg = new ArrayList<>(); for(int i=0;i<n;i++){ if(EQ[i])continue; if(inc[i]==0 && out[i]==0){ seg.add(A[i].charAt(0)+\"\"+A[i].charAt(A[i].length()-1)); cover[i]=true; } if(inc[i]>0 || out[i]==0)continue; String s =\"\"+A[i].charAt(0); int p =i; cover[p]=true; while(out[p]>0){ for(int j=0;j<n;j++) if(M[p][j]){ p=j; cover[p]=true; } } s+=A[p].charAt(A[p].length()-1); seg.add(s); } for(int i=0;i<n;i++)if(!EQ[i]&&!cover[i])return \"0\"; long res = 1; int free =0; long mod = 1000000007; for(char c = \\'a\\';c<=\\'z\\';c++){ int count=0;boolean att = false; for(int i=0;i<n;i++){ if(EQ[i]){ if(A[i].charAt(0)==c)count++; } } if(count==0)continue; for(int i=0;i<A.length;i++){ String s = A[i]; if(EQ[i])continue; if(s.charAt(0)==c || s.charAt(s.length()-1)==c)att=true; } if(!att && count >0)free++; for(int i=1;i<=count;i++)res = (res*i)%mod; } for(int i=1;i<=seg.size()+free;i++)res = (res*i)%mod; return \"\"+res; } int intLine(){ return parseInt(scan.nextLine()); } public static void main(String[] args) throws Exception{ Locale.setDefault(Locale.US); String cn = B.class.getName(); String sampleName = cn+\"-sample.in\"; String smallName = cn+\"-small-attempt4.in\"; String largeName = cn+\"-large.in\"; String name = largeName; String outName = name.substring(0, name.indexOf(\\'.\\'))+\".out\"; InputStream in = new BufferedInputStream(new FileInputStream(name)); PrintStream out = new PrintStream(new File(outName)); //PrintStream out = System.out; Scanner scan = new Scanner(in); int N = parseInt(scan.nextLine()); for(int c=1;c<=N;c++) { String res = new B(scan).solve(); out.printf(\"Case #%d: %s\\ \",c, res); System.err.println(c + \" done\"); } System.err.println(\"All done\"); } } '", "code2": "//Orz Sevenkplus #include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<ctime> #include<cctype> #include<complex> #include<algorithm> #include<iostream> #include<vector> #include<queue> #include<set> #include<map> #include<bitset> #define un using namespace un std; #define pb push_back #define pf pop_front #define mp make_pair #define c0 first #define c1 second #define sqr(x)((x)*(x)) #define clr(x)memset(x,0,sizeof(x)) #define clr1(x)memset(x,-1,sizeof(x)) #define clr80(x)memset(x,0x80,sizeof(x)) #define clr7F(x)memset(x,0x7F,sizeof(x)) #define ll long long #ifdef __unix__ #define LLD \"%lld\" #else #define LLD \"%I64d\" #endif #define pii pair<int,int> #define pip pair<int,pii> #define vi vector<int> #define vpi vector<pii> #define pq priority_queue template<typename T>inline bool chkmin(T&a,T b){return a>b?a=b,1:0;} template<typename T>inline bool chkmax(T&a,T b){return a<b?a=b,1:0;} #define modadd(a,b,c)(((a)+(b))%(c)) #define modmul(a,b,c)((int)(((ll)(a)*(b))%(c))) #define P 1000000007 #define getint(x){\\\\ char __next__char__;bool __nega__int__=0;\\\\ while(!isdigit(__next__char__=getchar())&&__next__char__!=\\'-\\');\\\\ __next__char__==\\'-\\'?(x=0,__nega__int__=1):(x=__next__char__-48);\\\\ while(isdigit(__next__char__=getchar()))x=x*10+__next__char__-48;\\\\ if(__nega__int__)x=-x;\\\\ } #define getint2(x1,x2){getint(x1);getint(x2);} #define getint3(x1,x2,x3){getint(x1);getint(x2);getint(x3);} #define getint4(x1,x2,x3,x4){getint(x1);getint(x2);getint(x3);getint(x4);} #define getint5(x1,x2,x3,x4,x5){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);} #define getint6(x1,x2,x3,x4,x5,x6){getint(x1);getint(x2);getint(x3);getint(x4);getint(x5);getint(x6);} char strr[200][200]; int f[26],b[26],e[26],l[200],s[26]; bool v[26]; bool check(int i){ char*str=strr[i]; clr(v); for(int j=l[i]-1;j--;){ if(str[j]!=str[j+1]){ if(v[str[j+1]-\\'a\\'])return 0; v[str[j+1]-\\'a\\']=1; } } return !v[str[0]-\\'a\\']; } int F[26]; int fa(int x){ int r=F[x],y=r; while(r!=F[r])r=F[r]; while((F[x]=r)!=(x=y))y=F[y]; return r; } int run(){ int n,ans=1; getint(n); clr(f); clr(b); clr(e); clr(s); for(int i=26;i--;)F[i]=i; for(int i=-1;++i!=n;){ clr(v); scanf(\"%s\",strr[i]); l[i]=strlen(strr[i]); char*str=strr[i]; if(str[0]==str[l[i]-1]){ e[str[0]-\\'a\\']++; ans=(ll)ans*e[str[0]-\\'a\\']%P; }else{ int x=fa(str[0]-\\'a\\'); int y=fa(str[l[i]-1]-\\'a\\'); if(x==y)return 0; F[x]=y; if(f[str[0]-\\'a\\']++){ return 0; } if(b[str[l[i]-1]-\\'a\\']++){ return 0; } } for(int j=l[i];j--;)v[str[j]-\\'a\\']=1; for(int j=26;j--;)s[j]+=v[j]; } for(int i=-1;++i!=n;){ char*str=strr[i]; if(!check(i)){ return 0; } for(int j=l[i];j--;) if(str[j]!=str[l[i]-1]&&str[j]!=str[0]){ if(s[str[j]-\\'a\\']>1)return 0; } } int q=0; for(int i=26;i--;){ if((e[i]||b[i])&&F[i]==i)q++; } while(q){ ans=(ll)ans*q%P; q--; } return ans; } int main(){ int T; getint(T); for(int t=1;t<=T;t++){ printf(\"Case #%d: %d\\ \",t,run()); } return 0; } '"}
{"code1": "def withoutDuplication(s): res = [] prev = -1 for c in s: i = ord(c) - ord(\\'a\\') if i != prev: res.append(i) prev = i return res mod = 1000000007 def fact(n): if n <= 1: return 1 return n*fact(n-1)%mod def solve(strs): n = 26 inE, outE, midE, badE = [0]*n, [0]*n, [0]*n, [0]*n g = [-1]*n for s in strs: letters = withoutDuplication(s) if len(letters) == 1: midE[letters[0]] += 1 else: outE[letters[0]] += 1 inE[letters[-1]] += 1 g[letters[0]] = letters[-1] for c in letters[1:-1]: badE[c] += 1 # print inE[:4], outE[:4], midE[:4], badE[:4], g[:4] for i in xrange(n): if badE[i] > 0 and inE[i] + outE[i] + midE[i] + badE[i] > 1: return 0 if inE[i] > 1 or outE[i] > 1: return 0 seen, nc = [False]*n, 0 for i in xrange(n): if seen[i] or inE[i] != 0: continue if outE[i] + midE[i] > 0: nc += 1 t = i while t != -1: seen[t] = True t = g[t] if len(filter(None, seen)) < n: return 0 #print nc res = fact(nc) for i in xrange(26): res *= fact(midE[i]) return res%mod T = int(raw_input()) for z in xrange(T): n = int(raw_input()) s = raw_input().strip().split(\\' \\') print \"Case #%d: %s\" % (z+1, solve(s))'", "code2": "#include <cstdlib> #include <cctype> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm> #include <vector> #include <string> #include <iostream> #include <sstream> #include <map> #include <set> #include <queue> #include <functional> using namespace std; typedef long long int64; #define PB push_back #define MP make_pair #define debug(x) cout<<(#x)<<\": \"<<(x)<<endl #define REP(i,n) for(int i=0;i<(n);++i) #define FOR(i,l,h) for(int i=(l);i<=(h);++i) #define FORD(i,h,l) for(int i=(h);i>=(l);--i) #define MOD 1000000007 inline int ADD(int a, int b) { a+=b; if (a>=MOD) a-=MOD; return (int)a; } inline void ADDTO(int &a, int b) { a+=b; if (a>=MOD) a-=MOD; } inline void SUBTO(int &a, int b) { a-=b; if (a<0) a+=MOD; } inline int MUL(int a, int b) { return (int)((int64)a*b%MOD); } int loop[30], indeg[30], oudeg[30], e[30][30], vis[30]; int fact[110], ans; void addEdge(char a, char b) { int u = a - \\'a\\', v = b - \\'a\\'; ++oudeg[u]; ++indeg[v]; e[u][v] = 1; } void dfs(int u) { vis[u] = 1; ans = MUL(ans, fact[loop[u]]); if (oudeg[u] > 0) { REP(v, 26) if (e[u][v] == 1) dfs(v); } } int main() { int tN; cin >> tN; fact[0] = 1; FOR(i, 1, 100) fact[i] = MUL(i, fact[i-1]); FOR(cN, 1, tN) { memset(loop, 0, sizeof(loop)); memset(indeg, 0, sizeof(indeg)); memset(oudeg, 0, sizeof(oudeg)); memset(e, 0, sizeof(e)); memset(vis, 0, sizeof(vis)); int n; cin >> n; REP(i, n) { string s; cin >> s; bool same = 1; REP(i, s.size()) { if (s[i] != s[0]) same = 0; if (i && s[i] != s[i-1]) addEdge(s[i-1], s[i]); } if (same) ++loop[s[0] - \\'a\\']; } bool nosol = 0; REP(i, 26) if (indeg[i] > 1 || oudeg[i] > 1) nosol = 1; if (!nosol) { ans = 1; int ncc = 0; REP(i, 26) if (!vis[i] && indeg[i] == 0) { if (oudeg[i] > 0 || loop[i] > 0) ++ncc; dfs(i); } ans = MUL(ans, fact[ncc]); REP(i, 26) if (!vis[i]) nosol = 1; } printf(\"Case #%d: \", cN); if (nosol) puts(\"0\"); else printf(\"%d\\ \", ans); } } '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; namespace CodeJam { internal class TestCase { public string[] Cars; } internal class Pair { public char First { get; set; } public char Last { get; set; } } internal class Program { private const string testFileName = \"B-large\"; private const int Base = 1000000007; public static IEnumerable<TestCase> ParseCases(TextReader reader) { var testCaseCount = int.Parse(reader.ReadLine()); for (var i = 0; i < testCaseCount; i++) { var carCount = int.Parse(reader.ReadLine()); var cars = reader.ReadLine().Split(); yield return new TestCase { Cars = cars }; } } private static long Solve(TestCase testCase) { // 3 types of cars // single letters: aaa // two letters: aabb // multiple letters aabcddd // simplify consecutive letters var withoutRuns = testCase.Cars.Select(RemoveConsecutive).ToArray(); var singleLetters = withoutRuns.Where(c => c.Length == 1).Select(c => c[0]).ToArray(); var hiddenLetters = withoutRuns.Where(c => c.Length > 2).SelectMany(c => c.Substring(1, c.Length - 2)).Distinct().ToArray(); var pairs = withoutRuns.Where(c => c.Length > 1).Select(c => new Pair { First = c[0], Last = c[c.Length - 1] }).ToArray(); // eliminate case 3 now if (pairs.Any(p => hiddenLetters.Contains(p.First) || hiddenLetters.Contains(p.Last)) || singleLetters.Any(hiddenLetters.Contains)) return 0; // we know just have to find orderings for pairs and single letters. // check that all the pairs can be ordered successfully if (pairs.Select(p => p.First).Distinct().Count() != pairs.Count() || pairs.Select(p => p.Last).Distinct().Count() != pairs.Count()) return 0; //check the groups that have an order imposed on them by the pairs var sortedPairs = GetFixedChains(pairs); if (sortedPairs == null) return 0; var singleLetterCounts = singleLetters.GroupBy(c => c, (key, values) => Tuple.Create(key, values.Count())); var lettersInChains = sortedPairs.SelectMany(p => p).SelectMany(p => new[] { p.First, p.Last }).Distinct(); var independentSingleLetters = singleLetters.Except(lettersInChains).ToArray(); // single letters can be in any order relative to each other long combinations = 1; foreach (var pair in singleLetterCounts) { combinations *= Factorial(pair.Item2); combinations %= Base; } // chains can be in any order relative to each other, and to the independent letters var independentBlockCount = independentSingleLetters.Count() + sortedPairs.Length; combinations *= Factorial(independentBlockCount); combinations %= Base; return combinations; } private static long Factorial(int x) { long fact = 1; while (x > 1) { fact *= x; fact %= Base; x--; } return fact; } private static Pair[][] GetFixedChains(Pair[] pairs) { var remainingPairs = pairs.ToList(); var sorted = new List<Pair[]>(); while (remainingPairs.Count > 0) { var chain = new List<Pair>(); var current = remainingPairs[0]; remainingPairs.RemoveAt(0); chain.Add(current); int index; var first = current; while ((index = remainingPairs.FindIndex(p => p.Last == first.First)) >= 0) { first = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Insert(0, first); } var last = current; while ((index = remainingPairs.FindIndex(p => p.First == last.Last)) >= 0) { last = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Add(last); } if (last.Last == first.First) return null; sorted.Add(chain.ToArray()); } return sorted.ToArray(); } private static string RemoveConsecutive(string arg) { var builder = new StringBuilder(arg.Length); char current = \\'\\\\0\\'; foreach (var c in arg) { if (c != current) { builder.Append(c); current = c; } } return builder.ToString(); } private static void Main(string[] args) { TestCase[] cases; using (var reader = new StreamReader(testFileName + \".in\")) using (var writer = new StreamWriter(testFileName + \".out\")) { cases = ParseCases(reader).ToArray(); for (int caseIndex = 0; caseIndex < cases.Length; caseIndex++) { var testCase = cases[caseIndex]; var solution = Solve(testCase); writer.WriteLine(\"Case #{0}: {1}\", caseIndex + 1, solution); } } } } }'", "code2": "#include <stdio.h> #include <stdlib.h> #include <string.h> #define M 1000000007LL //char *train[10]; int N; int count; int embedded[26]; int oneletter[26]; int endswith[26]; int startswith[26]; int impossible=0; int used; int segment; char *destutter(char *s) { static char buf2[200]; char *d=buf2; char last=0; while (*s) { if (*s!=last) last=*d++ = *s; s++; } *d=0; return buf2; } void readtrains(void) { int i,len,j; static char buff[200]; char *b; impossible=0; scanf(\"%d\",&N); for (i=0;i<26;i++) { embedded[i]=0; oneletter[i]=0; endswith[i]=-1; startswith[i]=-1; } for (i=0;i<N;i++) { scanf(\"%s\",buff); b=destutter(buff); len=strlen(b); if (len==1) { oneletter[*b-\\'a\\']++; continue; } if (startswith[*b-\\'a\\']>=0) impossible++; if (endswith[b[len-1]-\\'a\\']>=0) impossible++; startswith[*b-\\'a\\']=b[len-1]-\\'a\\'; endswith[b[len-1]-\\'a\\']=*b-\\'a\\'; for (j=1;j<len-1;j++) embedded[b[j]-\\'a\\']++; } } int modtimes(int a, int b) { return (int)((1LL*a*b) % M); } int factorial(int n) { int f=1; int i; if (n<=1) return 1; for (i=2;i<=n;i++) f=modtimes(f,i); return f; } void countonlyi(int i) { segment++; //printf(\"countonly %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); } void countendi(int i) { segment++; //printf(\"countend %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! while (1) { if ((1<<i) & used) {impossible++;return;} used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); i=endswith[i]; if (i<0) break; } } void countstarti(int i) { int used2=1<<i; //printf(\" Cs %c\\ \",i+\\'a\\'); while (startswith[i]>=0) { i=startswith[i]; //printf(\" cs %c\\ \",i+\\'a\\'); if (used2 & (1<<i)) { //printf(\"imp\\ \"); impossible++;return; } used2|=1<<i; } countendi(i); } void counttrains(void) { int i; count=1; used=0; segment=0; for (i=0;i<26;i++) { if (impossible || embedded[i]>1 || embedded[i] && (startswith[i]>=0 || endswith[i]>=0)) { printf(\"0\\ \"); //impossible return; } } i=0; while (i<26 && !impossible) { if (startswith[i]>=0 && !((1<<i) & used)) countstarti(i); if (endswith[i]>=0 && !((1<<i) & used)) countendi(i); if (oneletter[i]>0 && !((1<<i) & used)) countonlyi(i); i++; } if (impossible) printf(\"0\\ \"); else printf(\"%d\\ \",count); } void dump(void) { int i; printf(\"\\ \"); for (i=0;i<26;i++) { if (startswith[i]<0 && endswith[i]<0 && embedded[i]==0 && oneletter[i]==0) continue; printf(\" %c : ->%c %c<- em=%d 1L=%d\\ \",i+\\'a\\',startswith[i]+\\'a\\',endswith[i]+\\'a\\',embedded[i],oneletter[i]); } } int main(int argc, char **argv) { int tc,i; scanf(\"%d\",&tc); for (i=1;i<=tc;i++) { printf(\"Case #%d: \",i); readtrains(); //dump(); counttrains(); } return 0; } '"}
{"code1": "// uses http://introcs.cs.princeton.edu/java/stdlib/StdIn.java public class Train { static final int MOD = 1_000_000_007; public static long calc(String[] cars) { long result = 1; int n = cars.length; for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) { //System.out.println(java.util.Arrays.toString(cars)); int solocount = 0; int start = -1; int mid = -1; int end = -1; int solo = -1; for (int i=0; i<n; i++) { if (cars[i] == null) { } else if (cars[i].matches(\"\"+ch+\\'+\\')) { solocount++; result *= solocount; result %= MOD; cars[i] = null; solo = i; } else if (cars[i].matches(ch+\"+[^\"+ch+\"]+\")) { if (start != -1) return 0; start = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+\")) { if (end != -1) return 0; end = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+[^\"+ch+\"]+\")) { if (mid != -1) return 0; mid = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\")) { } else return 0; } //System.out.println(ch+\" \"+solocount+\" \"+start+\" \"+solo+\" \"+end+\" \"+result); if (mid == -1 && solocount == 0 && start == -1 && end == -1) continue; if (mid != -1 && (solocount > 0 || start != -1 || end != -1)) return 0; if (mid != -1) continue; String repl = \"\"; if (end != -1) {repl += cars[end]; cars[end] = null;} if (solo != -1) repl += ch; if (start != -1) {repl += cars[start]; cars[start] = null;} if (start != -1) {cars[start] = repl;} else if (solo != -1) {cars[solo] = repl;} else cars[end] = repl; } int left = 0; for (String s : cars) if (s != null) { left ++; result *= left; result %= MOD; } return result; } public static void main(String[] args) { int q = StdIn.readInt(); for (int j=1; j<=q; j++) { int n = StdIn.readInt(); String[] cars = new String[n]; { for (int i=0; i<n; i++) cars[i] = StdIn.readString(); } System.out.printf(\"Case #%d: %d\\ \", j, calc(cars)); } } } '", "code2": "import static java.lang.Math.*; import java.io.*; import java.math.*; import java.util.*; public class ProblemBLarge { static class Car { String s; LinkedHashMap<Character, Long> numAddedSameCharCars = new LinkedHashMap<Character, Long>(); char getFirst() { return s.charAt(0); } char getLast() { return s.charAt(s.length() - 1); } void addAllSameChars(Car car) { for (Map.Entry<Character, Long> entry : car.numAddedSameCharCars.entrySet()) { Character key = entry.getKey(); Long value = numAddedSameCharCars.get(key); if (value == null) value = 0L; value += entry.getValue(); numAddedSameCharCars.put(key, value); } } @Override public String toString() { return \"\"+s+\" (\"+numAddedSameCharCars+\")\"; } } public class Case { LinkedHashSet<Car> cars = new LinkedHashSet<Car>(); LinkedHashSet<Car> carsToCheck = new LinkedHashSet<Car>(); public void solve(int caseIndex) { for (Car car : cars) { if (isSameCharCar(car)) { car.numAddedSameCharCars.put(car.s.charAt(0), 1L); } } // System.out.println(\"Cars: \"+cars); carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); // LinkedHashSet<Car> carsWithSameChar = new LinkedHashSet<Car>(); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); if (isSameCharCar(car)) { for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } } carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } BigInteger result; if (!isValid()) { result = BigInteger.valueOf(0); } else { long mod = 1000000007L; result = BigInteger.valueOf(1); for (long i = 1; i <= cars.size(); i++) { result = result.multiply(BigInteger.valueOf(i)); } for (Car car : cars) { for (Long sameChars : car.numAddedSameCharCars.values()) { long a = 1; for (long i = 1; i <= sameChars; i++) { a *= i; a %= mod; } result = result.multiply(BigInteger.valueOf(a)); } } result = result.mod(BigInteger.valueOf(mod)); } // long result; // if (!isValid()) { // result = 0; // } // else { // long mod = 1000000007L; // // result = 1; // for (long i = 1; i <= cars.size(); i++) { // result *= i; // result %= mod; // } // // for (Car car : cars) { // for (Long sameChars : car.numAddedSameCharCars.values()) { // long a = 1; // for (long i = 1; i <= sameChars; i++) { // a *= i; // a %= mod; // } // result *= a; // result %= mod; // } // } // } println(\"Case #\" + (caseIndex + 1) + \": \" + result); } void combineCars(Car car1, Car car2) { Car car = new Car(); car.s = car1.s + car2.s; car.addAllSameChars(car1); car.addAllSameChars(car2); // car.numAddedSameCharCars = car1.numAddedSameCharCars + car2.numAddedSameCharCars; cars.add(car); carsToCheck.add(car); cars.remove(car1); carsToCheck.remove(car1); cars.remove(car2); carsToCheck.remove(car2); // System.out.println(\"Cars: \"+cars); } boolean isSameCharCar(Car car) { String s = car.s; for (int k = 0; k < s.length(); k++) { if (s.charAt(k) != s.charAt(0)) { return false; } } return true; } boolean isValid() { LinkedHashSet<Character> processed = new LinkedHashSet<>(); Character last = null; for (Car car : cars) { String s = car.s; for (int k = 0; k < s.length(); k++) { char ch = s.charAt(k); // System.out.println(\"Current: \"+ch); if (last != null && last.charValue() == ch) { // System.out.println(\"Last: \"+last+\", processed: \"+processed); } else { if (processed.contains(ch)) return false; processed.add(ch); } last = ch; } } return true; } long factorial(long p) { long result = 1; for (long i = 2; i <= p; i++) result *= i; return result; } } public void run() throws Exception { BufferedReader r = new BufferedReader(new FileReader(\"input.txt\")); int numCases = new InputParser(r.readLine()).readInt(); for (int caseIndex = 0; caseIndex < numCases; caseIndex++) { Case c = new Case(); InputParser p = new InputParser(r.readLine()); int numCars = p.readInt(); p = new InputParser(r.readLine()); for (int i = 0; i < numCars; i++) { Car car = new Car(); car.s = p.readToken(); c.cars.add(car); } c.solve(caseIndex); } r.close(); } public static void main(String[] args) throws Exception { fileWriter = new PrintWriter(new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"output.txt\")))); new ProblemBLarge().run(); fileWriter.close(); } public static class InputParser { String text; int pos; public InputParser(String text) { this.text = text; } public void skipSpaces() { while (pos < text.length()) { if (text.charAt(pos) != \\' \\') break; pos++; } } public String readUntil(char expectedChar) { StringBuilder b = new StringBuilder(); while (pos < text.length()) { char ch = text.charAt(pos); if (ch == expectedChar) break; b.append(ch); pos++; } return b.toString(); } public String readToken() { skipSpaces(); return readUntil(\\' \\'); } public int readInt() { return Integer.parseInt(readToken()); } public long readLong() { return Long.parseLong(readToken()); } public double readDouble() { return Double.parseDouble(readToken()); } public char readChar() { char ch = text.charAt(pos); pos++; return ch; } public void readExpectedString(String s) { for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (readChar() != ch) throw new RuntimeException(\"Expected: \"+ch); } } } public static PrintWriter fileWriter; public static void print(String text) { fileWriter.print(text); System.out.print(text); } public static void println(String text) { fileWriter.println(text); System.out.println(text); } public static <Key, Value> void addToMultiMapArrayList(Key key, Value value, Map<Key, ArrayList<Value>> map) { ArrayList<Value> list = map.get(key); if (list == null) { list = new ArrayList<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> void addToMultiMapLinkedHashSet(Key key, Value value, Map<Key, LinkedHashSet<Value>> map) { LinkedHashSet<Value> list = map.get(key); if (list == null) { list = new LinkedHashSet<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> ArrayList<Value> getMultiMapValues(Map<Key, Collection<Value>> map) { ArrayList<Value> result = new ArrayList<Value>(); for (Collection<Value> list : map.values()) { result.addAll(list); } return result; } // binarySearch(, , 0.000000001, new Function<Double, Integer>() { // public Integer evaluate(Double key) { // return ; // } // }); public static double binarySearch(double low, double high, double precision, Function<Double, Integer> f) { if (high < low) throw new RuntimeException(\"High (\"+high+\") cannot be smaller than low (\"+low+\")\"); { int lowValue = f.evaluate(low); if (lowValue == 0) return low; if (lowValue > 0) throw new RuntimeException(\"Unsuitable low: \"+low); } { int highValue = f.evaluate(high); if (highValue == 0) return high; if (highValue < 0) throw new RuntimeException(\"Unsuitable high: \"+high); } while (true) { double mid = (low + high) * 0.5; if (abs(high - low) < precision) { return mid; } int c = f.evaluate(mid); if (c < 0) low = mid; else if (c > 0) high = mid; else return mid; } } public static <T> LinkedHashSet<T> intersection(Set<T> s1, Set<T> s2) { if (s2.size() < s1.size()) { Set<T> temp = s1; s1 = s2; s2 = temp; } LinkedHashSet<T> result = new LinkedHashSet<T>(); for (T o : s1) { if (s2.contains(o)) result.add(o); } return result; } public static interface Function<Key, Value> { public Value evaluate(Key key); } public static class Int2 { int x, y; public Int2(int x, int y) { this.x = x; this.y = y; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Int2 other = (Int2) obj; if (x != other.x) return false; if (y != other.y) return false; return true; } @Override public String toString() { return \"(\"+x+\",\"+y+\")\"; } } } '"}
{"code1": "#include <iostream> #include <fstream> #include <string> #include <algorithm> #include <cstdlib> #include <cstring> #include <set> #include <map> #include <vector> #include <stack> #include <queue> #include <deque> #include <iomanip> #include <cassert> typedef long long ll; typedef unsigned long long ull; using namespace std; bool is_aaa(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] != c) return false; } return true; } bool is_aax(const string& s, char c) { return s[0] == c; } bool is_yaa(const string& s, char c) { return s[(int)s.size() - 1] == c; } bool is_uav(const string& s, char c) { for (int i = 0; i < (int)s.size(); i++) { if (s[i] == c) return true; } return false; } int fragment_count(const string& s, char c) { int result = 0; int n = (int)s.size(); int i = 0; while (i < n) { if (s[i] != c) i++; else { int j = i; while (j + 1 < n && s[j + 1] == c) j++; result++; i = j + 1; } } return result; } const int MAXN = 109; int N; string s[MAXN]; vector<string> pieces; const ll MOD = 1000000007; ll fact[MAXN]; ll solve(void) { pieces.clear(); for (int i = 0; i < N; i++) pieces.push_back(s[i]); ll result = 1; for (char c = \\'a\\'; c <= \\'z\\'; c++) { vector<string> aaa; vector<string> aax; vector<string> yaa; vector<string> uav; vector<string> other; for (int i = 0; i < pieces.size(); i++) { if (is_aaa(pieces[i], c)) aaa.push_back(pieces[i]); else if (is_aax(pieces[i], c)) aax.push_back(pieces[i]); else if (is_yaa(pieces[i], c)) yaa.push_back(pieces[i]); else if (is_uav(pieces[i], c)) uav.push_back(pieces[i]); else other.push_back(pieces[i]); } if (uav.size() != 0) { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0 && uav.size()==1 && fragment_count(uav[0], c)==1) { ; } else return 0LL; } else { if (aaa.size() == 0 && aax.size() == 0 && yaa.size() == 0) { ; // no constraints at all } else { if (yaa.size() <= 1 && aax.size() <= 1) { if (yaa.size() == 1) { if (fragment_count(yaa[0], c) > 1) return 0LL; } if (aax.size() == 1) { if (fragment_count(aax[0], c) > 1) return 0LL; } result *= fact[aaa.size()]; result %= MOD; pieces = other; string new_piece; if (yaa.size() != 0) new_piece += yaa[0]; for (int i = 0; i < aaa.size(); i++) new_piece += aaa[i]; if (aax.size() != 0) new_piece += aax[0]; pieces.push_back(new_piece); } else return 0LL; } } } result *= fact[pieces.size()]; result %= MOD; return result; } void solve_B(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; fact[0] = 1LL; for (int i = 1; i < MAXN; i++) fact[i] = (fact[i - 1] * i) % MOD; for (int tt = 1; tt <= T; tt++) { for (int i = 0; i < MAXN; i++) s[i] = \"\"; in >> N; for (int i = 0; i < N; i++) in >> s[i]; ll temp = solve(); out << \"Case #\" << tt << \": \"; out << temp; out << \\'\\ \\'; } in.close(); out.close(); } int main() { //solve_A(); solve_B(); //solve_C(); return 0; } void solve_(void) { ifstream in(\"input.txt\"); ofstream out(\"output.txt\"); int T; in >> T; for (int tt = 1; tt <= T; tt++) { out << \"Case #\" << tt << \": \"; } in.close(); out.close(); }'", "code2": "import java.util.HashSet; import java.util.Scanner; import java.util.Set; public class B { static final long BASE = 1000000007; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int cases = sc.nextInt(); long[] factorial = new long[101]; factorial[0] = 1; for (int i = 1; i < 101; i++) { factorial[i] = (factorial[i - 1] * i) % BASE; } for (int caseNum = 1; caseNum <= cases; caseNum++) { int N = sc.nextInt(); String[] cars = new String[N]; Set<Character> interior = new HashSet<Character>(); int[] singleLetterStrs = new int[26]; int[] starts = new int[26]; int[] ends = new int[26]; char[] next = new char[26]; boolean possible = true; for (int i = 0; i < N; i++) { cars[i] = sc.next(); int firstChar = cars[i].charAt(0) - \\'a\\'; char lastChar = cars[i].charAt(cars[i].length() - 1); if (isSingleLetter(cars[i])) { int index = firstChar; singleLetterStrs[index]++; } else { for (Character ch : getInteriorChars(cars[i])) { if (interior.contains(ch)) { possible = false; break; } interior.add(ch); } starts[firstChar]++; ends[lastChar - \\'a\\']++; next[firstChar] = lastChar; } } int numGroups = 0; for (int i = 0; i < 26; i++) { if (!possible) { break; } char ch = (char) (\\'a\\' + i); if (interior.contains(ch) && (singleLetterStrs[i] + starts[i] + ends[i] > 0)) { possible = false; } if (starts[i] > 1 || ends[i] > 1) { possible = false; } if (singleLetterStrs[i] > 0 && starts[i] == 0 && ends[i] == 0) { numGroups++; } else if (starts[i] == 1 && ends[i] == 0) { numGroups++; } } possible = possible && !hasCycles(next); System.out.print(\"Case #\" + caseNum + \": \"); if (!possible) { System.out.println(0); continue; } long ways = 1; for (int i = 0; i < 26; i++) { ways = (ways * factorial[singleLetterStrs[i]]) % BASE; } ways = (ways * factorial[numGroups]) % BASE; System.out.println(ways); } } private static boolean hasCycles(char[] next) { for (int i = 0; i < 26; i++) { if (next[i] == 0) { continue; } char start = (char) (\\'a\\' + i); int currIndex = i; while (next[currIndex] != 0 && next[currIndex] != start) { currIndex = next[currIndex] - \\'a\\'; } if (next[currIndex] == start) { return true; } } return false; } private static Set<Character> getInteriorChars(String str) { Set<Character> chars = new HashSet<Character>(); if (isSingleLetter(str)) { return chars; } int startIndex = 0; while (str.charAt(startIndex + 1) == str.charAt(0)) { startIndex++; } int endIndex = str.length() - 1; while (str.charAt(endIndex - 1) == str.charAt(str.length() - 1)) { endIndex--; } for (int i = startIndex + 1; i < endIndex; i++) { chars.add(str.charAt(i)); } return chars; } private static boolean isSingleLetter(String str) { char ch = str.charAt(0); for (int i = 1; i < str.length(); i++) { if (str.charAt(i) != ch) { return false; } } return true; } } '"}
{"code1": "#include <stdio.h> #include <stdlib.h> #include <math.h> #include <ctype.h> #include <string.h> int TC, T; int Cars; char Car[120][120]; char Visited[130]; int Stack[120]; int Used[120]; int i, x, y, L, Ans; char Last; int DFS(int Level){ if (Level==Cars){ int i, x; Last = Car[Stack[0]][0]; memset(Visited, 0, sizeof(Visited)); Visited[Last] = 1; for (i=0; i<Cars; i++){ L = strlen(Car[Stack[i]]); for (x=0; x<L; x++){ if (Car[Stack[i]][x]==Last) continue; if (Visited[Car[Stack[i]][x]]) return ; Visited[Car[Stack[i]][x]] = 1; Last = Car[Stack[i]][x]; } } Ans++; return ; } int i; for (i=0; i<Cars; i++) if (!Used[i]){ Used[i] = 1; Stack[Level] = i; DFS(Level+1); Used[i] = 0; } } int main(){ freopen(\"B-small-attempt0.in\", \"r\", stdin); freopen(\"B-small-attempt0.out\", \"w\", stdout); scanf(\"%d\", &TC); for (T=1; T<=TC; T++){ printf(\"Case #%d: \", T); scanf(\"%d\", &Cars); for (i=0; i<Cars; i++) scanf(\"%s\", Car[i]); Ans = 0; DFS(0); printf(\"%d\\ \", Ans); } return 0; } '", "code2": "#!/usr/bin/pypy import itertools,math,sys def simple_solve(N,S): S = sorted(S) cnt = 0 for perm in itertools.permutations(S): z = \"\".join(perm) chars = [False for _ in range(26)] last = \\'\\' for c in z: if last==c: continue last = c if chars[ord(c)-ord(\\'a\\')]: break chars[ord(c)-ord(\\'a\\')] = True else: cnt += 1 return cnt def true_solve(N,S): rz = {} for c in range(26): char = chr(c+ord(\\'a\\')) cnt_inside = cnt_left = cnt_right = cnt_full = 0 left_char = right_char = \"\" for z in S: h = False last = \"\" for x in z: if x==char and h and last != char: return 0 if x==char: h = True last = x if z[0] == z[-1] == char: cnt_full += 1 elif z[0] == char: cnt_left += 1 right_char = z[-1] elif z[-1] == char: cnt_right += 1 left_char = z[0] elif h: cnt_inside += 1 if cnt_inside > 1 or cnt_inside > 0 and cnt_left+cnt_right+cnt_full>0 or cnt_left>1 or cnt_right>1: return 0 if cnt_inside == 0 and cnt_left+cnt_right+cnt_full>0: rz[char] = ((left_char,right_char,math.factorial(cnt_full))) blocks = 0 bb = 1 while rz: for c,v in rz.items(): if v[0]==\"\": break else: return 0 del rz[c] bb *= v[2] while v[1] != \"\": if v[1] not in rz: return 0 v = rz.pop(v[1]) bb *= v[2] blocks += 1 return math.factorial(blocks)*bb%1000000007 def solve(): N = int(raw_input()) S = raw_input().strip().split() val1 = true_solve(N,S) #val2 = simple_solve(N,S) #if val1 != val2: # print \"Bad\" # print N,S # print val1,val2 # sys.exit(1) return val1 T = int(raw_input()) for t in range(1,T+1): print \"Case #%d:\"%t,solve() '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Linq; using System.Numerics; using System.Text; using System.Threading.Tasks; namespace GCJ2014R1CB { class Program { /// <summary> /// \\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe6\\x95\\xb0 /// </summary> static int ThreadCount = 1; /// <summary> /// \\xe9\\x80\\xb2\\xe6\\x8d\\x97\\xe3\\x82\\x92\\xe8\\xa1\\xa8\\xe7\\xa4\\xba\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 /// </summary> static bool Verbose = true; static int ProgressInterval = 1; class Solver { public List<string> SolveAll(int threadId, StreamReader sr) { // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ int TestCase = int.Parse(sr.ReadLine()); // ------------ \\xe5\\x88\\x9d\\xe6\\x9c\\x9f\\xe5\\x8c\\x96 ------------ List<string> outputs = new List<string>(); for (int testCase = 0; testCase < TestCase; testCase++) { // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ int N = int.Parse(sr.ReadLine()); string l = sr.ReadLine(); // ------------ \\xe8\\xaa\\xad\\xe3\\x81\\xbf\\xe8\\xbe\\xbc\\xe3\\x81\\xbf ------------ #region if (testCase % ThreadCount != threadId) { // \\xe3\\x81\\x93\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xae\\xe6\\x8b\\x85\\xe5\\xbd\\x93\\xe3\\x81\\xa7\\xe3\\x81\\xaf\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe3\\x81\\xae\\xe3\\x81\\xa7\\xe8\\xa7\\xa3\\xe3\\x81\\x8b\\xe3\\x81\\xaa\\xe3\\x81\\x84 continue; } if (Verbose) { if (testCase % ProgressInterval == 0) { Console.Error.WriteLine(testCase + \" / \" + TestCase); } } #endregion // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ string output = Solve(testCase, l); // ------------ \\xe5\\x91\\xbc\\xe3\\x81\\xb3\\xe5\\x87\\xba\\xe3\\x81\\x97 ------------ outputs.Add(output); } return outputs; } const long Mod = 1000000007; string Solve(int testCase, string l) { if (testCase == -1) { } List<string> ts = l.Split(\\' \\').ToList(); BigInteger ans = 1; for(char c = \\'a\\'; c <= \\'z\\'; c++) { int ct = 0; string ns = \"\"; for(int i = 0; i < ts.Count; i++) { if (ts[i].First() == c && ts[i].Last() == c) { ns += ts[i]; ct++; ans *= ct; ts.RemoveAt(i); i--; } } if (ct > 0) { ts.Add(ns); } } for(;;) { bool f = Update(ts, true); if (f == false) { break; } } for(;;) { bool f = Update(ts, false); if (f == false) { break; } } string all = string.Concat(ts); for(char c = \\'a\\'; c <= \\'z\\'; c++) { int first = all.IndexOf(c); if (first < 0) { continue; } int last = all.LastIndexOf(c); for(int i = first; i < last; i++) { if (all[i] != c) { return \"0\"; } } } for(int i = 1; i <= ts.Count; i++) { ans *= i; } ans %= Mod; return ans.ToString(); } static bool Update(List<string> ts, bool primary) { int N = ts.Count(); for(int i = 0; i < N; i++) { if (primary && ts[i].First() != ts[i].Last()) { continue; } for(int j = 0; j < N; j++) { if (i == j) { continue; } if (ts[i].Last() == ts[j].First()) { ts[i] += ts[j]; ts.RemoveAt(j); return true; } } } return false; } } static void Main(string[] args) { // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\x84\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\x9f\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\xab\\xe5\\xaf\\xbe\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe5\\x87\\xa6\\xe7\\x90\\x86\\xe3\\x82\\x92\\xe8\\xa1\\x8c\\xe3\\x81\\x86\\xe3\\x80\\x82 // \\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x81\\x8c\\xe6\\x8c\\x87\\xe5\\xae\\x9a\\xe3\\x81\\x95\\xe3\\x82\\x8c\\xe3\\x81\\xa6\\xe3\\x81\\xaa\\xe3\\x81\\x84\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe3\\x82\\xab\\xe3\\x83\\xac\\xe3\\x83\\xb3\\xe3\\x83\\x88\\xe3\\x83\\x87\\xe3\\x82\\xa3\\xe3\\x83\\xac\\xe3\\x82\\xaf\\xe3\\x83\\x88\\xe3\\x83\\xaa\\xe3\\x81\\xae large \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81 // small \\xe3\\x81\\xa3\\xe3\\x81\\xbd\\xe3\\x81\\x84\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x80\\x81sample.in \\xe3\\x82\\x92\\xe9\\xa0\\x86\\xe3\\x81\\xab\\xe6\\xa4\\x9c\\xe7\\xb4\\xa2\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 // large \\xe3\\x82\\x84 small \\xe3\\x81\\x8c\\xe8\\xa4\\x87\\xe6\\x95\\xb0\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x80\\x81\\xe5\\x90\\x8d\\xe5\\x89\\x8d\\xe3\\x81\\xa7\\xe3\\x82\\xbd\\xe3\\x83\\xbc\\xe3\\x83\\x88\\xe3\\x81\\x97\\xe3\\x81\\xa6\\xe4\\xb8\\x80\\xe7\\x95\\xaa\\xe6\\x9c\\x80\\xe5\\xbe\\x8c\\xe3\\x81\\xae\\xe3\\x82\\x92\\xe4\\xbd\\xbf\\xe3\\x81\\x86\\xe3\\x80\\x82 string inputName = null; if (args.Length > 0) { if (File.Exists(args[0]) == false) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } inputName = args[0]; } if (inputName == null) { List<string> larges = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"large\") && fi.Name.EndsWith(\".in\")) { larges.Add(fi.FullName); } } if (larges.Count > 0) { larges.Sort(); inputName = larges[larges.Count - 1]; } } if (inputName == null) { List<string> smalls = new List<string>(); foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.Contains(\"small\") && fi.Name.EndsWith(\".in\")) { smalls.Add(fi.FullName); } } if (smalls.Count > 0) { smalls.Sort(); inputName = smalls[smalls.Count - 1]; } } if (inputName == null) { foreach (var fi in new DirectoryInfo(Directory.GetCurrentDirectory()).GetFiles()) { if (fi.Name.ToLower() == \"sample.in\") { inputName = fi.FullName; break; } } } if (inputName == null) { Console.Error.WriteLine(\"\\xe5\\x85\\xa5\\xe5\\x8a\\x9b\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe8\\xa6\\x8b\\xe3\\x81\\xa4\\xe3\\x81\\x8b\\xe3\\x82\\x8a\\xe3\\x81\\xbe\\xe3\\x81\\x9b\\xe3\\x82\\x93\\xe3\\x80\\x82\"); return; } // \\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe5\\x85\\x88\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe5\\x90\\x8d\\xe3\\x82\\x92\\xe6\\xb1\\xba\\xe5\\xae\\x9a\\xe3\\x81\\x97\\xe3\\x80\\x81\\xe5\\x90\\x8c\\xe5\\x90\\x8d\\xe3\\x81\\xae\\xe3\\x83\\x95\\xe3\\x82\\xa1\\xe3\\x82\\xa4\\xe3\\x83\\xab\\xe3\\x81\\x8c\\xe3\\x81\\x82\\xe3\\x82\\x8b\\xe5\\xa0\\xb4\\xe5\\x90\\x88\\xe3\\x81\\xaf\\xe3\\x83\\xaa\\xe3\\x83\\x8d\\xe3\\x83\\xbc\\xe3\\x83\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 string outputName = inputName; if (outputName.EndsWith(\".in\")) { outputName = outputName.Substring(0, outputName.Length - 3); } outputName += \".out\"; if (File.Exists(outputName)) { int rev = 1; while (File.Exists(outputName + \".\" + rev)) { rev++; } File.Move(outputName, outputName + \".\" + rev); } // \\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82ThreadCount == 1 \\xe3\\x81\\xaa\\xe3\\x82\\x89\\xe3\\x80\\x81\\xe7\\x8f\\xbe\\xe5\\x9c\\xa8\\xe3\\x81\\xae\\xe3\\x82\\xb9\\xe3\\x83\\xac\\xe3\\x83\\x83\\xe3\\x83\\x89\\xe3\\x81\\xa7\\xe3\\x80\\x81\\xe3\\x81\\x9d\\xe3\\x82\\x8c\\xe4\\xbb\\xa5\\xe5\\xa4\\x96\\xe3\\x81\\xaa\\xe3\\x82\\x89 Parallel \\xe3\\x81\\xa7\\xe5\\xae\\x9f\\xe8\\xa1\\x8c\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 List<string>[] outputs = new List<string>[ThreadCount]; if (ThreadCount == 1) { for (int i = 0; i < ThreadCount; i++) { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } } } else { Parallel.For(0, ThreadCount, i => { Solver solver = new Solver(); using (StreamReader sr = new StreamReader(inputName)) { outputs[i] = solver.SolveAll(i, sr); } }); } // \\xe7\\xb5\\x90\\xe6\\x9e\\x9c\\xe3\\x82\\x92\\xe5\\x87\\xba\\xe5\\x8a\\x9b\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82Case # \\xe3\\x81\\xaf\\xe3\\x81\\x93\\xe3\\x81\\x93\\xe3\\x81\\xa7\\xe4\\xbb\\x98\\xe5\\x8a\\xa0\\xe3\\x81\\x99\\xe3\\x82\\x8b\\xe3\\x80\\x82 using (StreamWriter sw = new StreamWriter(outputName)) { for (int i = 0; ; i++) { if (outputs[i % ThreadCount].Count > i / ThreadCount) { sw.WriteLine(\"Case #\" + (i + 1) + \": \" + outputs[i % ThreadCount][i / ThreadCount]); } else { break; } } } } } } '", "code2": "#include<stdio.h> #include<stdlib.h> #include<string.h> #define MOD 1000000007LL int t,T,n,N; long long frac[128]; long long C; char s[128][128]; long long ans; char start[128];/*First Letter*/ char end[128];/*Last Letter*/ char blocked[256]; /*Internal characters*/ int first; int tmp; int c; int only_start[256]; int only_end[256]; int loops[256]; int done[256]; int num_frag; char tmp2; char tmp3; int main(){ scanf(\"%d\",&T); frac[0]=1; for(C=1;C<120;C++) frac[C]=(frac[C-1]*C)%MOD; for(t=1;t<=T;t++){ scanf(\"%d\",&N); for(n=1;n<=N;n++){scanf(\"%s\",&s[n][0]);} for(c=0;c<256;c++) { blocked[c]=0; only_start[c]=0; only_end[c]=0; loops[c]=0; } ans=1; for(n=1;n<=N;n++) { tmp=strlen(s[n]); first=1; start[n]=s[n][0]; end[n]=s[n][tmp-1]; for(c=1;c<tmp;c++) { if (s[n][c]!=s[n][c-1]) { if (blocked[s[n][c]]==1) ans=0; if (first==0) { blocked[s[n][c-1]]=1; } first=0; } } if ((start[n]==end[n])&&(first==0)) ans=0; } if (ans==1) { for(n=1;n<=N;n++) { if (blocked[start[n]]==1) ans=0; if (blocked[end[n]]==1) ans=0; } } if (ans==1) { for(n=1;n<=N;n++) { if (start[n]==end[n]) {loops[start[n]]++;} else { only_start[start[n]]++; only_end[end[n]]++; } } for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if (only_start[tmp2]>1) ans=0; if (only_end[tmp2]>1) ans=0; } } if (ans==1) { num_frag=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) num_frag++; if ((only_start[tmp2]==0)&&(only_end[tmp2]==0)&&(loops[tmp2]>0)) num_frag++; ans*=frac[loops[tmp2]]; ans%=MOD; } ans*=frac[num_frag]; ans%=MOD; } /*Detect cycles*/ if (ans!=0) { for(c=0;c<256;c++) done[c]=0; for(tmp2=\\'a\\';tmp2<=\\'z\\';tmp2++){ if ((only_start[tmp2]==1)&&(only_end[tmp2]==0)) { tmp3=tmp2; do{ for(n=1;n<=N;n++) { if ((start[n]==tmp3)&&(start[n]!=end[n])) break; } done[n]=1; tmp3=end[n]; } while (only_start[tmp3]==1); } } for(n=1;n<=N;n++) { if ((done[n]==0)&&(start[n]!=end[n])) ans=0; } } printf(\"Case #%d: \",t); printf(\"%lld\\ \",ans); } return 0; } '"}
{"code1": "//#pragma comment(linker, \"/STACK:134217728\") #include <iostream> #include <sstream> #include <cstdio> #include <cstdlib> #include <cmath> #include <cctype> #include <cstring> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> #include <numeric> using namespace std; typedef long long Int; typedef pair<int,int> PII; typedef vector<int> VInt; #define FOR(i, a, b) for(i = (a); i < (b); ++i) #define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i) #define CLEAR(a, b) memset(a, b, sizeof(a)) #define SIZE(a) int((a).size()) #define ALL(a) (a).begin(),(a).end() #define PB push_back #define MP make_pair #define MOD 1000000007 string S[256]; int A[256]; int C[256]; int Next[256]; int Prev[256]; int B[256]; Int dfs(int a) { if (a == -1) return 1; B[a] = 1; Int res = 1; int i; FOR(i, 0, C[a]) res = res * (i + 1) % MOD; return res * dfs(Next[a]) % MOD; } Int f(int n) { CLEAR(A, 0); CLEAR(C, 0); CLEAR(Next, -1); CLEAR(Prev, -1); int i, j; FOR(i, 0, n) { char first = S[i].front(); char last = S[i].back(); FOR(j, 1, SIZE(S[i]) - 1) { char mid = S[i][j]; if (A[mid] == 0) ++A[mid]; else return 0; } if (first == last) { if (SIZE(S[i]) == 1) ++C[first]; else return 0; } else { if (Next[first] != -1) return 0; if (Prev[last] != -1) return 0; Next[first] = last; Prev[last] = first; } } FOR(i, 0, 256) if (A[i] != 0 && (C[i] != 0 || Next[i] != -1 || Prev[i] != -1)) return 0; Int res = 1; int cnt = 0; CLEAR(B, 0); FOR(i, 0, 256) if (B[i] == 0 && Prev[i] == -1) { if (C[i] != 0 || Next[i] != -1) ++cnt; res *= dfs(i); res %= MOD; } FOR(i, 0, cnt) res = res * (i + 1) % MOD; FOR(i, 0, 256) if (B[i] == 0) return 0; return res; } int SolveTest(int test) { int n; scanf(\"%d\", &n); int i, j; FOR(i, 0, n) { char buf[128]; scanf(\"%s\", buf); int len = strlen(buf); string s; int prev = 0; FOR(j, 1, len + 1) if (j == len || buf[j] != buf[prev]) { s.push_back(buf[prev]); prev = j; } S[i] = s; } printf(\"Case #%d: %d\\ \", test + 1, int(f(n))); return 0; } int main() { freopen(\"b.in\", \"r\", stdin); freopen(\"b.out\", \"w\", stdout); int T, t; char buf[1 << 7]; gets(buf); sscanf(buf, \"%d\", &T); FOR(t, 0, T) { fprintf(stderr, \"Solving %d/%d\\ \", t + 1, T); SolveTest(t); } return 0; }; '", "code2": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.Linq; using System.Text; using System.IO; namespace ProblemA { class Program { static void Main(string[] args) { using (var sr = new StreamReader(@\"..\\\\..\\\\B-small-attempt0.in\")) { using (var sw = new StreamWriter(@\"..\\\\..\\\\B-small-attempt0.out\")) { var T = int.Parse(sr.ReadLine()); for (int t = 1; t <= T; t++) { sr.ReadLine(); var s = sr.ReadLine().Split(); var k = Enumerable.Range(0, s.Length).ToArray(); int res = 0; do { //for (int i = 0; i < k.Length; i++) //{ // Console.Write(k[i]); // Console.Write(\" \"); //} //Console.WriteLine(); //continue; var u = new bool[50]; int i; for (i = 0; i < k.Length; i++) { int j; for (j = 0; j < s[k[i]].Length; j++) { if (u[s[k[i]][j] - \\'a\\']) { if (j > 0) { if (s[k[i]][j - 1] != s[k[i]][j]) { break; } } else { if (s[k[i - 1]][s[k[i - 1]].Length - 1] != s[k[i]][j]) { break; } } } u[s[k[i]][j] - \\'a\\'] = true; } if (j < s[k[i]].Length) { break; } } if (i == k.Length) { res++; } } while (NextPermutation(k)); sw.WriteLine(\"Case #{0}: {1}\", t, res); } } } } private static bool NextPermutation(int[] numList) { /* Knuths 1. Find the largest index j such that a[j] < a[j + 1]. If no such index exists, the permutation is the last permutation. 2. Find the largest index l such that a[j] < a[l]. Since j + 1 is such an index, l is well defined and satisfies j < l. 3. Swap a[j] with a[l]. 4. Reverse the sequence from a[j + 1] up to and including the final element a[n]. */ var largestIndex = -1; for (var i = numList.Length - 2; i >= 0; i--) { if (numList[i] < numList[i + 1]) { largestIndex = i; break; } } if (largestIndex < 0) return false; var largestIndex2 = -1; for (var i = numList.Length - 1; i >= 0; i--) { if (numList[largestIndex] < numList[i]) { largestIndex2 = i; break; } } var tmp = numList[largestIndex]; numList[largestIndex] = numList[largestIndex2]; numList[largestIndex2] = tmp; for (int i = largestIndex + 1, j = numList.Length - 1; i < j; i++, j--) { tmp = numList[i]; numList[i] = numList[j]; numList[j] = tmp; } return true; } } } '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; namespace CodeJam { internal class TestCase { public string[] Cars; } internal class Pair { public char First { get; set; } public char Last { get; set; } } internal class Program { private const string testFileName = \"B-large\"; private const int Base = 1000000007; public static IEnumerable<TestCase> ParseCases(TextReader reader) { var testCaseCount = int.Parse(reader.ReadLine()); for (var i = 0; i < testCaseCount; i++) { var carCount = int.Parse(reader.ReadLine()); var cars = reader.ReadLine().Split(); yield return new TestCase { Cars = cars }; } } private static long Solve(TestCase testCase) { // 3 types of cars // single letters: aaa // two letters: aabb // multiple letters aabcddd // simplify consecutive letters var withoutRuns = testCase.Cars.Select(RemoveConsecutive).ToArray(); var singleLetters = withoutRuns.Where(c => c.Length == 1).Select(c => c[0]).ToArray(); var hiddenLetters = withoutRuns.Where(c => c.Length > 2).SelectMany(c => c.Substring(1, c.Length - 2)).Distinct().ToArray(); var pairs = withoutRuns.Where(c => c.Length > 1).Select(c => new Pair { First = c[0], Last = c[c.Length - 1] }).ToArray(); // eliminate case 3 now if (pairs.Any(p => hiddenLetters.Contains(p.First) || hiddenLetters.Contains(p.Last)) || singleLetters.Any(hiddenLetters.Contains)) return 0; // we know just have to find orderings for pairs and single letters. // check that all the pairs can be ordered successfully if (pairs.Select(p => p.First).Distinct().Count() != pairs.Count() || pairs.Select(p => p.Last).Distinct().Count() != pairs.Count()) return 0; //check the groups that have an order imposed on them by the pairs var sortedPairs = GetFixedChains(pairs); if (sortedPairs == null) return 0; var singleLetterCounts = singleLetters.GroupBy(c => c, (key, values) => Tuple.Create(key, values.Count())); var lettersInChains = sortedPairs.SelectMany(p => p).SelectMany(p => new[] { p.First, p.Last }).Distinct(); var independentSingleLetters = singleLetters.Except(lettersInChains).ToArray(); // single letters can be in any order relative to each other long combinations = 1; foreach (var pair in singleLetterCounts) { combinations *= Factorial(pair.Item2); combinations %= Base; } // chains can be in any order relative to each other, and to the independent letters var independentBlockCount = independentSingleLetters.Count() + sortedPairs.Length; combinations *= Factorial(independentBlockCount); combinations %= Base; return combinations; } private static long Factorial(int x) { long fact = 1; while (x > 1) { fact *= x; fact %= Base; x--; } return fact; } private static Pair[][] GetFixedChains(Pair[] pairs) { var remainingPairs = pairs.ToList(); var sorted = new List<Pair[]>(); while (remainingPairs.Count > 0) { var chain = new List<Pair>(); var current = remainingPairs[0]; remainingPairs.RemoveAt(0); chain.Add(current); int index; var first = current; while ((index = remainingPairs.FindIndex(p => p.Last == first.First)) >= 0) { first = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Insert(0, first); } var last = current; while ((index = remainingPairs.FindIndex(p => p.First == last.Last)) >= 0) { last = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Add(last); } if (last.Last == first.First) return null; sorted.Add(chain.ToArray()); } return sorted.ToArray(); } private static string RemoveConsecutive(string arg) { var builder = new StringBuilder(arg.Length); char current = \\'\\\\0\\'; foreach (var c in arg) { if (c != current) { builder.Append(c); current = c; } } return builder.ToString(); } private static void Main(string[] args) { TestCase[] cases; using (var reader = new StreamReader(testFileName + \".in\")) using (var writer = new StreamWriter(testFileName + \".out\")) { cases = ParseCases(reader).ToArray(); for (int caseIndex = 0; caseIndex < cases.Length; caseIndex++) { var testCase = cases[caseIndex]; var solution = Solve(testCase); writer.WriteLine(\"Case #{0}: {1}\", caseIndex + 1, solution); } } } } }'", "code2": "#include <stdio.h> #include <stdlib.h> #include <string.h> #define M 1000000007LL //char *train[10]; int N; int count; int embedded[26]; int oneletter[26]; int endswith[26]; int startswith[26]; int impossible=0; int used; int segment; char *destutter(char *s) { static char buf2[200]; char *d=buf2; char last=0; while (*s) { if (*s!=last) last=*d++ = *s; s++; } *d=0; return buf2; } void readtrains(void) { int i,len,j; static char buff[200]; char *b; impossible=0; scanf(\"%d\",&N); for (i=0;i<26;i++) { embedded[i]=0; oneletter[i]=0; endswith[i]=-1; startswith[i]=-1; } for (i=0;i<N;i++) { scanf(\"%s\",buff); b=destutter(buff); len=strlen(b); if (len==1) { oneletter[*b-\\'a\\']++; continue; } if (startswith[*b-\\'a\\']>=0) impossible++; if (endswith[b[len-1]-\\'a\\']>=0) impossible++; startswith[*b-\\'a\\']=b[len-1]-\\'a\\'; endswith[b[len-1]-\\'a\\']=*b-\\'a\\'; for (j=1;j<len-1;j++) embedded[b[j]-\\'a\\']++; } } int modtimes(int a, int b) { return (int)((1LL*a*b) % M); } int factorial(int n) { int f=1; int i; if (n<=1) return 1; for (i=2;i<=n;i++) f=modtimes(f,i); return f; } void countonlyi(int i) { segment++; //printf(\"countonly %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); } void countendi(int i) { segment++; //printf(\"countend %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! while (1) { if ((1<<i) & used) {impossible++;return;} used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); i=endswith[i]; if (i<0) break; } } void countstarti(int i) { int used2=1<<i; //printf(\" Cs %c\\ \",i+\\'a\\'); while (startswith[i]>=0) { i=startswith[i]; //printf(\" cs %c\\ \",i+\\'a\\'); if (used2 & (1<<i)) { //printf(\"imp\\ \"); impossible++;return; } used2|=1<<i; } countendi(i); } void counttrains(void) { int i; count=1; used=0; segment=0; for (i=0;i<26;i++) { if (impossible || embedded[i]>1 || embedded[i] && (startswith[i]>=0 || endswith[i]>=0)) { printf(\"0\\ \"); //impossible return; } } i=0; while (i<26 && !impossible) { if (startswith[i]>=0 && !((1<<i) & used)) countstarti(i); if (endswith[i]>=0 && !((1<<i) & used)) countendi(i); if (oneletter[i]>0 && !((1<<i) & used)) countonlyi(i); i++; } if (impossible) printf(\"0\\ \"); else printf(\"%d\\ \",count); } void dump(void) { int i; printf(\"\\ \"); for (i=0;i<26;i++) { if (startswith[i]<0 && endswith[i]<0 && embedded[i]==0 && oneletter[i]==0) continue; printf(\" %c : ->%c %c<- em=%d 1L=%d\\ \",i+\\'a\\',startswith[i]+\\'a\\',endswith[i]+\\'a\\',embedded[i],oneletter[i]); } } int main(int argc, char **argv) { int tc,i; scanf(\"%d\",&tc); for (i=1;i<=tc;i++) { printf(\"Case #%d: \",i); readtrains(); //dump(); counttrains(); } return 0; } '"}
{"code1": "// uses http://introcs.cs.princeton.edu/java/stdlib/StdIn.java public class Train { static final int MOD = 1_000_000_007; public static long calc(String[] cars) { long result = 1; int n = cars.length; for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) { //System.out.println(java.util.Arrays.toString(cars)); int solocount = 0; int start = -1; int mid = -1; int end = -1; int solo = -1; for (int i=0; i<n; i++) { if (cars[i] == null) { } else if (cars[i].matches(\"\"+ch+\\'+\\')) { solocount++; result *= solocount; result %= MOD; cars[i] = null; solo = i; } else if (cars[i].matches(ch+\"+[^\"+ch+\"]+\")) { if (start != -1) return 0; start = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+\")) { if (end != -1) return 0; end = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+[^\"+ch+\"]+\")) { if (mid != -1) return 0; mid = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\")) { } else return 0; } //System.out.println(ch+\" \"+solocount+\" \"+start+\" \"+solo+\" \"+end+\" \"+result); if (mid == -1 && solocount == 0 && start == -1 && end == -1) continue; if (mid != -1 && (solocount > 0 || start != -1 || end != -1)) return 0; if (mid != -1) continue; String repl = \"\"; if (end != -1) {repl += cars[end]; cars[end] = null;} if (solo != -1) repl += ch; if (start != -1) {repl += cars[start]; cars[start] = null;} if (start != -1) {cars[start] = repl;} else if (solo != -1) {cars[solo] = repl;} else cars[end] = repl; } int left = 0; for (String s : cars) if (s != null) { left ++; result *= left; result %= MOD; } return result; } public static void main(String[] args) { int q = StdIn.readInt(); for (int j=1; j<=q; j++) { int n = StdIn.readInt(); String[] cars = new String[n]; { for (int i=0; i<n; i++) cars[i] = StdIn.readString(); } System.out.printf(\"Case #%d: %d\\ \", j, calc(cars)); } } } '", "code2": "import static java.lang.Math.*; import java.io.*; import java.math.*; import java.util.*; public class ProblemBLarge { static class Car { String s; LinkedHashMap<Character, Long> numAddedSameCharCars = new LinkedHashMap<Character, Long>(); char getFirst() { return s.charAt(0); } char getLast() { return s.charAt(s.length() - 1); } void addAllSameChars(Car car) { for (Map.Entry<Character, Long> entry : car.numAddedSameCharCars.entrySet()) { Character key = entry.getKey(); Long value = numAddedSameCharCars.get(key); if (value == null) value = 0L; value += entry.getValue(); numAddedSameCharCars.put(key, value); } } @Override public String toString() { return \"\"+s+\" (\"+numAddedSameCharCars+\")\"; } } public class Case { LinkedHashSet<Car> cars = new LinkedHashSet<Car>(); LinkedHashSet<Car> carsToCheck = new LinkedHashSet<Car>(); public void solve(int caseIndex) { for (Car car : cars) { if (isSameCharCar(car)) { car.numAddedSameCharCars.put(car.s.charAt(0), 1L); } } // System.out.println(\"Cars: \"+cars); carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); // LinkedHashSet<Car> carsWithSameChar = new LinkedHashSet<Car>(); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); if (isSameCharCar(car)) { for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } } carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } BigInteger result; if (!isValid()) { result = BigInteger.valueOf(0); } else { long mod = 1000000007L; result = BigInteger.valueOf(1); for (long i = 1; i <= cars.size(); i++) { result = result.multiply(BigInteger.valueOf(i)); } for (Car car : cars) { for (Long sameChars : car.numAddedSameCharCars.values()) { long a = 1; for (long i = 1; i <= sameChars; i++) { a *= i; a %= mod; } result = result.multiply(BigInteger.valueOf(a)); } } result = result.mod(BigInteger.valueOf(mod)); } // long result; // if (!isValid()) { // result = 0; // } // else { // long mod = 1000000007L; // // result = 1; // for (long i = 1; i <= cars.size(); i++) { // result *= i; // result %= mod; // } // // for (Car car : cars) { // for (Long sameChars : car.numAddedSameCharCars.values()) { // long a = 1; // for (long i = 1; i <= sameChars; i++) { // a *= i; // a %= mod; // } // result *= a; // result %= mod; // } // } // } println(\"Case #\" + (caseIndex + 1) + \": \" + result); } void combineCars(Car car1, Car car2) { Car car = new Car(); car.s = car1.s + car2.s; car.addAllSameChars(car1); car.addAllSameChars(car2); // car.numAddedSameCharCars = car1.numAddedSameCharCars + car2.numAddedSameCharCars; cars.add(car); carsToCheck.add(car); cars.remove(car1); carsToCheck.remove(car1); cars.remove(car2); carsToCheck.remove(car2); // System.out.println(\"Cars: \"+cars); } boolean isSameCharCar(Car car) { String s = car.s; for (int k = 0; k < s.length(); k++) { if (s.charAt(k) != s.charAt(0)) { return false; } } return true; } boolean isValid() { LinkedHashSet<Character> processed = new LinkedHashSet<>(); Character last = null; for (Car car : cars) { String s = car.s; for (int k = 0; k < s.length(); k++) { char ch = s.charAt(k); // System.out.println(\"Current: \"+ch); if (last != null && last.charValue() == ch) { // System.out.println(\"Last: \"+last+\", processed: \"+processed); } else { if (processed.contains(ch)) return false; processed.add(ch); } last = ch; } } return true; } long factorial(long p) { long result = 1; for (long i = 2; i <= p; i++) result *= i; return result; } } public void run() throws Exception { BufferedReader r = new BufferedReader(new FileReader(\"input.txt\")); int numCases = new InputParser(r.readLine()).readInt(); for (int caseIndex = 0; caseIndex < numCases; caseIndex++) { Case c = new Case(); InputParser p = new InputParser(r.readLine()); int numCars = p.readInt(); p = new InputParser(r.readLine()); for (int i = 0; i < numCars; i++) { Car car = new Car(); car.s = p.readToken(); c.cars.add(car); } c.solve(caseIndex); } r.close(); } public static void main(String[] args) throws Exception { fileWriter = new PrintWriter(new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"output.txt\")))); new ProblemBLarge().run(); fileWriter.close(); } public static class InputParser { String text; int pos; public InputParser(String text) { this.text = text; } public void skipSpaces() { while (pos < text.length()) { if (text.charAt(pos) != \\' \\') break; pos++; } } public String readUntil(char expectedChar) { StringBuilder b = new StringBuilder(); while (pos < text.length()) { char ch = text.charAt(pos); if (ch == expectedChar) break; b.append(ch); pos++; } return b.toString(); } public String readToken() { skipSpaces(); return readUntil(\\' \\'); } public int readInt() { return Integer.parseInt(readToken()); } public long readLong() { return Long.parseLong(readToken()); } public double readDouble() { return Double.parseDouble(readToken()); } public char readChar() { char ch = text.charAt(pos); pos++; return ch; } public void readExpectedString(String s) { for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (readChar() != ch) throw new RuntimeException(\"Expected: \"+ch); } } } public static PrintWriter fileWriter; public static void print(String text) { fileWriter.print(text); System.out.print(text); } public static void println(String text) { fileWriter.println(text); System.out.println(text); } public static <Key, Value> void addToMultiMapArrayList(Key key, Value value, Map<Key, ArrayList<Value>> map) { ArrayList<Value> list = map.get(key); if (list == null) { list = new ArrayList<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> void addToMultiMapLinkedHashSet(Key key, Value value, Map<Key, LinkedHashSet<Value>> map) { LinkedHashSet<Value> list = map.get(key); if (list == null) { list = new LinkedHashSet<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> ArrayList<Value> getMultiMapValues(Map<Key, Collection<Value>> map) { ArrayList<Value> result = new ArrayList<Value>(); for (Collection<Value> list : map.values()) { result.addAll(list); } return result; } // binarySearch(, , 0.000000001, new Function<Double, Integer>() { // public Integer evaluate(Double key) { // return ; // } // }); public static double binarySearch(double low, double high, double precision, Function<Double, Integer> f) { if (high < low) throw new RuntimeException(\"High (\"+high+\") cannot be smaller than low (\"+low+\")\"); { int lowValue = f.evaluate(low); if (lowValue == 0) return low; if (lowValue > 0) throw new RuntimeException(\"Unsuitable low: \"+low); } { int highValue = f.evaluate(high); if (highValue == 0) return high; if (highValue < 0) throw new RuntimeException(\"Unsuitable high: \"+high); } while (true) { double mid = (low + high) * 0.5; if (abs(high - low) < precision) { return mid; } int c = f.evaluate(mid); if (c < 0) low = mid; else if (c > 0) high = mid; else return mid; } } public static <T> LinkedHashSet<T> intersection(Set<T> s1, Set<T> s2) { if (s2.size() < s1.size()) { Set<T> temp = s1; s1 = s2; s2 = temp; } LinkedHashSet<T> result = new LinkedHashSet<T>(); for (T o : s1) { if (s2.contains(o)) result.add(o); } return result; } public static interface Function<Key, Value> { public Value evaluate(Key key); } public static class Int2 { int x, y; public Int2(int x, int y) { this.x = x; this.y = y; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Int2 other = (Int2) obj; if (x != other.x) return false; if (y != other.y) return false; return true; } @Override public String toString() { return \"(\"+x+\",\"+y+\")\"; } } } '"}
{"code1": "\\xef\\xbb\\xbfusing System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; namespace CodeJam { internal class TestCase { public string[] Cars; } internal class Pair { public char First { get; set; } public char Last { get; set; } } internal class Program { private const string testFileName = \"B-large\"; private const int Base = 1000000007; public static IEnumerable<TestCase> ParseCases(TextReader reader) { var testCaseCount = int.Parse(reader.ReadLine()); for (var i = 0; i < testCaseCount; i++) { var carCount = int.Parse(reader.ReadLine()); var cars = reader.ReadLine().Split(); yield return new TestCase { Cars = cars }; } } private static long Solve(TestCase testCase) { // 3 types of cars // single letters: aaa // two letters: aabb // multiple letters aabcddd // simplify consecutive letters var withoutRuns = testCase.Cars.Select(RemoveConsecutive).ToArray(); var singleLetters = withoutRuns.Where(c => c.Length == 1).Select(c => c[0]).ToArray(); var hiddenLetters = withoutRuns.Where(c => c.Length > 2).SelectMany(c => c.Substring(1, c.Length - 2)).Distinct().ToArray(); var pairs = withoutRuns.Where(c => c.Length > 1).Select(c => new Pair { First = c[0], Last = c[c.Length - 1] }).ToArray(); // eliminate case 3 now if (pairs.Any(p => hiddenLetters.Contains(p.First) || hiddenLetters.Contains(p.Last)) || singleLetters.Any(hiddenLetters.Contains)) return 0; // we know just have to find orderings for pairs and single letters. // check that all the pairs can be ordered successfully if (pairs.Select(p => p.First).Distinct().Count() != pairs.Count() || pairs.Select(p => p.Last).Distinct().Count() != pairs.Count()) return 0; //check the groups that have an order imposed on them by the pairs var sortedPairs = GetFixedChains(pairs); if (sortedPairs == null) return 0; var singleLetterCounts = singleLetters.GroupBy(c => c, (key, values) => Tuple.Create(key, values.Count())); var lettersInChains = sortedPairs.SelectMany(p => p).SelectMany(p => new[] { p.First, p.Last }).Distinct(); var independentSingleLetters = singleLetters.Except(lettersInChains).ToArray(); // single letters can be in any order relative to each other long combinations = 1; foreach (var pair in singleLetterCounts) { combinations *= Factorial(pair.Item2); combinations %= Base; } // chains can be in any order relative to each other, and to the independent letters var independentBlockCount = independentSingleLetters.Count() + sortedPairs.Length; combinations *= Factorial(independentBlockCount); combinations %= Base; return combinations; } private static long Factorial(int x) { long fact = 1; while (x > 1) { fact *= x; fact %= Base; x--; } return fact; } private static Pair[][] GetFixedChains(Pair[] pairs) { var remainingPairs = pairs.ToList(); var sorted = new List<Pair[]>(); while (remainingPairs.Count > 0) { var chain = new List<Pair>(); var current = remainingPairs[0]; remainingPairs.RemoveAt(0); chain.Add(current); int index; var first = current; while ((index = remainingPairs.FindIndex(p => p.Last == first.First)) >= 0) { first = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Insert(0, first); } var last = current; while ((index = remainingPairs.FindIndex(p => p.First == last.Last)) >= 0) { last = remainingPairs[index]; remainingPairs.RemoveAt(index); chain.Add(last); } if (last.Last == first.First) return null; sorted.Add(chain.ToArray()); } return sorted.ToArray(); } private static string RemoveConsecutive(string arg) { var builder = new StringBuilder(arg.Length); char current = \\'\\\\0\\'; foreach (var c in arg) { if (c != current) { builder.Append(c); current = c; } } return builder.ToString(); } private static void Main(string[] args) { TestCase[] cases; using (var reader = new StreamReader(testFileName + \".in\")) using (var writer = new StreamWriter(testFileName + \".out\")) { cases = ParseCases(reader).ToArray(); for (int caseIndex = 0; caseIndex < cases.Length; caseIndex++) { var testCase = cases[caseIndex]; var solution = Solve(testCase); writer.WriteLine(\"Case #{0}: {1}\", caseIndex + 1, solution); } } } } }'", "code2": "#include <stdio.h> #include <stdlib.h> #include <string.h> #define M 1000000007LL //char *train[10]; int N; int count; int embedded[26]; int oneletter[26]; int endswith[26]; int startswith[26]; int impossible=0; int used; int segment; char *destutter(char *s) { static char buf2[200]; char *d=buf2; char last=0; while (*s) { if (*s!=last) last=*d++ = *s; s++; } *d=0; return buf2; } void readtrains(void) { int i,len,j; static char buff[200]; char *b; impossible=0; scanf(\"%d\",&N); for (i=0;i<26;i++) { embedded[i]=0; oneletter[i]=0; endswith[i]=-1; startswith[i]=-1; } for (i=0;i<N;i++) { scanf(\"%s\",buff); b=destutter(buff); len=strlen(b); if (len==1) { oneletter[*b-\\'a\\']++; continue; } if (startswith[*b-\\'a\\']>=0) impossible++; if (endswith[b[len-1]-\\'a\\']>=0) impossible++; startswith[*b-\\'a\\']=b[len-1]-\\'a\\'; endswith[b[len-1]-\\'a\\']=*b-\\'a\\'; for (j=1;j<len-1;j++) embedded[b[j]-\\'a\\']++; } } int modtimes(int a, int b) { return (int)((1LL*a*b) % M); } int factorial(int n) { int f=1; int i; if (n<=1) return 1; for (i=2;i<=n;i++) f=modtimes(f,i); return f; } void countonlyi(int i) { segment++; //printf(\"countonly %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); } void countendi(int i) { segment++; //printf(\"countend %c seg=%d\\ \",\\'a\\'+i,segment); count=modtimes(count,segment); //for segment! while (1) { if ((1<<i) & used) {impossible++;return;} used |= 1<<i; count=modtimes(count,factorial(oneletter[i])); i=endswith[i]; if (i<0) break; } } void countstarti(int i) { int used2=1<<i; //printf(\" Cs %c\\ \",i+\\'a\\'); while (startswith[i]>=0) { i=startswith[i]; //printf(\" cs %c\\ \",i+\\'a\\'); if (used2 & (1<<i)) { //printf(\"imp\\ \"); impossible++;return; } used2|=1<<i; } countendi(i); } void counttrains(void) { int i; count=1; used=0; segment=0; for (i=0;i<26;i++) { if (impossible || embedded[i]>1 || embedded[i] && (startswith[i]>=0 || endswith[i]>=0)) { printf(\"0\\ \"); //impossible return; } } i=0; while (i<26 && !impossible) { if (startswith[i]>=0 && !((1<<i) & used)) countstarti(i); if (endswith[i]>=0 && !((1<<i) & used)) countendi(i); if (oneletter[i]>0 && !((1<<i) & used)) countonlyi(i); i++; } if (impossible) printf(\"0\\ \"); else printf(\"%d\\ \",count); } void dump(void) { int i; printf(\"\\ \"); for (i=0;i<26;i++) { if (startswith[i]<0 && endswith[i]<0 && embedded[i]==0 && oneletter[i]==0) continue; printf(\" %c : ->%c %c<- em=%d 1L=%d\\ \",i+\\'a\\',startswith[i]+\\'a\\',endswith[i]+\\'a\\',embedded[i],oneletter[i]); } } int main(int argc, char **argv) { int tc,i; scanf(\"%d\",&tc); for (i=1;i<=tc;i++) { printf(\"Case #%d: \",i); readtrains(); //dump(); counttrains(); } return 0; } '"}
{"code1": "// uses http://introcs.cs.princeton.edu/java/stdlib/StdIn.java public class Train { static final int MOD = 1_000_000_007; public static long calc(String[] cars) { long result = 1; int n = cars.length; for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) { //System.out.println(java.util.Arrays.toString(cars)); int solocount = 0; int start = -1; int mid = -1; int end = -1; int solo = -1; for (int i=0; i<n; i++) { if (cars[i] == null) { } else if (cars[i].matches(\"\"+ch+\\'+\\')) { solocount++; result *= solocount; result %= MOD; cars[i] = null; solo = i; } else if (cars[i].matches(ch+\"+[^\"+ch+\"]+\")) { if (start != -1) return 0; start = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+\")) { if (end != -1) return 0; end = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\"+ch+\"+[^\"+ch+\"]+\")) { if (mid != -1) return 0; mid = i; } else if (cars[i].matches(\"[^\"+ch+\"]+\")) { } else return 0; } //System.out.println(ch+\" \"+solocount+\" \"+start+\" \"+solo+\" \"+end+\" \"+result); if (mid == -1 && solocount == 0 && start == -1 && end == -1) continue; if (mid != -1 && (solocount > 0 || start != -1 || end != -1)) return 0; if (mid != -1) continue; String repl = \"\"; if (end != -1) {repl += cars[end]; cars[end] = null;} if (solo != -1) repl += ch; if (start != -1) {repl += cars[start]; cars[start] = null;} if (start != -1) {cars[start] = repl;} else if (solo != -1) {cars[solo] = repl;} else cars[end] = repl; } int left = 0; for (String s : cars) if (s != null) { left ++; result *= left; result %= MOD; } return result; } public static void main(String[] args) { int q = StdIn.readInt(); for (int j=1; j<=q; j++) { int n = StdIn.readInt(); String[] cars = new String[n]; { for (int i=0; i<n; i++) cars[i] = StdIn.readString(); } System.out.printf(\"Case #%d: %d\\ \", j, calc(cars)); } } } '", "code2": "import static java.lang.Math.*; import java.io.*; import java.math.*; import java.util.*; public class ProblemBLarge { static class Car { String s; LinkedHashMap<Character, Long> numAddedSameCharCars = new LinkedHashMap<Character, Long>(); char getFirst() { return s.charAt(0); } char getLast() { return s.charAt(s.length() - 1); } void addAllSameChars(Car car) { for (Map.Entry<Character, Long> entry : car.numAddedSameCharCars.entrySet()) { Character key = entry.getKey(); Long value = numAddedSameCharCars.get(key); if (value == null) value = 0L; value += entry.getValue(); numAddedSameCharCars.put(key, value); } } @Override public String toString() { return \"\"+s+\" (\"+numAddedSameCharCars+\")\"; } } public class Case { LinkedHashSet<Car> cars = new LinkedHashSet<Car>(); LinkedHashSet<Car> carsToCheck = new LinkedHashSet<Car>(); public void solve(int caseIndex) { for (Car car : cars) { if (isSameCharCar(car)) { car.numAddedSameCharCars.put(car.s.charAt(0), 1L); } } // System.out.println(\"Cars: \"+cars); carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); // LinkedHashSet<Car> carsWithSameChar = new LinkedHashSet<Car>(); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); if (isSameCharCar(car)) { for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } } carsToCheck = new LinkedHashSet<Car>(); carsToCheck.addAll(cars); while (!carsToCheck.isEmpty()) { Car car = carsToCheck.iterator().next(); carsToCheck.remove(car); for (Car car2 : cars) { if (car2 != car) { if (car2.getLast() == car.getFirst()) { combineCars(car2, car); break; } else if (car.getLast() == car2.getFirst()) { combineCars(car, car2); break; } } } } BigInteger result; if (!isValid()) { result = BigInteger.valueOf(0); } else { long mod = 1000000007L; result = BigInteger.valueOf(1); for (long i = 1; i <= cars.size(); i++) { result = result.multiply(BigInteger.valueOf(i)); } for (Car car : cars) { for (Long sameChars : car.numAddedSameCharCars.values()) { long a = 1; for (long i = 1; i <= sameChars; i++) { a *= i; a %= mod; } result = result.multiply(BigInteger.valueOf(a)); } } result = result.mod(BigInteger.valueOf(mod)); } // long result; // if (!isValid()) { // result = 0; // } // else { // long mod = 1000000007L; // // result = 1; // for (long i = 1; i <= cars.size(); i++) { // result *= i; // result %= mod; // } // // for (Car car : cars) { // for (Long sameChars : car.numAddedSameCharCars.values()) { // long a = 1; // for (long i = 1; i <= sameChars; i++) { // a *= i; // a %= mod; // } // result *= a; // result %= mod; // } // } // } println(\"Case #\" + (caseIndex + 1) + \": \" + result); } void combineCars(Car car1, Car car2) { Car car = new Car(); car.s = car1.s + car2.s; car.addAllSameChars(car1); car.addAllSameChars(car2); // car.numAddedSameCharCars = car1.numAddedSameCharCars + car2.numAddedSameCharCars; cars.add(car); carsToCheck.add(car); cars.remove(car1); carsToCheck.remove(car1); cars.remove(car2); carsToCheck.remove(car2); // System.out.println(\"Cars: \"+cars); } boolean isSameCharCar(Car car) { String s = car.s; for (int k = 0; k < s.length(); k++) { if (s.charAt(k) != s.charAt(0)) { return false; } } return true; } boolean isValid() { LinkedHashSet<Character> processed = new LinkedHashSet<>(); Character last = null; for (Car car : cars) { String s = car.s; for (int k = 0; k < s.length(); k++) { char ch = s.charAt(k); // System.out.println(\"Current: \"+ch); if (last != null && last.charValue() == ch) { // System.out.println(\"Last: \"+last+\", processed: \"+processed); } else { if (processed.contains(ch)) return false; processed.add(ch); } last = ch; } } return true; } long factorial(long p) { long result = 1; for (long i = 2; i <= p; i++) result *= i; return result; } } public void run() throws Exception { BufferedReader r = new BufferedReader(new FileReader(\"input.txt\")); int numCases = new InputParser(r.readLine()).readInt(); for (int caseIndex = 0; caseIndex < numCases; caseIndex++) { Case c = new Case(); InputParser p = new InputParser(r.readLine()); int numCars = p.readInt(); p = new InputParser(r.readLine()); for (int i = 0; i < numCars; i++) { Car car = new Car(); car.s = p.readToken(); c.cars.add(car); } c.solve(caseIndex); } r.close(); } public static void main(String[] args) throws Exception { fileWriter = new PrintWriter(new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"output.txt\")))); new ProblemBLarge().run(); fileWriter.close(); } public static class InputParser { String text; int pos; public InputParser(String text) { this.text = text; } public void skipSpaces() { while (pos < text.length()) { if (text.charAt(pos) != \\' \\') break; pos++; } } public String readUntil(char expectedChar) { StringBuilder b = new StringBuilder(); while (pos < text.length()) { char ch = text.charAt(pos); if (ch == expectedChar) break; b.append(ch); pos++; } return b.toString(); } public String readToken() { skipSpaces(); return readUntil(\\' \\'); } public int readInt() { return Integer.parseInt(readToken()); } public long readLong() { return Long.parseLong(readToken()); } public double readDouble() { return Double.parseDouble(readToken()); } public char readChar() { char ch = text.charAt(pos); pos++; return ch; } public void readExpectedString(String s) { for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (readChar() != ch) throw new RuntimeException(\"Expected: \"+ch); } } } public static PrintWriter fileWriter; public static void print(String text) { fileWriter.print(text); System.out.print(text); } public static void println(String text) { fileWriter.println(text); System.out.println(text); } public static <Key, Value> void addToMultiMapArrayList(Key key, Value value, Map<Key, ArrayList<Value>> map) { ArrayList<Value> list = map.get(key); if (list == null) { list = new ArrayList<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> void addToMultiMapLinkedHashSet(Key key, Value value, Map<Key, LinkedHashSet<Value>> map) { LinkedHashSet<Value> list = map.get(key); if (list == null) { list = new LinkedHashSet<Value>(); map.put(key, list); } list.add(value); } public static <Key, Value> ArrayList<Value> getMultiMapValues(Map<Key, Collection<Value>> map) { ArrayList<Value> result = new ArrayList<Value>(); for (Collection<Value> list : map.values()) { result.addAll(list); } return result; } // binarySearch(, , 0.000000001, new Function<Double, Integer>() { // public Integer evaluate(Double key) { // return ; // } // }); public static double binarySearch(double low, double high, double precision, Function<Double, Integer> f) { if (high < low) throw new RuntimeException(\"High (\"+high+\") cannot be smaller than low (\"+low+\")\"); { int lowValue = f.evaluate(low); if (lowValue == 0) return low; if (lowValue > 0) throw new RuntimeException(\"Unsuitable low: \"+low); } { int highValue = f.evaluate(high); if (highValue == 0) return high; if (highValue < 0) throw new RuntimeException(\"Unsuitable high: \"+high); } while (true) { double mid = (low + high) * 0.5; if (abs(high - low) < precision) { return mid; } int c = f.evaluate(mid); if (c < 0) low = mid; else if (c > 0) high = mid; else return mid; } } public static <T> LinkedHashSet<T> intersection(Set<T> s1, Set<T> s2) { if (s2.size() < s1.size()) { Set<T> temp = s1; s1 = s2; s2 = temp; } LinkedHashSet<T> result = new LinkedHashSet<T>(); for (T o : s1) { if (s2.contains(o)) result.add(o); } return result; } public static interface Function<Key, Value> { public Value evaluate(Key key); } public static class Int2 { int x, y; public Int2(int x, int y) { this.x = x; this.y = y; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Int2 other = (Int2) obj; if (x != other.x) return false; if (y != other.y) return false; return true; } @Override public String toString() { return \"(\"+x+\",\"+y+\")\"; } } } '"}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
{"code1": "", "code2": ""}
